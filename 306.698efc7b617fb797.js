"use strict";(self.webpackChunkweb_building=self.webpackChunkweb_building||[]).push([[306],{5306:(ca,c,o)=>{o.r(c),o.d(c,{TsBookModule:()=>la});var n={};o.r(n),o.d(n,{ts_10_1_1:()=>yt,ts_10_1_2:()=>xt,ts_10_1_3:()=>ft,ts_10_2_1:()=>ht,ts_10_2_1_1:()=>_t,ts_10_2_2:()=>bt,ts_10_2_2_1:()=>Tt,ts_10_2_3:()=>At,ts_10_2_3_1:()=>St,ts_10_2_4:()=>wt,ts_10_3_1:()=>vt,ts_10_3_2:()=>Lt,ts_10_3_3:()=>Ct,ts_10_4_1:()=>Ot,ts_10_4_2:()=>It,ts_10_4_3:()=>kt,ts_10_4_4:()=>Et,ts_10_4_5:()=>Bt,ts_11_1_1:()=>Dt,ts_11_1_1_1:()=>Ut,ts_11_2_1:()=>Nt,ts_11_2_1_1:()=>Mt,ts_11_2_2:()=>Yt,ts_11_2_2_1:()=>jt,ts_11_2_3:()=>Ht,ts_11_2_3_1:()=>Ft,ts_11_2_4:()=>Pt,ts_11_2_4_1:()=>Qt,ts_12_1_1:()=>Rt,ts_12_1_10:()=>Zt,ts_12_1_2:()=>Gt,ts_12_1_3:()=>Wt,ts_12_1_4:()=>Jt,ts_12_1_5:()=>Kt,ts_12_1_6:()=>zt,ts_12_1_7:()=>Vt,ts_12_1_8:()=>qt,ts_12_1_9:()=>Xt,ts_12_2_1:()=>$t,ts_12_2_2:()=>ea,ts_12_2_3:()=>ta,ts_13_1_1:()=>aa,ts_13_1_2:()=>oa,ts_1_3_1:()=>y,ts_1_3_2:()=>x,ts_1_3_3:()=>f,ts_1_3_4:()=>h,ts_1_3_5:()=>_,ts_1_3_6:()=>b,ts_2_1_1:()=>T,ts_2_1_2:()=>A,ts_2_1_3:()=>S,ts_2_1_4:()=>w,ts_2_1_4_1:()=>v,ts_2_1_5:()=>L,ts_2_2_1:()=>C,ts_2_2_2:()=>O,ts_2_2_3:()=>I,ts_2_2_4:()=>k,ts_2_2_4_1:()=>E,ts_2_2_5:()=>B,ts_2_2_6:()=>D,ts_2_3_1:()=>U,ts_2_3_2:()=>N,ts_2_3_3:()=>M,ts_2_4_1:()=>Y,ts_2_4_2:()=>j,ts_2_4_3:()=>H,ts_3_1_1:()=>F,ts_3_1_2:()=>P,ts_3_1_3:()=>Q,ts_3_1_4:()=>R,ts_3_1_5:()=>G,ts_3_1_5_1:()=>W,ts_3_1_6:()=>J,ts_3_1_7:()=>K,ts_3_2_1:()=>z,ts_3_2_2:()=>V,ts_3_2_3:()=>q,ts_3_2_4:()=>X,ts_3_2_5:()=>Z,ts_3_2_6:()=>$,ts_3_2_7:()=>ee,ts_4_1_1:()=>te,ts_4_1_2:()=>ae,ts_4_1_3:()=>oe,ts_4_1_4:()=>ie,ts_4_1_5:()=>re,ts_4_2_1:()=>se,ts_4_2_1_1:()=>ne,ts_4_2_2:()=>le,ts_4_2_2_1:()=>ce,ts_4_2_3:()=>de,ts_4_2_3_1:()=>pe,ts_4_2_4:()=>ue,ts_5_1_1:()=>me,ts_5_1_2:()=>ge,ts_5_1_2_1:()=>ye,ts_5_1_3:()=>xe,ts_5_1_4:()=>fe,ts_5_1_5:()=>he,ts_5_1_6:()=>_e,ts_5_1_7:()=>be,ts_5_2_1:()=>Te,ts_5_2_2:()=>Ae,ts_5_2_3:()=>Se,ts_5_2_3_1:()=>we,ts_5_2_4:()=>ve,ts_5_2_4_1:()=>Le,ts_6_1_1:()=>Ce,ts_6_1_2:()=>Oe,ts_6_1_3:()=>Ie,ts_6_1_4:()=>ke,ts_6_2_1:()=>Ee,ts_6_2_2:()=>Be,ts_6_2_3:()=>De,ts_6_2_4:()=>Ue,ts_6_2_5:()=>Ne,ts_6_2_6:()=>Me,ts_7_1_1:()=>Ye,ts_7_1_2:()=>je,ts_7_2_1:()=>He,ts_7_2_2:()=>Fe,ts_7_2_3:()=>Pe,ts_7_2_4:()=>Qe,ts_7_2_5:()=>Re,ts_8_1_1:()=>Ge,ts_8_1_2:()=>We,ts_8_1_3:()=>Je,ts_8_1_4:()=>Ke,ts_8_1_5:()=>ze,ts_8_1_5_1:()=>Ve,ts_8_1_6:()=>qe,ts_8_1_7:()=>Xe,ts_8_2_1:()=>Ze,ts_8_2_1_1:()=>$e,ts_8_2_2:()=>et,ts_8_2_2_1:()=>tt,ts_8_2_3:()=>at,ts_8_2_3_1:()=>ot,ts_8_2_4:()=>it,ts_8_2_4_1:()=>rt,ts_9_2_1:()=>st,ts_9_2_2:()=>nt,ts_9_2_3:()=>lt,ts_9_2_4:()=>ct,ts_9_3_1:()=>dt,ts_9_3_2:()=>pt,ts_9_3_3:()=>ut,ts_9_3_4:()=>mt,ts_9_3_4_1:()=>gt});var p=o(6895),l=o(9299);const u=[{category:"ts",chid:1,title:"Introduction to TypeScript",sections:[{secid:1,subtitle:"What is TypeScript?",paragraphs:[{paraid:1,text:"TypeScript is a free and open-source programming language developed and maintained by Microsoft. It is a superset of JavaScript, which means it builds upon the capabilities of JavaScript while adding static type-checking and other advanced features. TypeScript aims to enhance the development experience by addressing some of the shortcomings and challenges that can arise when working with JavaScript code, especially in larger and more complex projects."},{paraid:2,text:"Here are some key features and concepts that define TypeScript:"},{paraid:3,text:"<ol><li><strong>Static Typing</strong></li></ul>"},{paraid:1,text:"<ul>One of the most prominent features of TypeScript is its support for static typing. This means that you can explicitly define the types of variables, function parameters, and function return values. The TypeScript compiler checks these types at compile-time, helping to catch type-related errors before the code runs.</ul>"},{paraid:4,text:'<ol start="2"><li><strong>Type Annotations</strong></li></ol>'},{paraid:1,text:"<ul>TypeScript allows you to annotate variables, functions, and other constructs with type information. This enhances code clarity and provides self-documentation for your codebase.</ul>"},{paraid:5,text:'<ol start="3"><li><strong>Type Inference</strong></li></ol>'},{paraid:1,text:"<ul>Even if you don't explicitly annotate types, TypeScript's type inference system can often determine the types of variables and expressions based on how they are used. This reduces the need for excessive type annotations.</ul>"},{paraid:6,text:'<ol start="4"><li><strong>Interfaces and Type Aliases</strong></li></ol>'},{paraid:1,text:"<ul>TypeScript introduces the concept of interfaces and type aliases. Interfaces define the structure of objects, ensuring that they adhere to a specific shape. Type aliases allow you to create custom type names for complex types, making the code more readable.</ul>"},{paraid:7,text:'<ol start="5"><li><strong>Classes and Inheritance</strong></li></ol>'},{paraid:1,text:"<ul>TypeScript supports object-oriented programming concepts, including classes, inheritance, and encapsulation. This is especially useful when working with larger and more organized codebases.</ul>"},{paraid:8,text:'<ol start="6"><li><strong>Enums</strong></li></ol>'},{paraid:1,text:"<ul>Enums provide a way to define a set of named constants, making the code more readable and self-explanatory.</ul>"},{paraid:9,text:'<ol start="7"><li><strong>Generics</strong></li></ol>'},{paraid:1,text:"<ul>Generics allow you to write reusable and flexible code by creating functions and classes that can work with different types without sacrificing type safety.</ul>"},{paraid:10,text:'<ol start="8"><li><strong>Modules and Namespaces</strong></li></ol>'},{paraid:1,text:"<ul>TypeScript offers built-in support for modular programming by allowing you to define modules that encapsulate related code. This helps with code organization and separation of concerns.</ul>"},{paraid:11,text:'<ol start="9"><li><strong>Type Checking</strong></li></ol>'},{paraid:1,text:"<ul>The TypeScript compiler performs thorough type checks during compilation. It can catch common mistakes and type-related errors, leading to more robust and reliable code.</ul>"},{paraid:12,text:'<ol start="10"><li><strong>Transpilation</strong></li></ol>'},{paraid:1,text:"<ul>TypeScript code is transpiled (converted) into standard JavaScript code that can run in any browser or JavaScript runtime. This means that TypeScript can be used in modern web development projects without compatibility issues.</ul>"},{paraid:13,text:'<ol start="11"><li><strong>Tooling and IDE Support</strong></li></ol>'},{paraid:1,text:"<ul>TypeScript is supported by various integrated development environments (IDEs) and code editors, providing features like intelligent code completion, type hints, and error checking.</ul>"},{paraid:14,text:"TypeScript is widely used in various domains, including web development, server-side development, and front-end frameworks like Angular and React. It's especially valuable for larger projects where maintaining code quality and minimizing runtime errors are crucial."}]},{secid:2,subtitle:"Advantages of TypeScript over JavaScript",paragraphs:[{paraid:1,text:"TypeScript offers several advantages over traditional JavaScript, making it a popular choice for developers, especially in larger and more complex projects. Here are some key advantages of TypeScript:"},{paraid:2,text:"<ol><li><strong>Static Typing</strong></li></ol>"},{paraid:1,text:"<ul>TypeScript introduces static typing, allowing developers to explicitly declare types for variables, function parameters, and return values. This catches type-related errors at compile-time, reducing the likelihood of runtime errors caused by type mismatches.</ul>"},{paraid:3,text:'<ol start="2"><li><strong>Type Inference</strong></li></ol>'},{paraid:1,text:"<ul>While TypeScript encourages explicit type annotations, it also provides a type inference system that can deduce types based on usage. This strikes a balance between static typing and developer convenience.</ul>"},{paraid:4,text:'<ol start="3"><li><strong>Code Readability and Self-Documentation</strong></li></ol>'},{paraid:1,text:"<ul>Type annotations make code more self-documenting by indicating the expected data types for variables and functions. This improves code readability and helps other developers understand the codebase.</ul>"},{paraid:5,text:'<ol start="4"><li><strong>Early Error Detection</strong></li></ol>'},{paraid:1,text:"<ul>The TypeScript compiler performs thorough type checking, catching many common programming errors before the code is executed. This leads to more robust and reliable code.</ul>"},{paraid:6,text:'<ol start="5"><li><strong>Enhanced IDE Support</strong></li></ol>'},{paraid:1,text:"<ul>TypeScript is designed to work well with modern development tools and IDEs. Features like autocompletion, intelligent code navigation, and error highlighting are more effective due to the availability of type information.</ul>"},{paraid:7,text:'<ol start="6"><li><strong>Better Refactoring and Code Maintenance</strong></li></ol>'},{paraid:1,text:"<ul>With the help of types, refactoring becomes safer and more efficient. Changing variable names, function signatures, or types can be done with confidence, knowing that the compiler will catch any inconsistencies.</ul>"},{paraid:8,text:'<ol start="7"><li><strong>Improved Collaboration</strong></li></ol>'},{paraid:1,text:"<ul>TypeScript's type annotations and clear interfaces enhance collaboration among team members. It reduces misunderstandings about function signatures and data structures, leading to smoother teamwork.</ul>"},{paraid:9,text:'<ol start="8"><li><strong>Easier Documentation Generation</strong></li></ol>'},{paraid:1,text:"<ul>TypeScript's type annotations can be used to generate accurate and up-to-date documentation automatically. This simplifies the documentation process and keeps it in sync with the code.</ul>"},{paraid:10,text:'<ol start="9"><li><strong>Better Tooling for Large Codebases</strong></li></ol>'},{paraid:1,text:"<ul>In larger projects, keeping track of types and dependencies can become challenging. TypeScript's modules and namespaces help structure and organize code, making it more manageable.</ul>"},{paraid:11,text:'<ol start="10"><li><strong>Code Maintainability</strong></li></ol>'},{paraid:1,text:"<ul>Static typing, combined with features like interfaces and classes, promotes better code organization and modular development. This leads to cleaner, more maintainable codebases.</ul>"},{paraid:12,text:'<ol start="11"><li><strong>Enhanced OOP Features</strong></li></ol>'},{paraid:1,text:"<ul>TypeScript provides support for object-oriented programming features like classes, interfaces, and inheritance. This is particularly beneficial for projects that require complex data structures and abstractions.</ul>"},{paraid:13,text:'<ol start="12"><li><strong>Compatibility with JavaScript Ecosystem</strong></li></ol>'},{paraid:1,text:"<ul>TypeScript is a superset of JavaScript, meaning that existing JavaScript code can be gradually migrated to TypeScript. This compatibility allows developers to take advantage of TypeScript's features without completely rewriting their codebase.</ul>"},{paraid:14,text:'<ol start="13"><li><strong>TypeScript Declaration Files</strong></li></ol>'},{paraid:1,text:"<ul>TypeScript has a concept of declaration files (with `<code>.d.ts</code>` extensions) that describe the structure and types of existing JavaScript libraries. This enables type checking and auto-completion when using third-party libraries in TypeScript projects.</ul>"},{paraid:15,text:'<ol start="14"><li><strong>Community and Resources</strong></li></ol>'},{paraid:1,text:"<ul>TypeScript has a growing and active community, providing resources, tutorials, and support for developers. This community-driven effort contributes to the language's evolution and improvement.</ul>"},{paraid:16,text:"Overall, TypeScript's static typing and advanced features help developers write more maintainable, reliable, and efficient code, particularly in complex and team-based projects."}]},{secid:3,subtitle:"Setting Up TypeScript Development Environment",paragraphs:[{paraid:1,text:"Setting up a TypeScript development environment is relatively straightforward and involves a few key steps. Here's a guide to help you get started."},{paraid:2,text:"<ol><li><strong>Install Node.js</strong></li></ol>"},{paraid:3,text:'<ul>TypeScript requires Node.js, so if you don\'t have it already, download and install it from the official Node.js website: <a href="https://nodejs.org/" target="_blank">https://nodejs.org/</a></ul>'},{paraid:4,text:'<ol start="2"><li><strong>Install TypeScript</strong></li></ol>'},{paraid:5,text:"<ul>Once Node.js is installed, you can use npm (Node Package Manager) to install TypeScript globally on your system. Open a terminal or command prompt and run the following command:</ul>"},{paraid:6,text:"",codeConfig:{codeid:"ts_1_3_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"BASH",exampleTitle:"",codeLangs:"bash",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:7,text:"<ul>This installs the TypeScript compiler (`<code>tsc</code>`) globally, allowing you to compile TypeScript files anywhere on your system.</ul>"},{paraid:8,text:'<ol start="3"><li><strong>Create a Project Directory</strong></li></ol>'},{paraid:9,text:"<ul>Create a directory for your TypeScript project. Navigate to this directory using the terminal.</ul>"},{paraid:10,text:'<ol start="4"><li><strong>Initialize a `<code>package.json</code>` File</strong></li></ol>'},{paraid:11,text:"<ul>Run the following command in your project directory to initialize a `<code>package.json</code>` file, which manages your project's dependencies and settings:</ul>"},{paraid:12,text:"",codeConfig:{codeid:"ts_1_3_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"BASH",exampleTitle:"",codeLangs:"bash",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:13,text:'<ol start="5"><li><strong>Create a TypeScript File</strong></li></ol>'},{paraid:14,text:"<ul>Create a new TypeScript file in your project directory. You can use any text editor or integrated development environment (IDE) for this purpose. Save the file with a `<code>.ts</code>` extension (e.g., `<code>main.ts</code>`).</ul>"},{paraid:15,text:'<ol start="6"><li><strong>Write TypeScript Code</strong></li></ol>'},{paraid:16,text:"<ul>Write some TypeScript code in your `<code>.ts</code>` file. For example:</ul>"},{paraid:17,text:"",codeConfig:{codeid:"ts_1_3_3",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:18,text:'<ol start="7"><li><strong>Compile TypeScript</strong></li></ol>'},{paraid:19,text:"<ul>To compile TypeScript code into JavaScript, use the TypeScript compiler (`<code>tsc</code>`). In your terminal, navigate to your project directory and run the following command:</ul>"},{paraid:20,text:"",codeConfig:{codeid:"ts_1_3_4",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"BASH",exampleTitle:"",codeLangs:"bash",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:21,text:"<ul>This generates a corresponding `<code>main.js</code>` file that contains the compiled JavaScript code.</ul>"},{paraid:22,text:'<ol start="8"><li><strong>Run JavaScript Code</strong></li></ol>'},{paraid:23,text:"<ul>You can now run the compiled JavaScript code using Node.js. In the terminal, run:</ul>"},{paraid:24,text:"",codeConfig:{codeid:"ts_1_3_5",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"BASH",exampleTitle:"",codeLangs:"bash",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:25,text:"<ul>This will execute the JavaScript code and display the output.</ul>"},{paraid:26,text:'<ol start="9"><li><strong>Automating Compilation (Optional)</strong></li></ol>'},{paraid:27,text:"<ul>Manually running `<code>tsc</code>` every time you make changes can become tedious. You can set up automatic compilation using the `<code>--watch</code>` flag. Run the following command to enable automatic recompilation whenever your `<code>.ts</code>` file changes:</ul>"},{paraid:28,text:"",codeConfig:{codeid:"ts_1_3_6",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"BASH",exampleTitle:"",codeLangs:"bash",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:29,text:"<ul>Alternatively, you can use build tools like Webpack or Gulp to automate more complex workflows and bundle your TypeScript code along with other assets.</ul>"},{paraid:30,text:"With these steps, you have successfully set up a basic TypeScript development environment. As your projects become more complex, you might want to explore using TypeScript with various frameworks, integrating with IDEs that offer TypeScript support, and leveraging TypeScript's features to enhance your coding experience."}]}]},{category:"ts",chid:2,title:"Basic Types and Variables",sections:[{secid:1,subtitle:"Primitive Types",paragraphs:[{paraid:1,text:"Absolutely, understanding primitive types in TypeScript is essential. TypeScript supports the same primitive types as JavaScript while allowing you to explicitly annotate them for improved type safety. Here's an overview of the primitive types: `<code>number</code>`, `<code>string</code>`, `<code>boolean</code>`, and `<code>symbol</code>`."},{paraid:2,text:"<ol><li><strong>Number</strong></li></ol>"},{paraid:3,text:"<ul>The `<code>number</code>` type represents both integer and floating-point numbers. In TypeScript, you can explicitly declare a variable to be of type `<code>number</code>`:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_2_1_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:5,text:'<ol start="2"><li><strong>String</strong></li></ol>'},{paraid:6,text:"<ul>The `<code>string</code>` type represents textual data. You can use single or double quotes to declare strings:</ul>"},{paraid:7,text:"",codeConfig:{codeid:"ts_2_1_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:8,text:'<ol start="3"><li><strong>Boolean</strong></li></ol>'},{paraid:9,text:"<ul>The `<code>boolean</code>` type represents two possible values: `<code>true</code>` or `<code>false</code>`:</ul>"},{paraid:10,text:"",codeConfig:{codeid:"ts_2_1_3",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:11,text:'<ol start="4"><li><strong>Symbol</strong></li></ol>'},{paraid:12,text:"<ul>The `<code>symbol</code>` is a primitive data type in TypeScript (and JavaScript) that represents a unique and immutable value. It's often used as an identifier for object properties, ensuring that they won't collide with other property names:</ul>"},{paraid:13,text:"",codeConfig:{codeid:"ts_2_1_4",exampleid:"ts_2_1_4_1",codeOutput:!1,exampleOutput:!0,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:14,text:"<ul>TypeScript's static typing allows you to catch type-related errors early in the development process. For instance, if you try to assign a value of the wrong type, the TypeScript compiler will issue an error:</ul>"},{paraid:15,text:"",codeConfig:{codeid:"ts_2_1_5",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:16,text:"Type annotations also serve as documentation for your code, making it easier for both you and other developers to understand the expected types of variables."}]},{secid:2,subtitle:"Special Types",paragraphs:[{paraid:1,text:"TypeScript introduces several special types that go beyond the standard primitive types (such as number, string, and boolean). These special types provide additional flexibility, type safety, and functionality for different scenarios. Here's an overview of TypeScript's special types."},{paraid:2,text:"<ol><li><strong>Undefined</strong></li></ol>"},{paraid:3,text:"<ul>The `<code>undefined</code>` type represents the absence of a value. Typically used when a variable doesn't have a value assigned:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_2_2_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:5,text:'<ol start="2"><li><strong>Null</strong></li></ol>'},{paraid:6,text:"<ul>The `<code>null</code>` type indicates the absence of a value explicitly:</ul>"},{paraid:7,text:"",codeConfig:{codeid:"ts_2_2_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:8,text:'<ol start="3"><li><strong>Any</strong></li></ol>'},{paraid:9,text:"<ul>The `<code>any</code>` type represents a type that can hold any value, and type checking is disabled. Used when you need to work with values of unknown types or interact with JavaScript code:</ul>"},{paraid:10,text:"",codeConfig:{codeid:"ts_2_2_3",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:11,text:'<ol start="4"><li><strong>Unknown</strong></li></ol>'},{paraid:12,text:"<ul>The `<code>unknown</code>` type represents a type-safe counterpart to `<code>any</code>`, requiring type checks before performing operations. Used when you're unsure of a value's type but want to maintain stricter type handling than `<code>any</code>`:</ul>"},{paraid:13,text:"",codeConfig:{codeid:"ts_2_2_4",exampleid:"ts_2_2_4_1",codeOutput:!1,exampleOutput:!0,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:14,text:'<ol start="5"><li><strong>Never</strong></li></ol>'},{paraid:15,text:"<ul>The `<code>never</code>` type represents values that never occur or functions that never return. Used in functions that throw exceptions, have infinite loops, or exhaustive type checks:</ul>"},{paraid:16,text:"",codeConfig:{codeid:"ts_2_2_5",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:17,text:'<ol start="6"><li><strong>Unique Symbol</strong></li></ol>'},{paraid:18,text:"<ul>The `<code>unique symbol</code>` type represents a unique and immutable value used as an identifier for object properties. Used to create unique property keys that won't conflict with other keys:</ul>"},{paraid:19,text:"",codeConfig:{codeid:"ts_2_2_6",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:20,text:"These special types provide tools to handle specific scenarios where standard primitive types may not suffice. Understanding when and how to use these types can help you write more robust, type-safe, and maintainable TypeScript code."}]},{secid:3,subtitle:"Declaring Variables",paragraphs:[{paraid:1,text:"In TypeScript, you can declare variables using the `<code>let</code>` and `<code>const</code>` keywords, just like in JavaScript. However, TypeScript's type system allows you to add type annotations to variables to specify their expected types, making your code more readable and helping catch type-related errors during development. Here's an overview of how to declare variables using `<code>let</code>` and `<code>const</code>`:"},{paraid:2,text:"<ol><li><strong>Using `<code>let</code>` for Mutable Variables</strong></li></ol>"},{paraid:3,text:"<ul>The `<code>let</code>` keyword is used to declare mutable variables, which means their values can be reassigned after their initial assignment:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_2_3_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:5,text:"<ul>In this example, `<code>age</code>`, `<code>firstName</code>`, and `<code>isActive</code>` are declared with explicit type annotations.</ul>"},{paraid:6,text:'<ol start="2"><li><strong>Using `<code>const</code>` for Immutable Variables</strong></li></ol>'},{paraid:7,text:"<ul>The `<code>const</code>` keyword is used to declare variables that cannot be reassigned after their initial assignment. This is useful when you want to ensure that a variable's value remains constant throughout its scope:</ul>"},{paraid:8,text:"",codeConfig:{codeid:"ts_2_3_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:9,text:"<ul>Once a value is assigned to a `<code>const</code>` variable, you cannot assign a new value to it:</ul>"},{paraid:10,text:"",codeConfig:{codeid:"ts_2_3_3",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:11,text:"Using `<code>let</code>` and `<code>const</code>` with type annotations helps improve code readability and maintainability. Additionally, when you declare variables with type annotations, the TypeScript compiler can catch potential type errors early in the development process, which leads to more robust and reliable code."}]},{secid:4,subtitle:"Type Annotations and Type Inference",paragraphs:[{paraid:1,text:"Type annotations and type inference are fundamental concepts in TypeScript that help define the types of variables, function parameters, return values, and other elements in your code. They play a crucial role in ensuring type safety and catching errors during development."},{paraid:2,text:"<ol><li><strong>Type Annotations</strong></li></ol>"},{paraid:3,text:"<ul>A type annotation is a way to explicitly specify the type of a variable, parameter, or return value. This is done by appending a colon (`<code>:</code>`) followed by the desired type after the variable or function declaration. Here's an example of type annotations:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_2_4_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:5,text:"<ul>In this example, the variable `<code>age</code>` is annotated with the `<code>number</code>` type, and the function `<code>greet</code>` takes a parameter `<code>name</code>` of type `<code>string</code>` and returns a value of type `<code>string</code>`.</ul>"},{paraid:6,text:'<ol start="2"><li><strong>Type Inference</strong></li></ol>'},{paraid:7,text:"<ul>Type inference is TypeScript's ability to automatically determine the type of a variable based on its initial value. TypeScript examines the value assigned to a variable and infers its type from that value. Here's an example:</ul>"},{paraid:8,text:"",codeConfig:{codeid:"ts_2_4_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:9,text:"<ul>In this example, TypeScript infers the types of `<code>temperature</code>` and `<code>appName</code>` based on the values they are assigned.</ul>"},{paraid:10,text:"<ul>Type inference allows you to write more concise code while still benefiting from type safety. However, there are cases where adding explicit type annotations is beneficial:</ul>"},{paraid:11,text:"<ul><ul><li>When you want to provide additional documentation and clarity for other developers or yourself.</li><li>When the initial value of a variable doesn't provide enough information for TypeScript to infer the intended type accurately.</li><li>When you want to enforce a specific type on a variable even though TypeScript's inference might suggest a different type.</li></ul></ul>"},{paraid:12,text:"<ul>Combining Type Annotations and Inference:</ul>"},{paraid:13,text:"",codeConfig:{codeid:"ts_2_4_3",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:14,text:"<ul>In the above example, `<code>age</code>` is explicitly annotated as a `<code>number</code>`, while the type of `<code>name</code>` is inferred as `<code>string</code>` based on its initial value.</ul>"},{paraid:15,text:"Using type annotations and type inference effectively can strike a balance between providing clear type information and allowing TypeScript to automatically deduce types, leading to code that is both readable and type-safe."}]}]},{category:"ts",chid:3,title:"Arrays and Tuples",sections:[{secid:1,subtitle:"Working with Arrays",paragraphs:[{paraid:1,text:"Working with arrays in TypeScript is similar to working with arrays in JavaScript, but TypeScript's static typing adds an extra layer of type safety and clarity. You can declare the type of elements an array can hold, and TypeScript will help you catch type-related errors. Here's how to work with arrays in TypeScript:"},{paraid:1,text:"<ol><li><strong>Declaring Typed Arrays</strong></li></ol>"},{paraid:1,text:"<ul>You can declare arrays with specific element types using square brackets (`<code>[]</code>`) after the type annotation:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_3_1_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="2"><li><strong>Array Type Inference</strong></li></ol>'},{paraid:1,text:"<ul>TypeScript can often infer the type of the array from the initial values:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_3_1_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="3"><li><strong>Accessing Array Elements</strong></li></ol>'},{paraid:1,text:"<ul>You can access array elements using zero-based indices:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_3_1_3",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="4"><li><strong>Array Methods and Properties</strong></li></ol>'},{paraid:1,text:"<ul>Arrays in TypeScript come with various built-in methods and properties, just like in JavaScript. TypeScript's type system provides type information for these methods, making your code more reliable:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_3_1_4",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="5"><li><strong>Iterating Through Arrays</strong></li></ol>'},{paraid:1,text:"<ul>You can use standard iteration methods like `<code>for</code>` loops, `<code>forEach</code>`, and `<code>for...of</code>` loops:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_3_1_5",exampleid:"ts_3_1_5_1",codeOutput:!1,exampleOutput:!0,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="6"><li><strong>Array Type Union</strong></li></ol>'},{paraid:1,text:"<ul>Arrays can hold different types using union types:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_3_1_6",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="7"><li><strong>Read-Only Arrays with `<code>readonly</code>`</strong></li></ol>'},{paraid:1,text:"<ul>You can make arrays read-only by using the `<code>readonly</code>` modifier. This prevents adding, removing, or modifying elements after initialization:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_3_1_7",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"Using TypeScript's type annotations and inference with arrays improves code quality by catching type-related errors early and providing clear documentation for the intended types of array elements."}]},{secid:2,subtitle:"Understanding Tuples and Their Uses",paragraphs:[{paraid:1,text:"Tuples are a specialized type in TypeScript that allows you to define an array with a fixed number of elements, where each element may have a different type. Tuples provide a way to represent a collection of values that have a specific order and known types at each position. They are particularly useful when you want to ensure a strict structure for data and maintain type information for each element. Here's how tuples work and how you can use them."},{paraid:1,text:"<ol><li><strong>Defining Tuples</strong></li></ol>"},{paraid:1,text:"<ul>To define a tuple, you enclose the types of its elements within square brackets `<code>[]</code>`, separated by commas. For example:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_3_2_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In this example, `<code>person</code>` is a tuple that holds a string (name) at index 0 and a number (age) at index 1.</ul>"},{paraid:1,text:'<ol start="2"><li><strong>Accessing Tuple Elements</strong></li></ol>'},{paraid:1,text:"<ul>You can access tuple elements using zero-based indices, just like arrays:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_3_2_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="3"><li><strong>Tuple Type Inference</strong></li></ol>'},{paraid:1,text:"<ul>TypeScript can infer tuple types when you assign values to them:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_3_2_3",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="4"><li><strong>Using Tuples in Functions</strong></li></ol>'},{paraid:1,text:"<ul>Tuples are often used to represent multiple return values from a function. You can also define function parameters as tuples:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_3_2_4",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="5"><li><strong>Tuples with Optional Elements</strong></li></ol>'},{paraid:1,text:"<ul>Tuples can include optional elements using the `<code>?</code>` modifier. Optional elements can have `<code>undefined</code>` values:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_3_2_5",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="6"><li><strong>Tuples with Rest Elements</strong></li></ol>'},{paraid:1,text:"<ul>Tuples can include a rest element to capture all remaining elements as an array:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_3_2_6",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="7"><li><strong>Tuples in Arrays</strong></li></ol>'},{paraid:1,text:"<ul>You can also have arrays of tuples:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_3_2_7",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="8"><li><strong>Limitations and Considerations</strong></li></ol>'},{paraid:1,text:"<ul>While tuples provide structure and type information, they have limitations compared to objects or classes, such as lack of named properties and methods. Overusing tuples for complex data structures can lead to code that is harder to understand and maintain. In such cases, it might be better to use objects or classes.</ul>"},{paraid:1,text:"<ul>Tuples are most effective when representing data with a fixed and specific order, like coordinates or key-value pairs, where each position has a well-defined meaning.</ul>"},{paraid:1,text:"In summary, tuples offer a way to create structured arrays with defined types for each position. They are useful when you need to maintain type information for multiple elements in a specific order."}]}]},{category:"ts",chid:4,title:"Functions",sections:[{secid:1,subtitle:"Declaring Functions and Function Types",paragraphs:[{paraid:1,text:"Declaring functions and specifying function types are fundamental aspects of TypeScript, as they allow you to provide type information for function parameters and return values. This helps catch errors early and provides better documentation for your code. Here's how to declare functions and define function types in TypeScript:"},{paraid:1,text:"<ol><li><strong>Declaring Functions</strong></li></ol>"},{paraid:1,text:"<ul>To declare a function in TypeScript, you provide the function's name, a parameter list with their types, and a return type annotation:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_4_1_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In this example, the function `<code>add</code>` takes two parameters of type `<code>number</code>` and returns a value of type `<code>number</code>`.</ul>"},{paraid:1,text:'<ol start="2"><li><strong>Function Types</strong></li></ol>'},{paraid:1,text:"<ul>In TypeScript, functions are first-class citizens, meaning they can be assigned to variables, passed as arguments, and returned from other functions. You can define function types using the syntax `<code>(parameters) => returnType</code>`:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_4_1_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In this example, `<code>mathFunction</code>` is of type `<code>(number, number) => number</code>`, meaning it's a function that takes two `<code>number</code>` parameters and returns a `<code>number</code>`.</ul>"},{paraid:1,text:'<ol start="3"><li><strong>Function Overloads</strong></li></ol>'},{paraid:1,text:"<ul>In TypeScript, you can define multiple function signatures for a single function using function overloads. This is particularly useful when a function can accept different types of arguments and return different types:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_4_1_3",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="4"><li><strong>Function Callbacks</strong></li></ol>'},{paraid:1,text:"<ul>Functions that take other functions as arguments often use callback patterns. You can define function types for callbacks:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_4_1_4",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="5"><li><strong>Arrow Functions</strong></li></ol>'},{paraid:1,text:"<ul>Arrow functions provide a concise syntax for declaring functions. Arrow functions automatically capture the value of `<code>this</code>` from their containing scope:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_4_1_5",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"Understanding how to declare functions and define their types is crucial for writing type-safe and well-documented TypeScript code. It helps catch type-related errors early and improves code clarity."}]},{secid:2,subtitle:"Optional, Default, and Rest Parameters",paragraphs:[{paraid:1,text:"Optional, default, and rest parameters are powerful features in TypeScript that provide flexibility when working with functions. They allow you to define functions that can be called with fewer arguments or with some arguments using default values. Here's an explanation of optional, default, and parameters:"},{paraid:1,text:"<ol><li><strong>Optional Parameters</strong></li></ol>"},{paraid:1,text:"<ul>An optional parameter is a parameter that doesn't require a value to be provided when the function is called. To make a parameter optional, you add a `<code>?</code>` symbol after the parameter name in the function declaration. Optional parameters must come after required parameters:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_4_2_1",exampleid:"ts_4_2_1_1",codeOutput:!1,exampleOutput:!0,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="2"><li><strong>Default Parameters</strong></li></ol>'},{paraid:1,text:"<ul>Default parameters allow you to provide default values for function parameters. If a value is not passed for a parameter when calling the function, the default value is used instead. Default parameters are specified by assigning a value to the parameter in the function declaration:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_4_2_2",exampleid:"ts_4_2_2_1",codeOutput:!1,exampleOutput:!0,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="3"><li><strong>Combining Optional and Default Parameters</strong></li></ol>'},{paraid:1,text:"<ul>You can also combine optional and default parameters in a function declaration:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_4_2_3",exampleid:"ts_4_2_3_1",codeOutput:!1,exampleOutput:!0,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="4"><li><strong>Rest Parameters</strong></li></ol>'},{paraid:1,text:"<ul>Functions can accept a variable number of arguments as an array using rest parameters:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_4_2_4",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"Optional, default, and rest parameters provide flexibility in handling different scenarios when calling functions. They allow you to create functions that can accept varying numbers of arguments and provide sensible default behavior when specific arguments are omitted."}]}]},{category:"ts",chid:5,title:"Classes",sections:[{secid:1,subtitle:"Understanding Classes",paragraphs:[{paraid:1,text:"In TypeScript, classes are a fundamental concept that enables you to define blueprints for creating objects. They allow you to encapsulate data and behavior, facilitating a more organized and object-oriented approach to programming. TypeScript classes are an enhancement of JavaScript's prototype-based inheritance model. Here's an overview of TypeScript classes and their features:"},{paraid:1,text:"<ol><li><strong>Class Declaration</strong></li></ol>"},{paraid:1,text:"<ul>A class is defined using the `<code>class</code>` keyword, followed by the class name. It can have properties, methods, constructors, and more:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_5_1_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="2"><li><strong>Constructors</strong></li></ol>'},{paraid:1,text:"<ul>Constructors are special methods that are declared by the `<code>constructor</code>` keyword and executed when a class instance is created using the `<code>new</code>` keyword. They initialize the object's properties:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_5_1_2",exampleid:"ts_5_1_2_1",codeOutput:!1,exampleOutput:!0,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="3"><li><strong>Properties</strong></li></ol>'},{paraid:1,text:"<ul>Properties store data within class instances. They can have different access modifiers: `<code>public</code>`, `<code>protected</code>`, or `<code>private</code>`. They can be made read-only using the `<code>readonly</code>` modifier:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_5_1_3",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="4"><li><strong>Getter and Setter Properties</strong></li></ol>'},{paraid:1,text:"<ul>In TypeScript, getter and setter properties provide a way to control access and manipulation of class properties. Getters and setters are defined using the `<code>get</code>` and `<code>set</code>` keywords followed by the property name:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_5_1_4",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="5"><li><strong>Methods</strong></li></ol>'},{paraid:1,text:"<ul>Methods are functions defined within a class. They can access and manipulate properties and perform actions related to the class. They can have different access modifiers: `<code>public</code>`, `<code>protected</code>`, or `<code>private</code>`:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_5_1_5",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="6"><li><strong>Static Members</strong></li></ol>'},{paraid:1,text:"<ul>Static members (properties and methods) belong to the class itself, rather than to instances. They are accessed using the class name:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_5_1_6",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="7"><li><strong>Access Modifiers</strong></li></ol>'},{paraid:1,text:"<ul>Access modifiers control the visibility and accessibility of class members. There are three main access modifiers: `<code>public</code>` (default), `<code>protected</code>`, and `<code>private</code>`.</ul>"},{paraid:1,text:"<ul><ul><li>`<code>public</code>`: Members marked as `<code>public</code>` are accessible from anywhere, both within the class and from external code.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>`<code>protected</code>`: Members marked as `<code>protected</code>` are accessible within the class and its subclasses (derived classes), but not from external code.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>`<code>private</code>`: Members marked as `<code>private</code>` are accessible only within the class they are defined in, not from subclasses or external code.</li></ul></ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_5_1_7",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"Classes in TypeScript allow you to create structured and reusable code by encapsulating data and behavior. They provide a powerful foundation for building object-oriented applications, and understanding their features and concepts is essential for effective TypeScript development."}]},{secid:2,subtitle:"Abstract Classes and Inheritance",paragraphs:[{paraid:1,text:"Abstract classes and inheritance are important concepts in TypeScript's object-oriented programming paradigm. They allow you to create structured and reusable code by defining common behaviors and properties in a base class and then extending that base class to create more specialized subclasses. Let's explore abstract classes and inheritance in TypeScript in more detail:"},{paraid:1,text:"<ol><li><strong>Abstract Classes</strong></li><ol>"},{paraid:1,text:"<ul>You can define an abstract class using the `<code>abstract</code>` keyword. An abstract class is a class that cannot be instantiated directly but serves as a base for other classes. It can contain abstract methods (methods without implementation) that must be implemented by its subclasses. Abstract classes provide a way to define common behavior and structure for related classes:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_5_2_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="2"><li><strong>Inheritance</strong></li><ol>'},{paraid:1,text:"<ul>You can use `<code>extends</code>` keyword to derive a subclass from a superclass. Inheritance allows a subclass (derived class) to inherit properties and methods from a superclass (base class). This promotes code reuse and hierarchy organization. Subclasses can extend the behavior of the base class by adding new properties and methods or by overriding existing ones:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_5_2_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In the example above, `<code>Shape</code>` is an abstract class with an abstract method `<code>calculateArea()</code>`. Both `<code>Circle</code>` and `<code>Square</code>` classes extend `<code>Shape</code>` and provide implementations for `<code>calculateArea()</code>`.</ul>"},{paraid:1,text:'<ol start="3"><li><strong>Method Overriding</strong></li><ol>'},{paraid:1,text:"<ul>Method overriding allows a subclass to provide a new implementation for a method that is already defined in its superclass. This enables the subclass to customize the behavior of the inherited method while maintaining a common interface:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_5_2_3",exampleid:"ts_5_2_3_1",codeOutput:!1,exampleOutput:!0,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In this example, the `<code>Child</code>` class overrides the `<code>greet()</code>` method inherited from the `<code>Parent</code>` class. When you call `<code>greet()</code>` on a `<code>Child</code>` instance, it will execute the overridden implementation.</ul>"},{paraid:1,text:"<ul>Here's an example using abstract classes, inheritance, and method overriding:<ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_5_2_4",exampleid:"ts_5_2_4_1",codeOutput:!1,exampleOutput:!0,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:1,text:"By leveraging abstract classes, inheritance, and method overriding, you can create a structured and organized class hierarchy that promotes code reuse, specialization, and a clean separation of concerns."}]}]},{category:"ts",chid:6,title:"Interfaces and Type Aliases",sections:[{secid:1,subtitle:"Defining Interfaces and Their Importance",paragraphs:[{paraid:1,text:"Defining interfaces is a powerful feature in TypeScript that helps you define contracts for the shape and structure of objects. Interfaces allow you to specify the properties and methods an object should have, ensuring type safety and consistency throughout your codebase. Here's a detailed explanation of interfaces and their importance:"},{paraid:1,text:"<ol><li><strong>Defining Interfaces</strong></li></ol>"},{paraid:1,text:"<ul>An interface in TypeScript defines a blueprint for an object, specifying its properties, methods, and their types. You use the `<code>interface</code>` keyword to define an interface:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_6_1_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In this example, the `<code>Person</code>` interface defines the properties `<code>firstName</code>`, `<code>lastName</code>`, and `<code>age</code>`, as well as the method `<code>greet()</code>`.</ul>"},{paraid:1,text:'<ol start="2"><li><strong>Implementing Interfaces</strong></li></ol>'},{paraid:1,text:"<ul>To ensure that an object adheres to the structure defined by an interface, you can implement that interface in a class using the `<code>implements</code>` keyword. Implementing an interface requires the class to provide definitions for all properties and methods specified by the interface:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_6_1_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In this example, the `<code>Employee</code>` class implements the `<code>Person</code>` interface by providing definitions for all properties and the `<code>greet()</code>` method.</ul>"},{paraid:1,text:'<ol start="3"><li><strong>Optional Properties and Readonly Properties</strong></li></ol>'},{paraid:1,text:"<ul>Interfaces can have optional properties denoted by the `<code>?</code>` symbol. Optional properties are not required to be present in implementing objects:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_6_1_3",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>Interfaces can also have readonly properties that can only be set at the time of object creation:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_6_1_4",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"In summary, interfaces in TypeScript are essential tools for defining object contracts, ensuring type safety, and promoting well-organized and reusable code. They play a significant role in building maintainable and scalable applications."}]},{secid:2,subtitle:"Creating Type Aliases for Custom Types",paragraphs:[{paraid:1,text:"Type aliases in TypeScript allow you to create custom names for types, making your code more expressive and readable. They are especially useful for complex type definitions or when you want to reuse a type definition across multiple places in your code. Here's how to create type aliases:"},{paraid:1,text:"<ol><li><strong>Basic Type Aliases</strong></li></ol>"},{paraid:1,text:"<ul>You can create a type alias using the `<code>type</code>` keyword:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_6_2_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In this example, `<code>Age</code>` and `<code>Name</code>` are type aliases for `<code>number</code>` and `<code>string</code>` respectively.</ul>"},{paraid:1,text:'<ol start="2"><li><strong>Custom Object Type Aliases</strong></li></ol>'},{paraid:1,text:"<ul>You can use type aliases to define custom object types:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_6_2_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="3"><li><strong>Union and Intersection Type Aliases</strong></li></ol>'},{paraid:1,text:"<ul>Type aliases can be used with union and intersection types:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_6_2_3",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="4"><li><strong>Function Type Aliases</strong></li></ol>'},{paraid:1,text:"<ul>You can create type aliases for function signatures:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_6_2_4",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="5"><li><strong>Mapped Type Aliases</strong></li></ol>'},{paraid:1,text:"<ul>Mapped types transform existing types by applying a mapping function to each property. You can use mapped type aliases to create new types based on existing ones:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_6_2_5",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="6"><li><strong>Generics with Type Aliases</strong></li></ol>'},{paraid:1,text:"<ul>Type aliases can also include generics to create reusable type definitions:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_6_2_6",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"Type aliases are a powerful tool to create expressive and reusable type definitions in your TypeScript code. They help improve code readability, maintainability, and flexibility."}]}]},{category:"ts",chid:7,title:"Type Assertions",sections:[{secid:1,subtitle:"Using Type Assertions to Override Type Inference",paragraphs:[{paraid:1,text:"Type assertions in TypeScript, sometimes referred to as \"type casting\", allow you to explicitly tell the TypeScript compiler that you know better than it does regarding the type of a particular value. Type assertions are used when you have more knowledge about a value's type than TypeScript's type inference system."},{paraid:1,text:"It's important to note that type assertions do not perform runtime type checks or data conversion; they are purely a tool to help the TypeScript compiler understand your intentions."},{paraid:1,text:"Here's how you can use type assertions to override type inference:"},{paraid:1,text:"<ol><li><strong>Using Angle Bracket Syntax</strong></li></ol>"},{paraid:1,text:"<ul>You can use angle brackets to assert the type of a value:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_7_1_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In this example, `<code>value</code>` is asserted to be of type `<code>string</code>` so that the `<code>length</code>` property can be accessed.</ul>"},{paraid:1,text:'<ol start="2"><li><strong>Using `<code>as</code>` Syntax</strong></li></ol>'},{paraid:1,text:"<ul>You can also use the `<code>as</code>` keyword for type assertions:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_7_1_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>Both of these examples achieve the same result: they tell the TypeScript compiler that even though `<code>value</code>` is of type `<code>any</code>`, you are treating it as a `<code>string</code>` in this specific context.</ul>"},{paraid:1,text:'<ol start="3"><li><strong>Caution and Best Practices</strong></li></ol>'},{paraid:1,text:"<ul>While type assertions can be useful in certain situations, they also come with some risks:</ul>"},{paraid:1,text:"<ul><ol><li>Incorrect assertions can lead to runtime errors if your assumption about the type is wrong.</li></ol></ul>"},{paraid:1,text:"<ul><ol start=\"2\"><li>Type assertions bypass TypeScript's type checking, so it's crucial to ensure that the assertion is accurate.</li></ol></ul>"},{paraid:1,text:"<ul>Whenever possible, try to rely on TypeScript's type inference and use type assertions sparingly. If you find yourself using type assertions frequently, consider revisiting your code structure and ensuring that you're leveraging TypeScript's strong type system effectively.</ul>"},{paraid:1,text:"In summary, type assertions allow you to override TypeScript's type inference temporarily, but they should be used with caution to avoid introducing runtime errors."}]},{secid:2,subtitle:"Alternatives to Type Assertions",paragraphs:[{paraid:1,text:"The type assertions allow you to explicitly inform the TypeScript compiler about the expected type of a value. While they can be useful, there are alternatives to consider depending on the situation. Here are some alternatives to type assertions:"},{paraid:1,text:"<ol><li><strong>Type Cast Functions</strong></li></ol>"},{paraid:1,text:"<ul>Instead of type assertions, you can create type-casting functions that perform the necessary type conversion:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_7_2_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>This approach encapsulates the type assertion logic in a function, making it more reusable and easier to maintain.</ul>"},{paraid:1,text:'<ol start="2"><li><strong>Type Guards</strong></li></ol>'},{paraid:1,text:"<ul>Type guards are functions that check the type of a value and return a boolean. They can help TypeScript's type inference system narrow down the possible types of a value within a certain code block:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_7_2_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>Type guards provide type safety without needing explicit type assertions.</ul>"},{paraid:1,text:'<ol start="3"><li><strong>User-Defined Type Guards</strong></li></ol>'},{paraid:1,text:"<ul>You can create more specific type guards that provide detailed type information:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_7_2_3",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>User-defined type guards allow you to narrow down the types of elements in an array.</ul>"},{paraid:1,text:'<ol start="4"><li><strong>Intersection and Union Types</strong></li></ol>'},{paraid:1,text:"<ul>In some cases, using intersection and union types can help you avoid the need for type assertions:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_7_2_4",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:4,text:"",codeConfig:{codeid:"ts_7_2_5",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"These alternatives help make your code more type-safe and maintainable by leveraging TypeScript's built-in type checking mechanisms. While type assertions can be helpful in certain scenarios, it's advisable to explore these alternatives first to ensure that your code remains accurate and reliable."}]}]},{category:"ts",chid:8,title:"Enums",sections:[{secid:1,subtitle:"Working with Enums in TypeScript",paragraphs:[{paraid:1,text:"Enums in TypeScript provide a way to define a set of named constant values that can represent a specific set of options or states. Enums help make your code more readable, self-explanatory, and type-safe. Here's how to work with enums in TypeScript:"},{paraid:1,text:"<ol><li><strong>Defining Enums</strong></li></ol>"},{paraid:1,text:"<ul>You define an enum using the `<code>enum</code>` keyword:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_8_1_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In this example, `<code>Color</code>` is an enum with three members: `<code>Red</code>`, `<code>Green</code>`, and `<code>Blue</code>`. By default, enum members are assigned numeric values starting from 0 and incrementing by 1 for each subsequent member.</ul>"},{paraid:1,text:'<ol start="2"><li><strong>Using Enums</strong></li></ol>'},{paraid:1,text:"<ul>You can use enum members just like constants:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_8_1_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>Enums are often used to represent options or states in a more meaningful way:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_8_1_3",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="3"><li><strong>Numeric and String Enums</strong></li></ol>'},{paraid:1,text:"<ul>By default, enums are numeric enums, but you can also create string enums:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_8_1_4",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="4"><li><strong>Accessing Enum Values</strong></li></ol>'},{paraid:1,text:"<ul>You can access the value of an enum member using the dot notation:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_8_1_5",exampleid:"ts_8_1_5_1",codeOutput:!1,exampleOutput:!0,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="5"><li><strong>Enum Value Assignment</strong></li></ol>'},{paraid:1,text:"<ul>You can explicitly assign values to enum members:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_8_1_6",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="6"><li><strong>Enum Member Behavior</strong></li></ol>'},{paraid:1,text:"<ul>Enum members are constants and have a few behaviors:</ul>"},{paraid:1,text:"<ul><ul><li>You can access an enum member using its name or value.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>You can iterate over enum members using loops.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>You can use enums in switch statements.</li></ul></ul>"},{paraid:1,text:'<ol start="7"><li><strong>Reverse Mapping</strong></li></ol>'},{paraid:1,text:"<ul>Enum members have both the name and the value. TypeScript generates reverse mappings, allowing you to find the name of an enum member from its value:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_8_1_7",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"Enums are particularly useful when you have a set of predefined options or states that your code can take. They enhance code readability and make it less error-prone by preventing invalid values. However, it's important to note that excessive use of enums can lead to code that is harder to refactor and maintain."}]},{secid:2,subtitle:"Enumerating and Accessing Enum Values",paragraphs:[{paraid:1,text:"Enumerating and accessing enum values in TypeScript involves iterating through the members of an enum and accessing their corresponding values. TypeScript provides several ways to achieve this. Here's how you can enumerate and access enum values:"},{paraid:1,text:"<ol><li><strong>`<code>for...in</code>` Loop</strong></li></ol>"},{paraid:1,text:"<ul>You can use a `<code>for...in</code>` loop to iterate through enum members and access their values:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_8_2_1",exampleid:"ts_8_2_1_1",codeOutput:!1,exampleOutput:!0,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In this example, the loop iterates through the keys in the `<code>Color</code>` enum. Since enum members are assigned numeric values, using `<code>isNaN</code>` helps filter out non-numeric keys.</ul>"},{paraid:1,text:'<ol start="2"><li><strong>`<code>Object.keys</code>`</strong></li></ol>'},{paraid:1,text:"<ul>You can use `<code>Object.keys</code>` to get an array of keys from the enum and then access their values:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_8_2_2",exampleid:"ts_8_2_2_1",codeOutput:!1,exampleOutput:!0,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="3"><li><strong>Using `<code>for...of</code>` with `<code>Object.values</code>`</strong></li></ol>'},{paraid:1,text:"<ul>You can use a `<code>for...of</code>` loop along with `<code>Object.values</code>` to directly iterate through the enum values:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_8_2_3",exampleid:"ts_8_2_3_1",codeOutput:!1,exampleOutput:!0,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="4"><li><strong>Accessing Enum Values</strong></li></ol>'},{paraid:1,text:"<ul>To access enum values, you can use their names or use their values directly:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_8_2_4",exampleid:"ts_8_2_4_1",codeOutput:!1,exampleOutput:!0,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:1,text:"Keep in mind that while enumerating enum values can be useful in certain situations, it's important to consider whether using loops to iterate through enum members aligns with your code's intended logic. Enums are designed to provide a set of distinct values, and using loops to manipulate them might not always be the most straightforward approach."}]}]},{category:"ts",chid:9,title:"Generics",sections:[{secid:1,subtitle:"Introduction to Generics",paragraphs:[{paraid:1,text:"Generics in TypeScript provide a way to create components (functions, classes, interfaces, etc.) that work with multiple types while maintaining type safety. They allow you to write code that is more flexible and reusable by enabling you to parameterize types within these components. Generics help you create functions and classes that can adapt to various data types without sacrificing type checking."},{paraid:1,text:"<ol><li><strong>Why Use Generics</strong></li></ol>"},{paraid:1,text:"<ul>Consider scenarios where you want to write a function or a class that works with different data types. Without generics, you would need to write separate implementations for each type, leading to code duplication. Generics solve this problem by allowing you to write a single implementation that can handle multiple types while ensuring type safety.</ul>"},{paraid:1,text:'<ol start="2"><li><strong>Advantages of Generics</strong></li></ol>'},{paraid:1,text:"<ul><ul><li>Reusability: Generics enable you to create components that work with a wide range of data types, promoting code reuse.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Type Safety: TypeScript's type checking ensures that generic components maintain type consistency, preventing type-related errors.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Code Reduction: Generics reduce code duplication by allowing you to create a single implementation for multiple types.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Flexibility: Generics make your code more adaptable to different data types without compromising type safety.</li></ul></ul>"},{paraid:1,text:"Generics play a vital role in writing flexible, reusable, and type-safe code. As you delve deeper into TypeScript, understanding how to use generics effectively will empower you to create more efficient and maintainable software."}]},{secid:2,subtitle:"Creating Generic Functions and Classes",paragraphs:[{paraid:1,text:"Creating generic functions and classes in TypeScript involves using type parameters to make your code flexible and reusable. Let's explore how to define and use generic functions and classes:"},{paraid:1,text:"<ol><li><strong>Creating a Generic Function</strong></li></ol>"},{paraid:1,text:"<ul>To create a generic function, you use angle brackets (`<code><></code>`) to introduce one or more type parameters. These type parameters act as placeholders for actual types that will be provided when the function is called. Here's a simple example of a generic function:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_9_2_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In this example, `<code>T</code>` is the type parameter. When you call `<code>identity</code>`, TypeScript infers the actual type based on the argument you provide.</ul>"},{paraid:1,text:'<ol start="2"><li><strong>Creating a Generic Class</strong></li></ol>'},{paraid:1,text:"<ul>Similar to functions, you can create generic classes by using type parameters. Here's a basic example of a generic class:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_9_2_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In this example, `<code>T</code>` is the type parameter for the `<code>Box</code>` class. When you create instances of the class, you specify the actual type.</ul>"},{paraid:1,text:'<ol start="3"><li><strong>Using Multiple Type Parameters</strong></li></ol>'},{paraid:1,text:"<ul>You can use multiple type parameters in a generic function or class. For example, here's a generic function that combines two arrays:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_9_2_3",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="4"><li><strong>Explicitly Specifying Types</strong></li></ol>'},{paraid:1,text:"<ul>While TypeScript's type inference often works well with generics, you can also explicitly specify types when using generic functions or classes:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_9_2_4",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"Creating generic functions and classes allows you to write code that is adaptable to various data types, promoting reusability and type safety. By understanding how to define and use type parameters, you can effectively leverage generics to build versatile and efficient software components."}]},{secid:3,subtitle:"Constraints on Generic Types",paragraphs:[{paraid:1,text:"Constraints on generic types in TypeScript allow you to specify requirements that the type parameter must meet. This helps ensure that the generic type is compatible with certain operations or properties. Let's explore how to apply constraints on generic types:"},{paraid:1,text:"<ol><li><strong>Using Constraints</strong></li></ol>"},{paraid:1,text:"<ul>You apply constraints to a generic type parameter by using the `<code>extends</code>` keyword followed by the type or interface that you want to use as the constraint. Here's a basic example:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_9_3_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In this example, the generic type parameter `<code>T</code>` must satisfy the `<code>Lengthy</code>` constraint, meaning it must have a `<code>length</code>` property of type `<code>number</code>`.</ul>"},{paraid:1,text:'<ol start="2"><li><strong>Using Multiple Constraints</strong></li></ol>'},{paraid:1,text:"<ul>You can use multiple constraints by separating them with the `<code>&</code>` operator:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_9_3_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In this example, the generic type parameter `<code>T</code>` must satisfy both the `<code>Lengthy</code>` and `<code>Printable</code>` constraints.</ul>"},{paraid:1,text:'<ol start="3"><li><strong>Using Built-in Constraints</strong></li></ol>'},{paraid:1,text:"<ul>TypeScript provides some built-in constraints that you can use:</ul>"},{paraid:1,text:"<ul><ul><li>`<code>keyof T</code>`: Constrains a generic type to valid property names of a given type `<code>T</code>`.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>`<code>Partial<T></code>`: Constrains a generic type to a type where all properties are optional.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>`<code>Readonly<T></code>`: Constrains a generic type to a type where all properties are readonly.</li></ul></ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_9_3_3",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="4"><li><strong>Using Class Constraints</strong></li></ol>'},{paraid:1,text:"<ul>You can also constrain generic type parameters to be instances of a specific class:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_9_3_4",exampleid:"ts_9_3_4_1",codeOutput:!1,exampleOutput:!0,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:1,text:"Constraints on generic types in TypeScript allow you to create more specific and tailored code by enforcing requirements on the types that can be used with your generic functions or classes. Constraints enhance type safety and help you write more robust and maintainable code."}]}]},{category:"ts",chid:10,title:"Advanced Types",sections:[{secid:1,subtitle:"Union Types and Intersection Types",paragraphs:[{paraid:1,text:"Union types and intersection types are advanced type features in TypeScript that allow you to work with combinations of types to create more flexible and expressive type definitions."},{paraid:1,text:"<ol><li><strong>Union Types</strong></li></ol>"},{paraid:1,text:"<ul>A union type allows a value to have multiple possible types. You define a union type by separating the types with the `<code>|</code>` symbol. This is useful when a value can be of different types at different times:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_10_1_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>Union types are particularly useful when you have a variable that can store different types of data.</ul>"},{paraid:1,text:'<ol start="2"><li><strong>Intersection Types</strong></li></ol>'},{paraid:1,text:"<ul>An intersection type is used to combine multiple types into a single type that has all the properties and methods of each constituent type. You define an intersection type by separating the types with the `<code>&</code>` symbol. This is useful when you want to create a type that contains the combined features of multiple types:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_10_1_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In this example, `<code>EmployeePerson</code>` has all the properties of both `<code>Person</code>` and `<code>Employee</code>`.</ul>"},{paraid:1,text:'<ol start="3"><li><strong>Using Union and Intersection Together</strong></li></ol>'},{paraid:1,text:"<ul>You can use union and intersection types together to create complex types:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_10_1_3",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In this example, `<code>ConfigurableValue</code>` is a type that has both the properties of `<code>Value</code>` and `<code>Configurable</code>`.</ul>"},{paraid:1,text:'<ol start="4"><li><strong>Key Points</strong></li></ol>'},{paraid:1,text:"<ul><ul><li>Union types allow a value to have multiple possible types.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Intersection types combine multiple types into a single type with the properties and methods of each constituent type.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Use union and intersection types to create flexible and complex type definitions.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Carefully choose between union and intersection types based on the behavior you want to achieve.</li></ul></ul>"},{paraid:1,text:"Understanding and effectively using union and intersection types can help you create more versatile and precise type definitions in your TypeScript code."}]},{secid:2,subtitle:"Type Guards and Type Predicates",paragraphs:[{paraid:1,text:"Type guards and type predicates are powerful concepts in TypeScript that allow you to narrow down the type of a value within specific code blocks. They help you write more precise and type-safe code when dealing with complex type scenarios. Let's explore type guards and type predicates:"},{paraid:1,text:"<ol><li><strong>Type Guards</strong></li></ol>"},{paraid:1,text:"<ul>Type guards are functions that perform runtime checks on values to determine their type. Once the type guard is used, TypeScript narrows down the type of the value within the corresponding code block.</ul>"},{paraid:1,text:"<ul>Here's an example of a simple type guard using the `<code>typeof</code>` operator:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_10_2_1",exampleid:"ts_10_2_1_1",codeOutput:!1,exampleOutput:!0,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In this example, the `<code>isString</code>` function is a type guard that narrows down the type of `<code>data</code>` to `<code>string</code>` within the `<code>if</code>` block.</ul>"},{paraid:1,text:'<ol start="2"><li><strong>Type Predicates</strong></li></ol>'},{paraid:1,text:"<ul>Type predicates are a more advanced way to define type guards using custom assertions. They are expressed in the form of a function that returns a boolean value and specifies the type assertion:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_10_2_2",exampleid:"ts_10_2_2_1",codeOutput:!1,exampleOutput:!0,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In this example, the `<code>isNumber</code>` function is a type predicate that asserts the type of `<code>value</code>` to be `<code>number</code>`.</ul>"},{paraid:1,text:'<ol start="3"><li><strong>In Operator</strong></li></ol>'},{paraid:1,text:"<ul>You can also use the `<code>in</code>` operator to narrow down the type of a value based on its properties:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_10_2_3",exampleid:"ts_10_2_3_1",codeOutput:!1,exampleOutput:!0,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="4"><li><strong>Non-Null Assertion Operator</strong></li></ol>'},{paraid:1,text:"<ul>The non-null assertion operator (`<code>!</code>`) is a post-fix expression that essentially removes the `<code>null</code>` or `<code>undefined</code> type from the type of a variable. In other words, it asserts that the expression to which it is applied is non-null or non-undefined, even if the type of that variable suggests otherwise. However, this does not perform any runtime checks; it's only a compile-time feature.</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_10_2_4",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:1,text:"<ul>This is a powerful but risky feature. You should use it only when you're certain that the expression will not be `<code>null</code>` or `<code>undefined</code>`.</ul>"},{paraid:1,text:'<ol start="5"><li><strong>Key Points</strong></li></ol>'},{paraid:1,text:"<ul><ul><li>Type guards and type predicates help narrow down the type of a value within a code block.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Type guards can be simple checks using `<code>typeof</code>`, `<code>instanceof</code>`, or custom property checks.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Type predicates are more advanced type guards expressed as functions that return a boolean value and specify the type assertion.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Type guards and type predicates are useful for improving type safety and providing better code readability.</li></ul></ul>"},{paraid:1,text:"By using type guards and type predicates, you can write code that is more robust and accurately represents the types of values you're working with in TypeScript."}]},{secid:3,subtitle:"Conditional Types",paragraphs:[{paraid:1,text:"Conditional types are a powerful and advanced feature in TypeScript that allow you to define types based on conditionals. They enable you to create flexible and dynamic type mappings based on the types of input values. Conditional types are often used in scenarios where you want to infer types based on certain conditions."},{paraid:1,text:"Here's an overview of how conditional types work:"},{paraid:1,text:"<ol><li><strong>Basic Syntax</strong></li></ol>"},{paraid:1,text:"<ul>The general syntax of a conditional type is:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_10_3_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>Here, `<code>T</code>` is the type you're testing, `<code>U</code>` is the type you're comparing against, `<code>X</code>` is the resulting type if the condition is true, and `<code>Y</code>` is the resulting type if the condition is false.</ul>"},{paraid:1,text:'<ol start="2"><li><strong>Extract and Exclude</strong></li></ol>'},{paraid:1,text:"<ul>Two common use cases for conditional types are the `<code>Extract</code>` and `<code>Exclude</code>` utility types. These types allow you to filter types based on conditions:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_10_3_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ul>In this example, the `<code>Extract</code>` type maps each type in the union to `<code>never</code>` unless it\'s assignable to `<code>"a"</code>` or `<code>"c"</code>`. The `<code>Exclude</code>` type does the opposite, mapping each type to `<code>never</code>` if it\'s assignable to `<code>"a"</code>` or `<code>"c"</code>`.</ul>'},{paraid:1,text:'<ol start="3"><li><strong>Distributive Conditional Types</strong></li></ol>'},{paraid:1,text:"<ul>Conditional types can distribute over union types. When applied to a union type, a conditional type is applied to each constituent type, and the result is a new union type:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_10_3_3",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="4"><li><strong>Key Points</strong></li></ol>'},{paraid:1,text:"<ul><ul><li>Conditional types allow you to define types based on conditionals.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>They are used to create dynamic type mappings based on input types.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Conditional types can distribute over union types, resulting in new unions.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Conditional types are a powerful tool for creating type transformations and custom type behaviors based on specific conditions.</li></ul></ul>"},{paraid:1,text:"Conditional types are an advanced feature and are often used in more complex scenarios where you need to dynamically generate types based on certain type conditions. They allow for greater flexibility in your type definitions and can help create more generic and reusable code."}]},{secid:4,subtitle:"Mapped Types",paragraphs:[{paraid:1,text:"Mapped types in TypeScript are a powerful feature that allow you to transform and manipulate the properties of an existing type to create a new type. They provide a way to generate new types based on the properties of an existing type by applying transformations uniformly across those properties. Mapped types are particularly useful when you need to create variations of types without duplicating code. Let's explore how mapped types work:"},{paraid:1,text:"<ol><li><strong>Basic Mapped Type</strong></li></ol>"},{paraid:1,text:"<ul>The most common mapped type is the `<code>Partial<T></code>` type, which makes all properties of type `<code>T</code>` optional:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_10_4_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>Here, `<code>[P in keyof T]?: T[P]</code>` iterates through each property `<code>P</code>` of type `<code>T</code>`, making it optional in the new type.</ul>"},{paraid:1,text:'<ol start="2"><li><strong>Creating Mapped Types</strong></li></ol>'},{paraid:1,text:"<ul>You can create your own mapped types using a similar syntax:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_10_4_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In these examples, `<code>ReadonlyProperties<T></code>` creates a type with all properties of `<code>T</code>` made readonly, and `<code>NullableProperties<T></code>` creates a type with properties of `<code>T</code>` that can also be `<code>null</code>`.</ul>"},{paraid:1,text:'<ol start="3"><li><strong>Mapping with Conditions</strong></li></ol>'},{paraid:1,text:"<ul>Mapped types can use conditions to selectively modify properties:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_10_4_3",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>Here, `<code>-?</code>` removes the optional modifier from properties.</ul>"},{paraid:1,text:'<ol start="4"><li><strong>Using Mapped Types</strong></li></ol>'},{paraid:1,text:"<ul>Mapped types are often used to transform existing types, especially when dealing with data transformations or APIs:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_10_4_4",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In this example, various mapped types are applied to the `<code>User</code>` interface to create variations of the type.</ul>"},{paraid:1,text:'<ol start="5"><li><strong>Inference with Mapped Types</strong></li></ol>'},{paraid:1,text:"<ul>Mapped types also work with inference, allowing you to infer and transform properties:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_10_4_5",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In this example, the `<code>setDefaults</code>` function infers the properties from the input and returns a new object with required properties.</ul>"},{paraid:1,text:"Mapped types in TypeScript provide a powerful mechanism for transforming and manipulating types, enabling you to generate new types based on existing ones while promoting code reuse and maintaining type safety. They are particularly useful for scenarios involving data transformations, API responses, and property manipulations."}]}]},{category:"ts",chid:11,title:"Decorators",sections:[{secid:1,subtitle:"Understanding Decorators and Their Applications",paragraphs:[{paraid:1,text:"Decorators in TypeScript are a powerful feature that allow you to modify or extend the behavior of classes, methods, properties, or other declarations at design time. They provide a way to annotate and enhance your code without changing the original source code. Decorators are used primarily for metadata and aspect-oriented programming. They're often associated with frameworks like Angular."},{paraid:1,text:"<ol><li><strong>Using Decorators</strong></li></ol>"},{paraid:1,text:"<ul>Decorators are applied using the `<code>@</code>` symbol followed by the decorator function's name. Decorators are executed when the declaration they decorate is defined. Here's a simple example of a class decorator:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_11_1_1",exampleid:"ts_11_1_1_1",codeOutput:!1,exampleOutput:!0,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In this example, the `<code>myClassDecorator</code>` function is applied as a class decorator to the `<code>MyClass</code>` declaration.</ul>"},{paraid:1,text:'<ol start="2"><li><strong>Common Applications</strong></li></ol>'},{paraid:1,text:"<ul><ul><li><strong>Class Decorators</strong>: Used to modify or enhance class behavior. For example, they can be used in dependency injection or to add additional properties/methods to a class.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li><strong>Method Decorators</strong>: Applied to class methods. They can be used for logging, access control, or to modify the method's behavior.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li><strong>Property Decorators</strong>: Applied to class properties. They can be used to track changes or enforce data validation.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li><strong>Parameter Decorators</strong>: Applied to parameters of class constructor, methods, or accessors. Used for logging, validation, or to provide additional metadata.</li></ul></ul>"},{paraid:1,text:'<ol start="3"><li><strong>Using Decorators with Frameworks</strong></li></ol>'},{paraid:1,text:"<ul>Frameworks like Angular make extensive use of decorators to provide features such as dependency injection, component metadata, route configuration, and more.</ul>"},{paraid:1,text:'<ol start="4"><li><strong>Key Considerations</strong></li></ol>'},{paraid:1,text:'<ul><ul><li>Decorators are an experimental feature in TypeScript, so ensure you have the `<code>"experimentalDecorators"</code>` option enabled in your `<code>tsconfig.json</code>` file.</li></ul></ul>'},{paraid:1,text:"<ul><ul><li>Decorators are applied when the code is being defined, not when it's executed.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Decorators can be chained on the same declaration.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>The order of execution for multiple decorators is from bottom to top.</li></ul></ul>"},{paraid:1,text:"Decorators provide a powerful tool for creating reusable and customizable behaviors in your codebase, enhancing modularity and maintainability. However, they require a clear understanding of their behavior and should be used thoughtfully to avoid unnecessary complexity."}]},{secid:2,subtitle:"Implementing Custom Decorators",paragraphs:[{paraid:1,text:"Implementing custom decorators in TypeScript involves creating functions that modify the behavior of classes, methods, properties, or parameters. Custom decorators provide a way to extend the functionality of your codebase while keeping it organized and maintainable. Let's walk through the process of implementing custom decorators with some examples:"},{paraid:1,text:"<ol><li><strong>Class Decorator</strong></li></ol>"},{paraid:1,text:"<ul>A class decorator is applied to a class declaration. Here's a simple example of a class decorator that adds a prefix to the class name:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_11_2_1",exampleid:"ts_11_2_1_1",codeOutput:!1,exampleOutput:!0,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In this example, the `<code>prefix</code>` decorator adds a `<code>prefix</code>` property to the prototype of the `<code>Example</code>` class.</ul>"},{paraid:1,text:'<ol start="2"><li><strong>Method Decorator</strong></li></ol>'},{paraid:1,text:"<ul>A method decorator is applied to a method within a class. Here's an example of a method decorator that logs the arguments and result of a method:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_11_2_2",exampleid:"ts_11_2_2_1",codeOutput:!1,exampleOutput:!0,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In this example, the `<code>logMethod</code>` decorator modifies the behavior of the `<code>add</code>` method to log its arguments and return value.</ul>"},{paraid:1,text:'<ol start="3"><li><strong>Property Decorator</strong></li></ol>'},{paraid:1,text:"<ul>A property decorator is applied to a property within a class. Here's an example of a property decorator that logs the property value when it's accessed:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_11_2_3",exampleid:"ts_11_2_3_1",codeOutput:!1,exampleOutput:!0,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In this example, the `<code>logProperty</code>` decorator modifies the getter and setter of the `<code>name</code>` property to log its value changes.</ul>"},{paraid:1,text:'<ol start="4"><li><strong>Parameter Decorator</strong></li></ol>'},{paraid:1,text:"<ul>A method parameter decorators allow you to customize the behavior of method parameters in classes. Here's an example of a method parameter decorator:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_11_2_4",exampleid:"ts_11_2_4_1",codeOutput:!1,exampleOutput:!0,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In this example, the `<code>parameterLogger</code>` decorator applies to the `<code>message</code>` parameter of the `<code>greet</code>` method.</ul>"},{paraid:1,text:"Custom decorators can be tailored to meet specific requirements and scenarios in your application. They allow you to enhance or modify the behavior of your classes, methods, and properties in a reusable and organized way. Just remember to consider readability and maintainability when applying decorators, as they can introduce complexity if overused."}]}]},{category:"ts",chid:12,title:"Modules and Namespaces",sections:[{secid:1,subtitle:"Organizing Code with Modules",paragraphs:[{paraid:1,text:"Organizing code with modules in TypeScript allows you to create structured and modular codebases by encapsulating functionality into separate files, namespaces, or external libraries. Modules help improve code readability, maintainability, and reusability by dividing your code into logical units of functionality. Here's how you can organize your code using modules in TypeScript:"},{paraid:1,text:"<ol><li><strong>Named Exports</strong></li></ol>"},{paraid:1,text:"<ul>You can use the `<code>export</code> keyword to export elements individually with names:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_12_1_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="2"><li><strong>Default Exports</strong></li></ol>'},{paraid:1,text:'<ul>You can have one default export per module. The default export represents the "main" element of the module:</ul>'},{paraid:4,text:"",codeConfig:{codeid:"ts_12_1_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="3"><li><strong>Exporting Types</strong></li></ol>'},{paraid:1,text:"<ul>You can use the `<code>export type</code>` syntax to export a type declaration from a module, but not to include the implementation. The type is available for type checking but does not affect the runtime behavior:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_12_1_3",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="4"><li><strong>Re-Exporting</strong></li></ol>'},{paraid:1,text:"<ul>You can re-export elements from one module to another, creating a higher-level abstraction:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_12_1_4",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="5"><li><strong>Named Imports</strong></li></ol>'},{paraid:1,text:"<ul>You can import named exports using the `<code>import</code>` statement:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_12_1_5",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="6"><li><strong>Default Imports</strong></li></ol>'},{paraid:1,text:"<ul>For default exports, you don't need to use curly braces and can choose any name for the imported element:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_12_1_6",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="7"><li><strong>Alias Imports</strong></li></ol>'},{paraid:1,text:"<ul>You can use aliases to import elements with different names:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_12_1_7",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="8"><li><strong>Importing Types</strong></li></ol>'},{paraid:1,text:"<ul>You can use the `<code>import type</code>` syntax to import type declarations from another module. This allows you to use the imported type for type annotations, interfaces, function signatures, and more:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_12_1_8",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="9"><li><strong>Importing All Elements</strong></li></ol>'},{paraid:1,text:"<ul>You can import all named exports from a module using the `<code>*</code>` wildcard:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_12_1_9",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="10"><li><strong>Importing External Modules</strong></li></ol>'},{paraid:1,text:"<ul>When using external third-party libraries, you can import their exports like this after the libraries are installed:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_12_1_10",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="11"><li><strong>Key Benefits of Modules</strong></li></ol>'},{paraid:1,text:"<ul><ul><li><strong>Encapsulation</strong>: Modules allow you to encapsulate related functionality and separate concerns.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li><strong>Reusability</strong>: Modules promote code reuse by allowing you to import and use code across different parts of your application.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li><strong>Readability</strong>: Organized code is easier to understand and maintain.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li><strong>Dependency Management</strong>: Modules help manage dependencies between different parts of your application.</li></ul></ul>"},{paraid:1,text:"Effective use of modules is essential for building maintainable and scalable TypeScript applications. By organizing your code into well-structured modules, you can create more manageable and robust software."}]},{secid:2,subtitle:"Using Namespaces for Encapsulation",paragraphs:[{paraid:1,text:"Namespaces in TypeScript provide a way to organize and encapsulate code into logical containers to avoid naming conflicts and keep related functionality together. Namespaces help improve code organization, maintainability, and readability by grouping related code into separate namespaces. Here's how you can use namespaces for encapsulation:"},{paraid:1,text:"<ol><li><strong>Defining a Namespace</strong></li></ol>"},{paraid:1,text:"<ul>To define a namespace, use the `<code>namespace</code>` keyword followed by the namespace's name:</ul>"},{paraid:1,text:"<ul>`<code>shapes.ts</code>`</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_12_2_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>In this example, a namespace named `<code>Shapes</code>` contains the `<code>Circle</code>` and <code>Rectangle</code>` classes.</ul>"},{paraid:1,text:'<ol start="2"><li><strong>Using Namespaced Members</strong></li></ol>'},{paraid:1,text:"<ul>To access members within a namespace, use dot notation:</ul>"},{paraid:1,text:"<ul>`<code>main.ts</code>`</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_12_2_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ul>You can use triple-slash directive `<code>/// &lt;reference path="shapes.ts" /&gt;</code>` to reference the namespace\'s definition file.</ul>'},{paraid:1,text:'<ol start="3"><li><strong>Nested Namespaces</strong></li></ol>'},{paraid:1,text:"<ul>You can create nested namespaces to further organize your code:</ul>"},{paraid:1,text:"<ul>`<code>geometry.ts</code>`</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_12_2_3",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"TS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="4"><li><strong>Using Global Objects with Namespaces</strong></li></ol>'},{paraid:1,text:"<ul>When compiling TypeScript code with namespaces, TypeScript generates a global object for each namespace. However, using global objects might not be the recommended way of organizing code in modern TypeScript projects. Instead, consider using ES6 modules (import/export) for better modularity.</ul>"},{paraid:1,text:'<ol start="5"><li><strong>Limitations and Considerations</strong></li></ol>'},{paraid:1,text:"<ul><ul><li>Namespaces should not be overused; they are more suitable for legacy codebases or scenarios where ES6 modules are not feasible.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Namespaces do not work well with bundling tools like Webpack or Rollup. ES6 modules are more compatible with these tools.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Prefer ES6 modules for new projects, as they offer better support for tree-shaking, module resolution, and tooling.</li></ul></ul>"},{paraid:1,text:"In conclusion, while namespaces can be useful for encapsulating code and avoiding naming conflicts, modern TypeScript projects often benefit from using ES6 modules for better compatibility, maintainability, and modularity."}]}]},{category:"ts",chid:13,title:"Debugging and Tooling",sections:[{secid:1,subtitle:"Debugging TypeScript Code",paragraphs:[{paraid:1,text:"Debugging TypeScript code is an important skill to ensure your applications work as expected. TypeScript offers a range of debugging techniques that you can use in conjunction with popular development tools and browsers to identify and fix issues in your code. Here's how to debug TypeScript code effectively:"},{paraid:1,text:"<ol><li><strong>Using Browser DevTools</strong></li></ol>"},{paraid:1,text:"<ul>Modern web browsers provide powerful developer tools that allow you to debug both TypeScript and JavaScript code running in the browser:</ul>"},{paraid:1,text:'<ul><ul><li><strong>Setting Breakpoints</strong>: Place breakpoints in your TypeScript code by clicking the line numbers in the source files within the "Sources" tab of the browser\'s DevTools. Execution will pause at these breakpoints, allowing you to inspect variables and the call stack.</li></ul></ul>'},{paraid:1,text:'<ul><ul><li><strong>Stepping Through Code</strong>: Use the "Step Over", "Step Into", and "Step Out" buttons to navigate through your code line by line.</li></ul></ul>'},{paraid:1,text:"<ul><ul><li><strong>Variable Inspection</strong>: While paused, you can inspect variables' current values, add watch expressions, and evaluate expressions in the console.</li></ul></ul>"},{paraid:1,text:'<ol start="2"><li><strong>Using Node.js Debugger</strong></li></ol>'},{paraid:1,text:"<ul>If you're running TypeScript code in a Node.js environment, you can debug using the Node.js debugger along with the `<code>--inspect</code>` flag:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_13_1_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"BASH",exampleTitle:"",codeLangs:"bash",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ul>This starts a debugging session that you can connect to using the "Attach to Node.js" option in your IDE.</ul>'},{paraid:1,text:'<ol start="3"><li><strong>Debugging in IDEs</strong></li></ol>'},{paraid:1,text:"<ul>Integrated development environments (IDEs) like Visual Studio Code (VS Code) offer excellent support for TypeScript debugging:</ul>"},{paraid:1,text:"<ul><ul><li><strong>Setting Breakpoints</strong>: Click the line numbers in your TypeScript files to set breakpoints.</li></ul></ul>"},{paraid:1,text:'<ul><ul><li><strong>Debug Configuration</strong>: In VS Code, create a `<code>launch.json</code>` file in the `<code>.vscode</code> directory to configure your debugging setup. Select "Node.js" for Node.js applications or "Chrome" for browser-based applications.</li></ul></ul>'},{paraid:1,text:'<ul><ul><li><strong>Debugging Panel</strong>: In VS Code, use the "Run and Debug" panel to launch your debugging configuration. You can start debugging sessions for different environments, such as Node.js or browser.</li></ul></ul>'},{paraid:1,text:'<ol start="4"><li><strong>Console Logging</strong></li></ol>'},{paraid:1,text:"<ul>While debugging with breakpoints is essential, console logging can also be a powerful tool for identifying issues in your TypeScript code. Use `<code>console.log()</code>` to output values, states, and debugging information at various points in your code.</ul>"},{paraid:1,text:'<ol start="5"><li><strong>Source Maps</strong></li></ol>'},{paraid:1,text:"<ul>Source maps generated by TypeScript allow you to debug your TypeScript code directly in the browser, even if it was compiled to JavaScript. Ensure you have source maps enabled in your TypeScript configuration:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"ts_13_1_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"JSON",exampleTitle:"",codeLangs:"json",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="6"><li><strong>Debugging Third-Party Code</strong></li></ol>'},{paraid:1,text:"<ul>If you're encountering issues in third-party libraries, ensure that you're using type definitions and that you're looking at the TypeScript code if available.</ul>"},{paraid:1,text:"Remember that effective debugging involves a combination of techniques, including breakpoints, logging, and reading error messages. As you gain experience, you'll become more efficient at identifying and resolving issues in your TypeScript code."}]},{secid:2,subtitle:"Overview of Popular TypeScript Tools and IDEs",paragraphs:[{paraid:1,text:"TypeScript has a thriving ecosystem of tools and integrated development environments (IDEs) that enhance your development experience. These tools provide features such as code editing, debugging, linting, formatting, and more. Here's an overview of some popular TypeScript tools and IDEs."},{paraid:1,text:"<ol><li><strong>Visual Studio Code (VS Code)</strong></li></ol>"},{paraid:1,text:"<ul>VS Code is a widely used, free, and open-source code editor developed by Microsoft. It offers robust TypeScript support out of the box and provides features like intelligent code completion, debugging, Git integration, extensions, and a vibrant marketplace with TypeScript-related extensions.</ul>"},{paraid:1,text:'<ol start="2"><li><strong>WebStorm</strong></li></ol>'},{paraid:1,text:"<ul>WebStorm is a commercial IDE developed by JetBrains. It's known for its powerful JavaScript and TypeScript support, including code completion, refactoring, and integrated debugging.</ul>"},{paraid:1,text:'<ol start="3"><li><strong>Sublime Text</strong></li></ol>'},{paraid:1,text:"<ul>Sublime Text is a versatile code editor with a dedicated TypeScript package available for enhanced TypeScript support. Although it's not as feature-rich as IDEs, it's highly customizable and popular among developers.</ul>"},{paraid:1,text:'<ol start="4"><li><strong>TypeScript Playground</strong></li></ol>'},{paraid:1,text:"<ul>The TypeScript Playground is an online tool provided by the TypeScript team. It allows you to experiment with TypeScript code in a browser environment and see the compiled JavaScript output and type information instantly.</ul>"},{paraid:1,text:'<ol start="5"><li><strong>TypeScript Language Service</strong></li></ol>'},{paraid:1,text:"<ul>The TypeScript Language Service is a core part of the TypeScript compiler that provides rich IntelliSense, code navigation, and refactoring capabilities. IDEs and text editors use this service to provide features like autocompletion and type checking.</ul>"},{paraid:1,text:'<ol start="6"><li><strong>ts-node</strong></li></ol>'},{paraid:1,text:"<ul>ts-node is a tool that allows you to run TypeScript code directly in Node.js without compiling it first. It's useful for scripting and testing TypeScript code without the extra step of compilation.</ul>"},{paraid:1,text:'<ol start="7"><li><strong>TSLint and ESLint</strong></li></ol>'},{paraid:1,text:"<ul>TSLint and ESLint are popular linting tools for TypeScript and JavaScript, respectively. They help you maintain code quality by enforcing coding standards and detecting potential issues.</ul>"},{paraid:1,text:'<ol start="8"><li><strong>Jest and Testing Libraries</strong></li></ol>'},{paraid:1,text:"<ul>For testing TypeScript applications, tools like Jest (with TypeScript support) and testing libraries like React Testing Library or Vue Test Utils provide testing capabilities and support for TypeScript typings.</ul>"},{paraid:1,text:'<ol start="9"><li><strong>Parcel and Webpack</strong></li></ol>'},{paraid:1,text:"<ul>Parcel and Webpack are popular bundlers that can be used to build and bundle TypeScript projects. They handle bundling, module resolution, and other build-related tasks.</ul>"},{paraid:1,text:"Remember that the choice of tools and IDEs depends on your preferences, project requirements, and existing workflows. Experiment with different tools to find the combination that best suits your TypeScript development needs."}]}]},{category:"ts",chid:14,title:"Best Practices and Tips",sections:[{secid:1,subtitle:"TypeScript Coding Standards",paragraphs:[{paraid:1,text:"TypeScript coding standards are a set of guidelines and best practices that help maintain consistency, readability, and maintainability in your TypeScript codebase. Following these standards makes your code more understandable for you and your team, and it reduces the likelihood of introducing bugs or errors. While coding standards can vary based on your team's preferences and the nature of your project, here are some common TypeScript coding standards to consider:"},{paraid:1,text:"<ol><li><strong>Naming Conventions</strong></li></ol>"},{paraid:1,text:"<ul><ul><li>Use camelCase for variables, function names, parameters, and properties (e.g., `<code>myVariable</code>`, `<code>calculateTotal</code>`).</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Use PascalCase for class and interface names (e.g., `<code>MyClass</code>`, `<code>PersonInfo</code>`).</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Use UPPERCASE_SNAKE_CASE for constants (e.g., `<code>MAX_VALUE</code>`, `<code>API_KEY</code>`).</li></ul></ul>"},{paraid:1,text:'<ol start="2"><li><strong>Type Annotations</strong></li></ol>'},{paraid:1,text:"<ul><ul><li>Annotate types explicitly when defining variables, parameters, and function return types.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Use built-in TypeScript types (`<code>string</code>`, `<code>number</code>`, `<code>boolean</code>`, etc.) instead of their JavaScript equivalents.</li></ul></ul>"},{paraid:1,text:'<ol start="3"><li><strong>Code Formatting</strong></li></ol>'},{paraid:1,text:"<ul><ul><li>Use consistent indentation (e.g., 2 or 4 spaces) for better readability.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Ensure consistent placement of curly braces and use the same brace style throughout your codebase.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Use semicolons at the end of statements for clarity and consistency.</li></ul></ul>"},{paraid:1,text:'<ol start="4"><li><strong>Interface and Type Declarations</strong></li></ol>'},{paraid:1,text:"<ul><ul><li>Use interfaces when defining object shapes and contracts.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Use type aliases when working with unions, intersections, and more complex types.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Avoid mixing interfaces and classes with similar names to prevent confusion.</li></ul></ul>"},{paraid:1,text:'<ol start="5"><li><strong>Function Declarations</strong></li></ol>'},{paraid:1,text:"<ul><ul><li>Use arrow functions `<code>(() =></code>`) for concise function expressions.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Prefer function declarations over anonymous functions when possible.</li></ul></ul>"},{paraid:1,text:'<ol start="6"><li><strong>Imports and Exports</strong></li></ol>'},{paraid:1,text:"<ul><ul><li>Use explicit default exports (`<code>export default ...</code>`) and named exports (`<code>export { ... }</code>`) for better clarity.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Organize imports by grouping external libraries, internal modules, and local files.</li></ul></ul>"},{paraid:1,text:'<ol start="7"><li><strong>Avoid Any</strong></li></ol>'},{paraid:1,text:"<ul><ul><li>Minimize the use of the `<code>any</code>` type, which removes TypeScript's type checking benefits.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Use better type annotations or type unions instead of `<code>any</code>.</li></ul></ul>"},{paraid:1,text:'<ol start="8"><li><strong>Avoid Implicit Any</strong></li></ol>'},{paraid:1,text:"<ul><ul><li>Enable the `<code>noImplicitAny</code>` compiler option to catch instances where TypeScript cannot infer types.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Explicitly annotate types for parameters and variables to avoid implicit `<code>any</code>`.</li></ul></ul>"},{paraid:1,text:'<ol start="9"><li><strong>Null and Undefined</strong></li></ol>'},{paraid:1,text:"<ul><ul><li>Use strict null checks (`<code>strictNullChecks: true</code>` in `<code>tsconfig.json</code>`) to prevent null and undefined errors.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Use union types (`<code>string | null</code>`, `<code>number | undefined</code>`) to represent nullable values.</li></ul></ul>"},{paraid:1,text:'<ol start="10"><li><strong>Enums</strong></li></ol>'},{paraid:1,text:"<ul><ul><li>Use enums for a set of related constants with semantic meaning.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Prefer string enums for better type safety and maintainability.</li></ul></ul>"},{paraid:1,text:'<ol start="11"><li><strong>Comments and Documentation</strong></li></ol>'},{paraid:1,text:"<ul><ul><li>Use comments to explain complex logic, assumptions, and non-trivial code blocks.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Provide JSDoc-style comments for functions, classes, and interfaces to document their usage.</li></ul></ul>"},{paraid:1,text:'<ol start="12"><li><strong>Error Handling</strong></li></ol>'},{paraid:1,text:"<ul><ul><li>Use `<code>try/catch</code>` blocks for synchronous error handling.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Use `<code>Promise.catch()</code>` for handling asynchronous errors.</li></ul></ul>"},{paraid:1,text:'<ol start="13"><li><strong>Testing and Debugging</strong></li></ol>'},{paraid:1,text:"<ul><ul><li>Write unit tests for your code to catch bugs early.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Use debugging tools and breakpoints to troubleshoot issues.</li></ul></ul>"},{paraid:1,text:'<ol start="14"><li><strong>Code Reviews</strong></li></ol>'},{paraid:1,text:"<ul><ul><li>Regularly conduct code reviews to ensure coding standards are being followed.</li></ul></ul>"},{paraid:1,text:"<ul><ul><li>Use linters and static analysis tools to enforce coding standards automatically.</li></ul></ul>"},{paraid:1,text:"Adapting and adhering to TypeScript coding standards can greatly enhance the quality and maintainability of your codebase. While these guidelines provide a foundation, it's important to tailor them to your team's preferences and project requirements. Consistency and collaboration are key factors in successfully implementing and maintaining coding standards."}]},{secid:2,subtitle:"Common Pitfalls to Avoid",paragraphs:[{paraid:1,text:"When working with TypeScript, there are several common pitfalls and mistakes that developers should be aware of to write clean, maintainable, and error-free code. Here are some common pitfalls to avoid:"},{paraid:1,text:"<ol><li><strong>Not Using Strict Mode</strong></li></ol>"},{paraid:1,text:'<ul>Not enabling TypeScript\'s strict mode (`<code>"strict": true</code>` in `<code>tsconfig.json</code>`) can lead to type-related errors and loss of type checking benefits.</ul>'},{paraid:1,text:'<ol start="2"><li><strong>Neglecting Type Annotations</strong></li></ol>'},{paraid:1,text:"<ul>Failing to provide accurate type annotations for variables, function parameters, and return types can lead to type-related bugs.</ul>"},{paraid:1,text:'<ol start="3"><li><strong>Overusing `<code>any</code>`</strong></li></ol>'},{paraid:1,text:"<ul>Relying too heavily on the `<code>any</code>` type undermines TypeScript's type safety benefits. Avoid using `<code>any</code>` unless absolutely necessary.</ul>"},{paraid:1,text:'<ol start="4"><li><strong>Ignoring Null and Undefined</strong></li></ol>'},{paraid:1,text:"<ul>Not considering `<code>null</code>` and `<code>undefined</code>` values when dealing with variables and function return values can lead to runtime errors.</ul>"},{paraid:1,text:'<ol start="5"><li><strong>Not Handling Promises Correctly</strong></li></ol>'},{paraid:1,text:"<ul>Forgetting to handle Promise rejections or using `<code>.then()</code>` without error handling can result in unhandled Promise exceptions.</ul>"},{paraid:1,text:'<ol start="6"><li><strong>Not Using Non-Null Assertions Wisely</strong></li></ol>'},{paraid:1,text:"<ul>Overusing the non-null assertion (`<code>!</code>`) can lead to runtime errors if the value is actually null or undefined.</ul>"},{paraid:1,text:'<ol start="7"><li><strong>Not Updating Type Definitions</strong></li></ol>'},{paraid:1,text:"<ul>Neglecting to update type definitions when third-party libraries are updated can lead to type conflicts and errors.</ul>"},{paraid:1,text:'<ol start="8"><li><strong>Using Object as a Type</strong></li></ol>'},{paraid:1,text:"<ul>Avoid using the `<code>Object</code>` type to represent object structures. Use more specific types, interfaces, or classes instead.</ul>"},{paraid:1,text:'<ol start="9"><li><strong>Failing to Consider Enums</strong></li></ol>'},{paraid:1,text:"<ul>Enums can lead to type safety issues if not used carefully. Consider using string enums when possible to avoid these issues.</ul>"},{paraid:1,text:'<ol start="10"><li><strong>Ignoring Strict Mode Checks</strong></li></ol>'},{paraid:1,text:"<ul>Ignoring strict mode errors and warnings can lead to uncaught issues. Address and fix these issues to maintain code quality.</ul>"},{paraid:1,text:'<ol start="11"><li><strong>Using `<code>undefined</code>` as a Value</strong></li></ol>'},{paraid:1,text:"<ul>Explicitly using `<code>undefined</code>` as a value can lead to confusion and potential errors. Prefer `<code>null</code>` for indicating the absence of a value.</ul>"},{paraid:1,text:'<ol start="12"><li><strong>Neglecting Type Inference</strong></li></ol>'},{paraid:1,text:"<ul>TypeScript's type inference can be powerful. Neglecting it and providing overly explicit type annotations can lead to redundant code.</ul>"},{paraid:1,text:'<ol start="13"><li><strong>Not Handling Unions and Intersection Types</strong></li></ol>'},{paraid:1,text:"<ul>Unions and intersection types have specific behavior that needs to be considered, especially when dealing with null and undefined values.</ul>"},{paraid:1,text:'<ol start="14"><li><strong>Incorrectly Using `<code>this</code>` Context</strong></li></ol>'},{paraid:1,text:"<ul>In classes, incorrectly using the `<code>this</code>` context can lead to runtime errors or unexpected behavior. Be mindful of how you manage the context.</ul>"},{paraid:1,text:'<ol start="15"><li><strong>Not Using Code Analysis Tools</strong></li></ol>'},{paraid:1,text:"<ul>Not using tools like linters, static analyzers, and type checking during development can lead to unnoticed issues in your code.</ul>"},{paraid:1,text:'<ol start="16"><li><strong>Overengineering with Generics</strong></li></ol>'},{paraid:1,text:"<ul>While generics are powerful, overusing them can lead to complex and hard-to-understand code. Use them when needed but keep it simple.</ul>"},{paraid:1,text:'<ol start="17"><li><strong>Failing to Test Types</strong></li></ol>'},{paraid:1,text:"<ul>Don't assume your types are correct without testing them. Write tests that validate type behavior, especially for complex types.</ul>"},{paraid:1,text:'<ol start="18"><li><strong>Overlooking Error Handling</strong></li></ol>'},{paraid:1,text:"<ul>Not properly handling errors, especially in asynchronous code, can result in unhandled exceptions and unexpected application behavior.</ul>"},{paraid:1,text:"By being aware of these common pitfalls and incorporating best practices into your TypeScript development process, you can write more robust and maintainable code and avoid unnecessary issues and bugs."}]}]}];var i=o(4650),m=o(4214);let g=(()=>{class e{constructor(a){this.coreService=a}ngOnInit(){this.coreService.sentBookData(u)}ngOnDestroy(){}}return e.\u0275fac=function(a){return new(a||e)(i.Y36(m.p))},e.\u0275cmp=i.Xpm({type:e,selectors:[["app-ts-book"]],decls:1,vars:0,template:function(a,d){1&a&&i._UZ(0,"router-outlet")},dependencies:[l.lC]}),e})();function t(e){return`<!DOCTYPE html>\n  <html>\n  <head>\n    <style>\n      html { font-size: 16px; }\n      a { text-decoration: none; }\n    </style>\n  </head>\n  <body>\n    <br/><p><a href="${e}" target="_blank">Go to TS Playground.</a></p>\n  </body>\n  </html>`}const y="npm install -g typescript",x="npm init -y",f="function greet(name: string) { \n  return `Hello, ${name}!`; \n} \n\nconst message = greet('TypeScript'); \nconsole.log(message);",h="tsc main.ts",_="node main.js",b="tsc main.ts --watch",T="let age: number = 25;\nlet price: number = 49.99;",A="let firstName: string = 'John';\nlet lastName: string = 'Doe';",S="let isActive: boolean = true;\nlet isStudent: boolean = false;",w="const mySymbol: symbol = Symbol('description');\n\nconst obj = {\n  [mySymbol]: 'This is a value associated with the symbol'\n};\n\nconsole.log(obj[mySymbol]); // 'This is a value associated with the symbol'",v=t("https://www.typescriptlang.org/play?ts=5.1.6#code/MYewdgzgLgBAtgTwMoLgIxAGwFwwqjTGAXhhXSwAoAiAEwFMJgAnASwAcpXxqBKAbgCwAKBgjQkWCDQArEjADeImDADaicoQC6uagBUAFqwgxjMAIYwAbucwBXehYgQQwVuaj1aMAO6soBjABjvgUmNQiAL5CouLgLpj0AHSYIADmlNIy6sgEWFoCMAD0RTD6RiZmljb2jubOru6e3n4BQQYheeEiQA"),L="let age: number = '25'; // Error: Type 'string' is not assignable to type 'number'.",C="let myUndefined: undefined = undefined;",O="let myNull: null = null;",I="let myAny: any = 'Hello, TypeScript!';",k="let myUnknown: unknown = 'Hello, TypeScript!';\nif (typeof myUnknown === 'string') {\n    console.log(myUnknown.length);\n}",E=t("https://www.typescriptlang.org/play?ts=5.1.6#code/DYUwLgBAtgngqgOwNYIPYHcEC4IFdlqYQC8EA5ABIjDCoA0EAKjAA4gDKAxgE4CWLYAIRkA3AFgAULwBmEABRhWIVLNiIUGBCWKkyAZzB8EAczIBKCAG9JEWxE6oEe1KAB0tY3LUFN7kCbAACzNxCQBfIA"),B="function throwError(message: string): never {\n  throw new Error(message);\n}",D="const uniqueKey: unique symbol = Symbol('unique property');\nconst obj = {\n  [uniqueKey]: 'This is a value associated with the unique symbol'\n};",U="let age: number = 25;\nlet firstName: string = 'John';\nlet isActive: boolean = true;",N="const pi: number = 3.14159;\nconst greeting: string = 'Hello, TypeScript!';",M="const name: string = 'Alice';\nname = 'Bob'; // Error: Cannot assign to 'name' because it is a constant.",Y="let age: number = 25; // age is explicitly annotated as type number \nfunction greet(name: string): string { \n  return `Hello, ${name}!`; \n}",j="let temperature = 30; // TypeScript infers temperature as type 'number'\nconst appName = 'MyApp'; // TypeScript infers appName as type 'string'",H="let age: number = 25; // Type annotation\nlet name = 'Alice'; // Type inference",F="let numbers: number[] = [1, 2, 3, 4, 5];\nlet names: string[] = ['Alice', 'Bob', 'Charlie'];",P="let temperatures = [25, 30, 22]; // TypeScript infers temperatures as number[]",Q="let fruits: string[] = ['apple', 'banana', 'orange'];\nlet firstFruit: string = fruits[0]; // 'apple'\nlet secondFruit: string = fruits[1]; // 'banana'",R="let numbers: number[] = [1, 2, 3, 4, 5];\nlet length: number = numbers.length; // Property 'length' is inferred as number\nnumbers.push(6); // push() method is type-checked for number[]\nlet poppedNumber: number | undefined = numbers.pop(); // pop() method returns a number or undefined if the array is empty",G="let colors: string[] = ['red', 'green', 'blue'];\n\nfor (let i = 0; i < colors.length; i++) {\n  console.log(colors[i]);\n}\n\ncolors.forEach(color => {\n  console.log(color);\n});\n\nfor (let color of colors) {\n  console.log(color);\n}",W=t("https://www.typescriptlang.org/play?ts=5.1.6#code/DYUwLgBAxg9sMCcDOAuCSwIJYDsDmA2gLoQC8EBA5AiACaUA0EleNIOjzARsAK4iUiAbgCwAKHEAzRBAAUoSFjIQADEIhKAPNDiIkAOlD4wAC3VYA1BYCUEAN7iIOnEjghDMPLNjxkBLETWomIAvuLiPnr60ggAogCGUCbeughkAHz2js6uoB5ekQhB4iHFEmIxcgo6vhAwkjV6tg5iTrAubvkpvmUhQA"),J="let mixedArray: (number | string)[] = [1, 'two', 3, 'four'];",K="let readOnlyArray: readonly number[] = [1, 2, 3];\nreadOnlyArray.push(4); // Error: Property 'push' does not exist on type 'readonly number[]'",z="let person: [string, number] = ['Alice', 30];",V="let name: string = person[0]; // 'Alice'\nlet age: number = person[1]; // 30",q="let coordinate = [10, 20]; // TypeScript infers coordinate as [number, number]",X="function getCoordinates(): [number, number] {\n  return [10, 20];\n}\n\nlet [x, y] = getCoordinates();",Z="let optionalTuple: [string, number?] = ['Alice'];",$="let multiValueTuple: [string, ...number[]] = ['Alice', 1, 2, 3];",ee="let measurements: [string, number][] = [['height', 180], ['weight', 75]];",te="function add(a: number, b: number): number {\n  return a + b;\n}",ae="let mathFunction: (x: number, y: number) => number;\nmathFunction = add;",oe="function processValue(input: string): string;\nfunction processValue(input: number): number;\nfunction processValue(input: string | number): string | number {\n  if (typeof input === 'string') {\n    return input.toUpperCase();\n  } else {\n    return input * 2;\n  }\n}",ie="function doSomething(callback: (result: string) => void) {\n  const result = 'Finished';\n  callback(result);\n}",re="const multiply = (a: number, b: number): number => a * b;",se="function greet(name: string, age?: number): string { \n  if (age) { \n    return `Hello, ${name}! You are ${age} years old.`; \n  } else { \n    return `Hello, ${name}!`; \n  } \n} \n\nconsole.log(greet('Alice'));           // Output: Hello, Alice! \nconsole.log(greet('Bob', 30));         // Output: Hello, Bob! You are 30 years old.",ne=t("https://www.typescriptlang.org/play?ts=5.1.6#code/GYVwdgxgLglg9mABAcwE4FN1QBRgIYC26AXIgM5SoxjIA0iey6A-KWCAQEbqoCUpFKjUQBvRAFgAUIkQxgibI3S9RE6TMQYoIVEgAGACXQAbY3HoASEfiIBfAISIAmnBAMMiK0tuIAnujxUMkQ4YwATADo9AG41GR8TMnRVKQ1NLB19I1NzT2tCdAcYuMQfKTLpKQgEMlD0CLNkbDRMHAByAEFjGAh0Nt5eWLThxAB6UcQAeRAoAAcZ0myzei6e9EcqmrqGuCaWrGw2gCE4Tjb6AGYABgGhkbGJ6bmFxCXck85HFzdA5Ou-AJBELhCJSIA"),le="function introduce(name: string, role: string = 'user'): string { \n  return `My name is ${name} and I am a ${role}.`; \n} \n\nconsole.log(introduce('Alice'));       // Output: My name is Alice and I am a user. \nconsole.log(introduce('Bob', 'admin')); // Output: My name is Bob and I am an admin.",ce=t("https://www.typescriptlang.org/play?ts=5.1.6#code/JAMwrgdgxgLglgewgAjhGAnBATMUCmAFBAIYC2+AXMgM6ZoDmANMlgDZW30QPIC8yAORga+DIICU1OhkbIA3sgCwAKGSt8MMBhQADALIBPZKQqoayACTzT+AL7ISEbMgCSjso6vz29gHS6ANzKKg6qIVBINAgcfmwIDIRomDh4RIIAgmxwBJISweqFyAD0xcgA8mAwAA5V1EYm5PjmyFk5zU4u7uReImJ+EVEx+HEJSehYuASEggBCCABGgiyCJNhkaHnBpRVVtTD1xrYt8wuOzm4e547raH6qQA"),de="function greetUser(firstName: string, lastName?: string, title: string = 'Mr.'): string { \n  if (lastName) { \n    return `Hello, ${title} ${firstName} ${lastName}!`; \n  } else { \n    return `Hello, ${title} ${firstName}!`; \n  } \n} \n\nconsole.log(greetUser('John'));                   // Output: Hello, Mr. John! \nconsole.log(greetUser('Alice', 'Smith'));          // Output: Hello, Mr. Alice Smith! \nconsole.log(greetUser('Bob', undefined, 'Dr.'));  // Output: Hello, Dr. Bob!",pe=t("https://www.typescriptlang.org/play?ts=5.1.6#code/JAMwrgdgxgLglgewgAgOYCcCmmYFUDOm6AFCHOvjAHICGAtpgFzKXpwSoA0yANjZbQYB+Zq3Zdk8GDyYsYbDsgC8yAOQBZdADpVASlHzxyAN7IAsAChkyOCGTE+A+pl0nzV68iwww6FAAMACUweHgRuABJjKRkAX2QosgpqZ3ioxxSGWIBCfwBud2t4kMI3S08vHF8A4NDwhOi4aUw04ySnLNyC8uR4yz6rSygkfAQZLTDUYgxsPEISVQApBAALCD1dAortnc8Aej3kAHkwGAAHU+ZasO5NLWRltez3YYhR8cnprBwCImJVACCPDgUEwqm4qgAynQmisNltdsgDsdThcYFcQjdkHdkECQZhkNDYc8hiMxpgJggpjMfvN-gAhBAAI3ByEgABNMGQIJh2RCACLaeHWZEnc6XZDXeqC+6MpnZIA"),ue="function sumNumbers(...numbers: number[]): number {\n  return numbers.reduce((total, num) => total + num, 0);\n}",me="class MyClass {\n  // Properties and methods go here\n}",ge="class Person {\n  constructor(public firstName: string, public lastName: string) {}\n}\n\nconst person = new Person('John', 'Doe');\nconsole.log(person.firstName); // Output: John",ye=t("https://www.typescriptlang.org/play?ts=5.1.6#code/MYGwhgzhAEAKCmAnCB7AdtA3gWAFDWmHQgBdEBXYElRACgAdyAjEAS2GgDNXkSA5MAFt4ALmilErNAHMANNEYt20cKQHCxEqdICUWAL55D+PETSkFSVBgC80NPADucK+loByAFIoAFmnfy7gAiKPDuOgDcpsQoIPAAdCAo0gyuaPHcvOrwkdAA9HnQAPLkJIwkYt5+QA"),xe="class Student {\n  public readonly school: string = 'MountainView School';\n  private studentId: number;\n\n  constructor(studentId: number) {\n    this.studentId = studentId;\n  }\n}",fe="class Circle {\n  private _radius: number;\n\n  constructor(radius: number) {\n    this._radius = radius;\n  }\n\n  get radius(): number {\n    return this._radius;\n  }\n\n  set radius(value: number) {\n    if (value >= 0) {\n      this._radius = value;\n    } else {\n      throw new Error('Radius cannot be negative.');\n    }\n  }\n\n  get area(): number {\n    return Math.PI * this._radius * this._radius;\n  }\n}",he="class Calculator {\n  public add(a: number, b: number): number {\n    return a + b;\n  }\n}",_e="class MathUtils {\n  static PI: number = 3.14;\n\n  static calculateCircumference(radius: number): number {\n    return 2 * MathUtils.PI * radius;\n  }\n}",be="class BankAccount {\n  private balance: number;\n\n  constructor(initialBalance: number) {\n    this.balance = initialBalance;\n  }\n\n  public deposit(amount: number): void {\n    this.balance += amount;\n  }\n}",Te="abstract class Shape {\n  // Properties and methods go here\n}",Ae="abstract class Shape {\n  abstract calculateArea(): number;\n}\n\nclass Circle extends Shape {\n  constructor(private radius: number) {\n    super();\n  }\n\n  calculateArea(): number {\n    return Math.PI * this.radius * this.radius;\n  }\n}\n\nclass Square extends Shape {\n  constructor(private sideLength: number) {\n    super();\n  }\n\n  calculateArea(): number {\n    return this.sideLength * this.sideLength;\n  }\n}",Se="class Parent {\n  greet(): void {\n    console.log('Hello from Parent');\n  }\n}\n\nclass Child extends Parent {\n  greet(): void {\n    console.log('Hello from Child');\n  }\n}",we=t("https://www.typescriptlang.org/play?ts=5.1.6#code/MYGwhgzhAEAKYCcCmA7ALtA3gWAFDWgHNkk0AKASgC5oA3AewEsATLPAg4elCekJAHQh6hMgHIAEkhDDoAMwT0AtnESo0YigG520AL54D+PKEgwAwgAtGIVkgAeaVMxjxk6NviIly1Ok1YcL05uXn4hEXEpGXp5RRUrG2ZNHS8jPSA"),ve="const circle = new Circle(5);\nconsole.log(circle.calculateArea()); // Output: 78.53981633974483\n\nconst square = new Square(4);\nconsole.log(square.calculateArea()); // Output: 16\n\nconst child = new Child();\nchild.greet(); // Output: Hello from Child",Le=t("https://www.typescriptlang.org/play?ts=5.1.6#code/IYIwzgLgTsDGEAJYBthjAgygC2ABwFMEBvAWACgEFRIZ4lhlYBXVCAgQSgOAAoBKAFwIAdswC2IAlADcFAL4UKKNBgDCASygoiBAB7sRAEww58RMpSQB7EbWbxrUXnigaAbsHYIYRjczBhMUlpfhIKKiowZkJnfjkrRXIIhiZWL05uPiFRCSkocKsqbghmKBEEAFkvbAA6AAUASQQAKgQIbA0wWt9-DDaOrp7gPwCEqiSk5VR0LABHZmBuBH1DEyxcQkKqWFt7R2dXDwyEMA0jAgAZAhEAcw6gvNDtyOjYgXGEKatYRhY2TI8ASPEIFSyRHwEUrldqdbpnC7XO4dVqwoYIq43e7YT6TJTkFSzepLG6IcEIW7cKHAhDuaznF47PbWZAEWrIay3XgAIgAEgRkByEAAzKDWcQIYncEQQbnxFJ45IEmbqTrIIwrAw3dZS0kvSkEak5OkM8lMuwstkcrl8gVC0XihBqNVGOW4hT43Z2RCwLQ6BAAXlEBAA7k6-azeABWeUE5ms9mc3i+7QJ35pAFcIH8eIIAD0eYQAHlmBA8KXhAB2AActSjAGYAJzVgCMADZ603KwAWbvV+uevaIMALEmB4NhzCj7i8buxr1gS2JrkjxbcWrp-4ZLPZXMF4ul8sQYTtwfepAu8ciUNOl0fZQu2oGo0yfOFktlisIfmC6wisUSs6GjqhQQA"),Ce="interface Person {\n  firstName: string;\n  lastName: string;\n  age: number;\n  greet(): string;\n}",Oe="class Employee implements Person { \n  firstName: string; \n  lastName: string; \n  age: number; \n  \n  constructor(firstName: string, lastName: string, age: number) { \n    this.firstName = firstName; \n    this.lastName = lastName; \n    this.age = age; \n  } \n  \n  greet() { \n    return `Hello, my name is ${this.firstName} ${this.lastName}.`; \n  } \n}",Ie="interface Book {\n  title: string;\n  author: string;\n  pages?: number; // Optional property\n}",ke="interface Circle {\n  readonly radius: number;\n}",Ee="type Age = number;\ntype Name = string;\n\nlet age: Age = 25;\nlet name: Name = 'Alice';",Be="type Person = {\n  firstName: string;\n  lastName: string;\n  age: number;\n};\n\nlet person: Person = {\n  firstName: 'John',\n  lastName: 'Doe',\n  age: 30,\n};",De="type ID = string | number;\ntype Point = { x: number; y: number };\ntype PointWithLabel = Point & { label: string };",Ue="type MathFunction = (x: number, y: number) => number;\n\nlet add: MathFunction = (a, b) => a + b;",Ne="type ReadonlyPerson = Readonly<Person>;\ntype OptionalPerson = Partial<Person>;",Me="type Wrapper<T> = { value: T };\n\nlet stringWrapper: Wrapper<string> = { value: 'Hello' };\nlet numberWrapper: Wrapper<number> = { value: 42 };",Ye="let value: any = 'Hello, TypeScript!';\nlet length: number = (<string>value).length;",je="let value: any = 'Hello, TypeScript!';\nlet length: number = (value as string).length;",He="function castToType<T>(value: any): T {\n  return value as T;\n}\n\nlet stringValue: string = castToType<string>('Hello');",Fe="function isString(value: any): value is string {\n  return typeof value === 'string';\n}\n\nlet value: any = 'Hello';\nif (isString(value)) {\n  let length: number = value.length;\n}",Pe="function isStringArray(value: any[]): value is string[] {\n  return value.every(item => typeof item === 'string');\n}\n\nlet array: any[] = ['Hello', 'World'];\nif (isStringArray(array)) {\n  let firstItem: string = array[0];\n}",Qe="type StringOrNumber = string | number;\n\nlet value: StringOrNumber = 'Hello';\nlet length: number = (value as string).length; // Type assertion",Re="type StringOrNumber = string | number;\n\nlet value: StringOrNumber = 'Hello';\nif (typeof value === 'string') {\n  let length: number = value.length; // No type assertion needed\n}",Ge="enum Color {\n  Red,\n  Green,\n  Blue,\n}",We="let myColor: Color = Color.Green;",Je="enum Direction {\n  Up = 'UP',\n  Down = 'DOWN',\n  Left = 'LEFT',\n  Right = 'RIGHT',\n}\n\nlet direction: Direction = Direction.Up;",Ke="enum Status {\n  Active = 'ACTIVE',\n  Inactive = 'INACTIVE',\n  Pending = 'PENDING',\n}",ze="let currentStatus: Status = Status.Active;\nconsole.log(currentStatus); // Output: 'ACTIVE'",Ve=t("https://www.typescriptlang.org/play?ts=5.1.6#code/KYOwrgtgBAygLgQzmAzlA3gWAFBSgQQGM4BLAN2CgF4oByfAYQBUBJANQFFaAaHPFkAmLlKNWiwByjVpx58oABVAATEiADm1Ogo4SAIpIDic7AF8cOADbA4UQmABOD0HHhJUALliJkaGm98AOiJSCgBuHEIAexAUKOtAyyj1AAp7JxcA1ABKMKgAenyoAHkwOAAHMq96ZnYuHCA"),qe="enum Size {\n  Small = 1,\n  Medium = 2,\n  Large = 3,\n}",Xe="enum Fruit {\n  Apple,\n  Banana,\n}\n\nlet fruitName: string = Fruit[1]; // 'Banana'",Ze="enum Color { \n  Red, \n  Green, \n  Blue, \n} \n\nfor (let key in Color) { \n  if (isNaN(Number(key))) { \n      console.log(`Enum member: ${key}, Value: ${Color[key]}`); \n  } \n}",$e=t("https://www.typescriptlang.org/play?ts=5.1.6#code/KYOwrgtgBAwg9gGzgJygbygWAFBSgJWABMAaLXKAcWWFDJzwCEExh7sBfc8gMxSgAUCYABcoAa2ABPKAEsQsRCgCU6bnJ6DZAZwByAQ10DdkAEbBkAyVOW21DPI4DGcENsTAAdEgDmAgAYAouDQEMAQ5sgAXFAAJGjWHGQAavoswDHx8EjIANrWALoc-soA3OpcOBw4QA"),et="enum Direction { \n  Up, \n  Down, \n  Left, \n  Right, \n} \n\nObject.keys(Direction).forEach(key => { \n  if (isNaN(Number(key))) { \n      console.log(`Enum member: ${key}, Value: ${Direction[key as keyof typeof Direction]}`); \n  } \n});",tt=t("https://www.typescriptlang.org/play?ts=5.1.6#code/KYOwrgtgBAIglgJ2AYwC5wPYigbygWACgooBVABwBoDjYMB3EaokgGWADNVnaAlOAOYALbjQC+NGgHkARgCsUqAHQBrYAE8AzgAp4SNJhABKJRwwIAogENkQ7WvVQAvAD5ckqHA5RtcTQDkrf21-SBlgBHsNIxj3FhIE5CxNDAAbYCVUjAFtAAMLcGgIYAhwhAAuKAASHAcxagA1K1SwYEqavUVDAG0HKCtNKAcMb1R1cmAR2EQurABdMVyjAG4PCSIxFaIgA"),at="enum Status { \n  Active, \n  Inactive, \n  Pending, \n} \n\nfor (const value of Object.values(Status)) { \n  console.log(`Enum value: ${value}`); \n}",ot=t("https://www.typescriptlang.org/play?ts=5.1.6#code/KYOwrgtgBAygLgQzmAzlA3lAsAKClAQQGM4BLAN2ABps8oBJEBEi62-ABVABNSQBzGrgC+7XADMA9gCcoACiKSQKOFHIIANmGBRJ4qAHkARgCtgJAHTqtwFHPhJUASicZ2URcskbgFjZP45AAMAUXBoa20ALigAEnRI4GEgpwBuWmFcIA"),it="enum Day {\n  Sunday,\n  Monday,\n  Tuesday,\n  Wednesday,\n  Thursday,\n  Friday,\n  Saturday,\n}\n\nlet today: Day = Day.Wednesday;\nconsole.log(today); // Output: 3\n\nlet dayName: string = Day[3]; // 'Wednesday'",rt=t("https://www.typescriptlang.org/play?ts=5.1.6#code/KYOwrgtgBAIghgTygbwLACgpQMphAE0QBoMsBZAewONKgBUxgBnQhEzKAdWHxGdfZY6ACzAAnFjQ4AxMQEsBtbHAAu4xegC+GDABtgKqCoqsAXLERQAvBYQA6br36IA3BgDGVJhX13dFAHMACmNWAEoXKAB6KKgAeTAVAAdE8wBmHXR9Q1YAOTgIYHMmFXkQAOtbAG00gF1ImKgAIkc+SQQmjCA"),st="function identity<T>(value: T): T {\n  return value;\n}\n\nconst numberResult = identity(42); // TypeScript infers T as number\nconst stringResult = identity('Hello'); // TypeScript infers T as string",nt="class Box<T> {\n  private value: T;\n\n  constructor(value: T) {\n    this.value = value;\n  }\n\n  getValue(): T {\n    return this.value;\n  }\n}\n\nconst numberBox = new Box<number>(42); // Creates a Box<number> instance\nconst stringBox = new Box<string>('Hello'); // Creates a Box<string> instance",lt="function combineArrays<T, U>(arr1: T[], arr2: U[]): (T | U)[] {\n  return [...arr1, ...arr2];\n}\n\nconst combinedArray = combineArrays([1, 2], ['a', 'b']); // Array of mixed types: [1, 2, 'a', 'b']",ct="const explicitResult = identity<number>(42); // Specifies T as number\nconst explicitBox = new Box<string>('Hello'); // Specifies T as string",dt="interface Lengthy {\n  length: number;\n}\n\nfunction logLength<T extends Lengthy>(item: T): void {\n  console.log(item.length);\n}",pt="interface Printable {\n  print: () => void;\n}\n\nfunction processItem<T extends Lengthy & Printable>(item: T): void {\n  console.log(item.length);\n  item.print();\n}",ut="function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\nconst person = { name: 'Alice', age: 30 };\nconst name = getProperty(person, 'name'); // Type of name is string\nconst age = getProperty(person, 'age'); // Type of age is number",mt="class Animal { \n  constructor(public name: string) {} \n} \n\nclass Cat extends Animal { \n  meow(): void { \n    console.log('Meow!'); \n  } \n} \n\nfunction adopt<T extends Animal>(animal: T): void { \n  console.log(`You adopted ${animal.name}`); \n} \n\nconst cat = new Cat('Whiskers'); \nadopt(cat); // Outputs: You adopted Whiskers",gt=t("https://www.typescriptlang.org/play?ts=5.1.6#code/MYGwhgzhAECCB2BLAtmE0De0CwAoa0wA9vBAC4BOArsGURQBQAOVARiIsNPGMgKYAuaOQqJ4AcwCUmAL45ccvPNCQYAYTBlofAB5k+8ACYwEKNJnkF+RAO4NJQgG5FEhi0oKESEIiD4A6ECJxBgByAFk+WwBCUMkAbktoRQVLPAAzKnhaRBJoMEMiJjIAHgAVbT0DYzgkVBAAPgYwOrQhModoZ1d3fC9SXwCgkIADAE0iKnzC4r43ABIMFrMQfx5+GRGE+RTlby1gTWgAXm4+G2gNMjCAdQALRAgAaz4KCDjEvAKi68OybYA9ADoAB5KhkFhkCBCCZTb6zNz3R4vN5AA"),yt="type Result = string | number;\n\nlet data: Result;\ndata = 'Hello'; // Valid\ndata = 42;      // Valid\n// data = true; // Error: Type 'boolean' is not assignable to type 'Result'",xt="type Person = {\n  firstName: string;\n};\n\ntype Employee = {\n  employeeId: number;\n};\n\ntype EmployeePerson = Person & Employee;\n\nlet employee: EmployeePerson = {\n  firstName: 'Alice',\n  employeeId: 123,\n};",ft="type Value = string | number;\n\ntype Configurable = {\n  readonly id: number;\n};\n\ntype ConfigurableValue = Value & Configurable;",ht="function isString(value: any): boolean {\n  return typeof value === 'string';\n}\n\nlet data: any = 'Hello, TypeScript!';\nif (isString(data)) {\n  // Inside this block, TypeScript knows that 'data' is of type 'string'\n  console.log(data.toUpperCase());\n}",_t=t("https://www.typescriptlang.org/play?ts=5.1.6#code/GYVwdgxgLglg9mABDAzgORAWwEYFMBOAFAG4CGANiLgFyKlgCeAlLWZbsiomFnvogG8AsAChEifLigh8SKAwAOuOMERsqiALzbEAch44CugNyiAvqMSjQkWAkQL8cCLhQoAahSokvNRCih8GDAAc0QAH25eAhY1OBgAE0FLZFVCVAxDInVcJiZksXEigHpixABJMBREjigAC1REbHJnAGsAGkQAFUVcAGUIIIUoRFawOAB3LnrSEd0c3U5EFUR5JT0DPl0UosQIBBQ4clwAOhaQn3ZEACpEACYmU0KzRFxyFA5hQt3Siqqa1YNLjNNqdHpKAZDEZjSbTOqzPQLJYrNYcXQBIKhbbfIr7KpHU7nS5UE5QOAAVQUSnwAGFSB9CHknuILCIzEA"),bt="function isNumber(value: any): value is number {\n  return typeof value === 'number';\n}\n\nfunction processValue(value: string | number): void {\n  if (isNumber(value)) {\n      // Inside this block, TypeScript knows that 'value' is of type 'number'\n      console.log(value * 2);\n  } else {\n      // Inside this block, TypeScript knows that 'value' is of type 'string'\n      console.log(value.toUpperCase());\n  }\n}",Tt=t("https://www.typescriptlang.org/play?ts=5.1.6#code/GYVwdgxgLglg9mABDAzgORAWwEYFMBOAFAG4CGANiLgFyKlgCeAlLWZbsiomFnvogG8AsAChEifLigh8SKAwAOuOMERsqiALzbEAch44CugNyiAvqMSjQkWAkQL8cCLhQoAahSokvNRCih8GDAAc0QAH25eAhY1OBgAE0FLZFVCVAxDInVcJiZksXEigHpixABJMBREjigAC1REbHJnAGsAGkQAFUVcAGUIIIUoRFawOAB3LnrSEd0c3U5EFUR5JT0DPl0UosQIBBQ4clwAOhaQn3ZEACpEACYmU0KzRFxyFA5hQt3Siqqa1YNLjNNqdHpKAZDEZjSbTOqzPQLJYrNYcXQBIKhbbfIr7KpHU7nS5UE5QOAAVQUSnwAGFSB9CHknuILCIzEA"),At="function hasNameProperty(obj: any): obj is { name: string } {\n  return 'name' in obj;\n}\n\nlet item: any = { name: 'Book' };\nif (hasNameProperty(item)) {\n  // Inside this block, TypeScript knows that 'item' has a 'name' property of type 'string'\n  console.log(item.name.toUpperCase());\n}",St=t("https://www.typescriptlang.org/play?ts=5.1.6#code/GYVwdgxgLglg9mABACwIYGcByqC2BTABQCc4AHPIqATwAo4AjAKwC5FUwqBKVhxxGdIgDeiMLjyt0UIjDABzRAF9hAWABQiRETxQQRJAHIx+A-yS8A3OsXrE6gDY7+UPDlbsqiALzDR41gYAQnBwANamilZqMMCINGhY4sRkFNQ0MC44nJyqGogA9PmIAJJg6DAAJniIUMgCiPT2cBChADSIACpU5ADKEDKkUIihYHAA7oK1qEMGGa6mCWyIRuKmpCTklJ5wsdTky1Iy8ga2iBAI6HCOAHRNcumZ18Z411BwAKqkmwDCGHg02SiiiAA"),wt="function getNameLength(name: string | null): number {\n  // return name.length; // Error: 'name' is possibly 'null'\n\n  return name!.length; // No Error\n}",vt="T extends U ? X : Y",Lt="type Extract<T, U> = T extends U ? T : never;\ntype Exclude<T, U> = T extends U ? never : T;\n\ntype Result1 = Extract<'a' | 'b' | 'c', 'a' | 'c'>; // 'a' | 'c'\ntype Result2 = Exclude<'a' | 'b' | 'c', 'a' | 'c'>; // 'b'",Ct="type Filter<T> = T extends string ? T : never;\ntype Result = Filter<'a' | 123 | 'b'>; // Result is 'a' | 'b'",Ot="type Partial<T> = {\n  [P in keyof T]?: T[P];\n};",It="type ReadonlyProperties<T> = {\n  readonly [P in keyof T]: T[P];\n};\n\ntype NullableProperties<T> = {\n  [P in keyof T]: T[P] | null;\n};",kt="type NonOptional<T> = {\n  [P in keyof T]-?: T[P];\n};",Et="interface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ntype OptionalUser = Partial<User>;\ntype ReadonlyUser = ReadonlyProperties<User>;\ntype NullableUser = NullableProperties<User>;\ntype RequiredUser = NonOptional<User>;",Bt="type Required<T> = {\n  [P in keyof T]-?: T[P];\n};\n\nfunction setDefaults<T>(input: T): Required<T> {\n  const defaults = {} as Required<T>;\n  for (const key in input) {\n    defaults[key] = input[key];\n  }\n  return defaults;\n}\n\nconst defaultUser = setDefaults({ id: 0, name: '', email: '' });",Dt="function myClassDecorator(constructor: Function) {\n  console.log('Class decorator called');\n}\n\n@myClassDecorator\nclass MyClass {\n  // Class implementation\n}",Ut=t("https://www.typescriptlang.org/play?experimentalDecorators=true&ts=5.1.6#code/GYVwdgxgLglg9mABAWwJ4GEA2BDAzrgEQFMI4AnbKcgClLFyjJGnIC5EAxcaeMASkQBvALAAoRIjq44mIgDpMcAObUA5Fjy5EAExLlK5SdkyztqvgG4xAXzGIxAATQb8xUhSpkxEHPkQBZDF8tEXFEAHpwxBctGGQAB1lkIjAoSl4bIA"),Nt="function prefix(prefixStr: string) {\n  return function(target: Function) {\n    target.prototype.prefix = prefixStr;\n  };\n}\n\n@prefix('My')\nclass Example {\n  // Class implementation\n}\n\nconst example = new Example();\nconsole.log(example.prefix); // Output: 'My'",Mt=t("https://www.typescriptlang.org/play?experimentalDecorators=true&ts=5.1.6#code/GYVwdgxgLglg9mABABwE4FNgwB4Ao2Y4DKUqAXIgM6kxgDmAlIgN4CwAUIohlCKkqEiwEuKAENUddFAoAxcNHhgmbTl0TjJ0gHRo4UfQE9k6XRizZEAXhTnipANwcuAXyfsXzjgAECF3ADkALKGAQwcEAA2YpSUiACi2GIAtsiR6CzOiAD02YgAwtGxiDCp6cnoYOLCYByenBEI1IjoSWUZNmDoAO4JbWnouAzuEE1w6dqRcHS4rSkDZoTYwzl5APIgUMibFMGhHEA"),Yt="function logMethod(target: any, key: string, descriptor: PropertyDescriptor) { \n  const originalMethod = descriptor.value; \n  \n  descriptor.value = function (...args: any[]) { \n    console.log(`Calling ${key} with arguments: ${args.join(', ')}`); \n    const result = originalMethod.apply(this, args); \n    console.log(`Method ${key} returned: ${result}`); \n    return result; \n  }; \n  \n  return descriptor; \n} \n\nclass Calculator { \n  @logMethod \n  add(a: number, b: number): number { \n    return a + b; \n  } \n} \n\nconst calculator = new Calculator(); \ncalculator.add(2, 3);",jt=t("https://www.typescriptlang.org/play?experimentalDecorators=true&ts=5.1.6#code/GYVwdgxgLglg9mABAGzgcwLIFMoAs4AmAFFAIYBOaOAXIqWAJ4A0iA1lg7QM5TkxhoWBLFwh8ADlDjlaABXJxxWclAYAREWJiTpASkQBvRAFgAUIkQQEPRNJhp+pZNjyFEAXkTDREqeQB0AG5OIFgA3CbmkRbeWjoBwcihHoigkLAIiET+ORRoXLT0DADaALr6RmYWFlZgXHDIWP6oaEQABgDCTsj8aIgAJAbsDAC+iADuMHh0lCAAtlhgUAUDBnlc-gBWcPxEAOQse7ojbboRVdW1NuQiIMhQKXYOYE4u+AT+pOLiyAwkuDAuCx1mdopdrA0mi12m83INhmMblAQOQwFgCLRBjcuHcoCdQRcLEiUUhsbjzlERhSLBdiaivJpfNIKWMqmYIMhSFwuIgusgIHdSH5DGCAAItWEEMGkAjEUi0MDzABGyhYSoVyuUug1cxV5BFhMQdKQpEQAGpEErqYhWaZbZErg8IE4BZzhZ40eNeS7BX4iATTM7+b7pJ9ZUQAEwsADMZyAA"),Ht="function logProperty(target: any, key: string) { \n  let value = target[key]; \n  \n  const getter = () => { \n    console.log(`Getting value of property ${key}: ${value}`); \n    return value; \n  }; \n  \n  const setter = (newValue: any) => { \n    console.log(`Setting value of property ${key}: ${newValue}`); \n    value = newValue; \n  }; \n  \n  Object.defineProperty(target, key, { \n    get: getter, \n    set: setter, \n    enumerable: true, \n    configurable: true, \n  }); \n} \n\nclass Person { \n  @logProperty \n  name: string = 'Alice'; \n} \n\nconst person = new Person(); \nconsole.log(person.name); \nperson.name = 'Bob';",Ft=t("https://www.typescriptlang.org/play?experimentalDecorators=true&ts=5.1.6#code/GYVwdgxgLglg9mABAGzgcwAoCc4AcCmWUAngBRQCGWa+UAXIhWMQDSIDW+xDAzlFjDBoAlIgDeiALAAoRClqIAbhWQh8iALyJK1WgG1OxALoBuKbPNyICPohpQohTYlKiNAPnGW5ia2B5wyPgAdKhopAAGAOK0sEJKKmqIcMCIuDgERMSIACRihgC+DHnKqvgFEcJmMj6IWLQgWEilatUWBW1yNb42UIg8sU5apGD4AO4Aaon4DEzEbp4S3VY2gSFhkQDKsYJoCWXJqel4hCS5+VxF56OT0xVV3nIt6lo3U2WdiB3e3QDyAEYAK3w0GCABN8MBBPhsCcsuQqPY2IY2EsLHJ7Ax7I4sGxlv1aLxBrjHoh8GAQABbQgUf5BBj8NR49E9MBQtCNWn07RYJneAoPGQFSwyCDICg8HiIDCEAJINFyAACYVhmTO3TAFGpvH4u2cAHIAILIGAQfD6trCmqi3ppWUIZw3aX2sCuNp+AJBULoUiZOXBTXUwXSP0IANal6IfUAITg-wtQA"),Pt="function parameterLogger(target: any, methodName: string, parameterIndex: number) { \n  console.log(`Parameter decorator called on ${methodName} at index ${parameterIndex}`); \n} \n\nclass ExampleClass { \n  greet(@parameterLogger message: string) { \n    console.log(`Hello, ${message}!`); \n  } \n} \n\nconst exampleInstance = new ExampleClass(); \nexampleInstance.greet('World');",Qt=t("https://www.typescriptlang.org/play?experimentalDecorators=true&ts=5.1.6#code/GYVwdgxgLglg9mABABwIYCdUFsCmUfoAycA5iQQBRQblQBciqYAngDSK5QAWcAJgHLYcDAM5R0MMCXZpMnAgEkwvHAA8GYEFgBGBAJSIA3ogCwAKESIICEXAA2OAHR3SFAAYAFDEPzpEK60woOD8IVDsHXkQERAASQ04eASEAX0YoREkVVTjDWR9FZTUUtz0AblMzNPNKiDtUERFEAFFVbGQHAGF6xqNKyxJ0HDwKAAF8+SJScj9cRtRyUXFJEgNjGssrG3snFxJ3AAkcCLh2eLmRBZwUgEJSio3qqv7zazAxRDV2hyUxJggcIgALyIMA4ADuLTaWA6OG6DREFHKlS+MJ+72okCcg2GUAoAHIAOohOy8fHlIA"),Rt="// math.ts\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}",Gt="// logger.ts\nexport default class Logger {\n  log(message: string): void {\n    console.log(message);\n  }\n}",Wt="// types.ts\nexport type Point = { x: number; y: number };",Jt="// operations.ts\nexport * from './math'; // Re-export all named exports from math.ts\nexport { default as MyLogger } from './logger'; // Re-export default export as MyLogger",Kt="// main.ts\nimport { add, subtract } from './math';\n\nconst result1 = add(10, 20);\nconst result2 = subtract(30, 5);",zt="// app.ts\nimport MyLogger from './logger';\n\nconst logger = new MyLogger();\nlogger.log('Hello!');",Vt="// main.ts\nimport { add as addition, subtract as subtraction } from './math';\n\nconst result1 = addition(10, 20);\nconst result2 = subtraction(30, 5);",qt="// geometry.ts\nimport type { Point } from './types';\n\nfunction calculateDistance(pointA: Point, pointB: Point): number {\n    // ...\n}",Xt="// main.ts\nimport * as mathModule from './math';\n\nconst result1 = mathModule.add(10, 20);\nconst result2 = mathModule.subtract(30, 5);",Zt="// Using a library with named exports\nimport { someFunction } from 'library';\n\n// Using a library with default export\nimport MyLibrary from 'my-library';",$t="namespace Shapes {\n  export class Circle {\n    // ...\n  }\n\n  export class Rectangle {\n    // ...\n  }\n}",ea='/// <reference path="shapes.ts" />\n\nconst circle = new Shapes.Circle();\nconst rectangle = new Shapes.Rectangle();',ta="namespace Geometry {\n  export namespace Shapes {\n    export class Circle {\n    // ...\n    }\n  }\n}",aa="node --inspect-brk my-ts-app.js",oa='{\n  "compilerOptions": {\n    "sourceMap": true\n  }\n}';var ia=o(7359);let s=(()=>{class e{constructor(){this.bookData=n}}return e.\u0275fac=function(a){return new(a||e)},e.\u0275cmp=i.Xpm({type:e,selectors:[["app-ts-chapter"]],decls:1,vars:1,consts:[[3,"bookData"]],template:function(a,d){1&a&&i._UZ(0,"app-chapter",0),2&a&&i.Q6J("bookData",d.bookData)},dependencies:[ia.l]}),e})();const ra=[{path:"",component:g,children:[{path:"chapter",component:s},{path:"chapter/:chid",component:s},{path:"chapter/:chid/section/:secid",component:s},{path:"**",component:s},{path:"",component:s}]}];let sa=(()=>{class e{}return e.\u0275fac=function(a){return new(a||e)},e.\u0275mod=i.oAB({type:e}),e.\u0275inj=i.cJS({imports:[l.Bz.forChild(ra),l.Bz]}),e})();var na=o(1375);let la=(()=>{class e{}return e.\u0275fac=function(a){return new(a||e)},e.\u0275mod=i.oAB({type:e}),e.\u0275inj=i.cJS({imports:[p.ez,sa,na.I]}),e})()}}]);