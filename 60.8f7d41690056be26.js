"use strict";(self.webpackChunkweb_building=self.webpackChunkweb_building||[]).push([[60],{8060:(Rr,u,t)=>{t.r(u),t.d(u,{RxjsBookModule:()=>Ar});var l={};t.r(l),t.d(l,{rxjs_1_1_1:()=>je,rxjs_1_1_2:()=>me,rxjs_1_1_3:()=>ve,rxjs_1_1_4:()=>fe,rxjs_1_1_5:()=>de,rxjs_1_1_6:()=>he,rxjs_2_2_1:()=>i,rxjs_2_2_1_1:()=>ge,rxjs_2_2_2:()=>b,rxjs_2_2_2_1:()=>ye,rxjs_2_2_3:()=>p,rxjs_2_2_3_1:()=>Se,rxjs_2_2_4:()=>x,rxjs_2_2_4_1:()=>Oe,rxjs_2_2_5:()=>j,rxjs_2_2_5_1:()=>ke,rxjs_2_2_6:()=>m,rxjs_2_2_6_1:()=>Ce,rxjs_2_2_7:()=>v,rxjs_2_2_7_1:()=>we,rxjs_2_3_1:()=>f,rxjs_2_3_1_1:()=>Ee,rxjs_2_4_1:()=>d,rxjs_2_4_1_1:()=>Be,rxjs_2_4_2:()=>h,rxjs_2_4_2_1:()=>Ae,rxjs_2_4_3:()=>g,rxjs_2_4_3_1:()=>$e,rxjs_2_4_4:()=>y,rxjs_2_4_4_1:()=>Re,rxjs_2_5_1:()=>Me,rxjs_2_5_2:()=>S,rxjs_2_5_2_1:()=>Ve,rxjs_2_5_3:()=>O,rxjs_2_5_3_1:()=>Te,rxjs_3_2_1:()=>k,rxjs_3_2_1_1:()=>Ie,rxjs_3_2_2:()=>C,rxjs_3_2_2_1:()=>We,rxjs_3_2_3:()=>w,rxjs_3_2_3_1:()=>Ue,rxjs_3_2_4:()=>E,rxjs_3_2_4_1:()=>De,rxjs_3_2_5:()=>B,rxjs_3_2_5_1:()=>Fe,rxjs_3_2_6:()=>A,rxjs_3_2_6_1:()=>ze,rxjs_3_3_1:()=>$,rxjs_3_3_1_1:()=>Je,rxjs_3_3_2:()=>R,rxjs_3_3_2_1:()=>Le,rxjs_3_3_3:()=>M,rxjs_3_3_3_1:()=>Ne,rxjs_3_3_4:()=>V,rxjs_3_3_4_1:()=>He,rxjs_3_4_1:()=>T,rxjs_3_4_1_1:()=>Pe,rxjs_3_4_2:()=>I,rxjs_3_4_2_1:()=>Xe,rxjs_3_4_3:()=>W,rxjs_3_4_3_1:()=>Ye,rxjs_3_4_4:()=>U,rxjs_3_4_4_1:()=>Ze,rxjs_3_4_5:()=>D,rxjs_3_4_5_1:()=>Ke,rxjs_3_5_1:()=>F,rxjs_3_5_1_1:()=>Qe,rxjs_3_5_2:()=>z,rxjs_3_5_2_1:()=>Ge,rxjs_3_5_3:()=>J,rxjs_3_5_3_1:()=>qe,rxjs_3_5_4:()=>L,rxjs_3_5_4_1:()=>er,rxjs_3_6_1:()=>N,rxjs_3_6_1_1:()=>rr,rxjs_3_6_2:()=>H,rxjs_3_6_2_1:()=>sr,rxjs_3_6_3:()=>P,rxjs_3_6_3_1:()=>or,rxjs_3_6_4:()=>X,rxjs_3_6_4_1:()=>tr,rxjs_3_7_1:()=>Y,rxjs_3_7_1_1:()=>nr,rxjs_3_7_2:()=>Z,rxjs_3_7_2_1:()=>cr,rxjs_3_7_3:()=>K,rxjs_3_7_3_1:()=>ar,rxjs_3_8_1:()=>Q,rxjs_3_8_1_1:()=>lr,rxjs_3_8_2:()=>_r,rxjs_4_1_1:()=>G,rxjs_4_1_1_1:()=>ur,rxjs_4_2_1:()=>q,rxjs_4_2_1_1:()=>ir,rxjs_4_3_1:()=>ee,rxjs_4_3_1_1:()=>br,rxjs_4_4_1:()=>re,rxjs_4_4_1_1:()=>pr,rxjs_4_5_1:()=>se,rxjs_4_5_1_1:()=>xr,rxjs_4_6_1:()=>oe,rxjs_4_6_1_1:()=>jr,rxjs_4_7_1:()=>te,rxjs_4_7_1_1:()=>mr,rxjs_4_8_1:()=>ne,rxjs_4_8_1_1:()=>vr,rxjs_4_9_1:()=>ce,rxjs_4_9_1_1:()=>fr,rxjs_4_9_2:()=>ae,rxjs_4_9_2_1:()=>dr,rxjs_5_2_1:()=>le,rxjs_5_2_1_1:()=>hr,rxjs_5_3_1:()=>_e,rxjs_5_3_1_1:()=>gr,rxjs_5_4_1:()=>ue,rxjs_5_4_1_1:()=>yr,rxjs_5_5_1:()=>ie,rxjs_5_5_1_1:()=>Sr,rxjs_6_1_1:()=>Or,rxjs_6_1_2:()=>kr});var be=t(6895),_=t(9299),n=t(4650),pe=t(4214);let xe=(()=>{class r{constructor(s){this.coreService=s}ngOnInit(){this.coreService.getRxjsBookData()}ngOnDestroy(){}}return r.\u0275fac=function(s){return new(s||r)(n.Y36(pe.p))},r.\u0275cmp=n.Xpm({type:r,selectors:[["app-rxjs-book"]],decls:1,vars:0,template:function(s,a){1&s&&n._UZ(0,"router-outlet")},dependencies:[_.lC]}),r})();function e(r,o,s=""){return`<!DOCTYPE html>\n  <html>\n  <head>\n    <style>\n      html { font-size: 16px; }\n      a { text-decoration: none; }\n    </style>\n    <script src="assets/js/utils2.js"><\/script>\n    <script src="https://unpkg.com/rxjs@^7/dist/bundles/rxjs.umd.min.js"><\/script>\n  </head>\n  <body>\n    ${s}\n    <script>\n      ${r.join(" ")}\n      ${o.replace(/import {/g,"//import {")}\n    <\/script>\n  </body>\n  </html>`}const je="node -v\nnpm -v",me="mkdir rxjs-tutorial\ncd rxjs-tutorial",ve="npm init",fe="npm install rxjs",de="// main.ts\n// Import RxJS\nimport { from } from 'rxjs';\n\n// Create an observable from an array\nconst numbers = from([1, 2, 3, 4, 5]);\n\n// Subscribe to the observable\nnumbers.subscribe(number => console.log(number));",he="node main.js",i="import { of } from 'rxjs';\n\n// Creating an Observable from individual values\nconst observable = of(1, 2, 3, 4, 5);\n\n// Subscribing to the Observable\nobservable.subscribe({\n  next: value => console.log(value),\n  complete: () => console.log('Observable complete')\n});",ge=e(["const { of } = rxjs;"],i),b="import { from } from 'rxjs';\n\nconst array = [1, 2, 3, 4, 5];\nconst observable = from(array);\n\nobservable.subscribe(value => console.log(value));",ye=e(["const { from } = rxjs;"],b),p="import { from } from 'rxjs';\n\nconst promise = fetch('assets/data/json/integer-array.json');\nconst observable = from(promise.then(response => response.json()));\n\nobservable.subscribe(response => console.log(response));",Se=e(["const { from } = rxjs;"],p),x="import { fromEvent } from 'rxjs';\n\nconst button = document.querySelector('button');\nconst clickObservable = fromEvent(button, 'click');\n\nclickObservable.subscribe(event => console.log('Button clicked!'));",Oe=e(["const { fromEvent } = rxjs;"],x,"<button>Click Me!</button>"),j="import { Observable } from 'rxjs';\n\nconst customObservable = new Observable(observer => {\n  observer.next(1);     // Emitting values\n  observer.next(2);\n  observer.complete();  // Completing the observable\n});\n\ncustomObservable.subscribe(\n  value => console.log(value),\n  error => console.error(error),\n  () => console.log('Observable completed')\n);",ke=e(["const { Observable } = rxjs;"],j),m="import { interval } from 'rxjs';\n\nconst intervalObservable = interval(1000); // Emit value every second\n\nconst subscription = intervalObservable.subscribe(value => console.log(value));\n\n// Unsubscribe after 5 seconds \nsetTimeout(() => { \n  subscription.unsubscribe(); \n  console.log('Subscription unsubscribed.'); \n}, 5000);",Ce=e(["const { interval } = rxjs;"],m),v="import { interval, queueScheduler, scheduled } from 'rxjs'; \nimport { observeOn } from 'rxjs/operators'; \n\n// Create an Observable that emits values at 1-second intervals \nconst source = interval(1000); \n\n// Use the scheduled operator to change the scheduler to queueScheduler \nconst scheduledSource = scheduled([source], queueScheduler); \n\n// Subscribe to the scheduled Observable \nconst subscription = scheduledSource.subscribe(value => { \n  console.log(`Emitted value: ${value}`); \n}); \n\n// Unsubscribe after 5 seconds \nsetTimeout(() => { \n  subscription.unsubscribe(); \n  console.log('Subscription unsubscribed.'); \n}, 5000);",we=e(["const { interval, queueScheduler, scheduled } = rxjs;","const { observeOn } = rxjs.operators;"],v),f="import { Observable } from 'rxjs';\n\n// Create an observable that emits values\nconst observable = new Observable(observer => {\n  observer.next(1);\n  observer.next(2);\n  observer.next(3);\n  observer.complete(); // Signal that the observable is completed\n});\n\n// Subscribe to the observable\nconst subscription = observable.subscribe(\n  value => console.log(value),     // Handle emitted values\n  error => console.error(error),   // Handle errors\n  () => console.log('Completed')   // Handle completion\n);\n\n// Later, when you're done with the observable, unsubscribe\nsubscription.unsubscribe();",Ee=e(["const { Observable } = rxjs;"],f),d="import { Observable } from 'rxjs';\n\nconst observable = new Observable(observer => {\n  const intervalHandle = setInterval(() => {\n    observer.next('Value');\n  }, 2000);\n\n  // Clean up when unsubscribing\n  return () => {\n    clearInterval(intervalHandle);\n  };\n});\n\nconst subscription = observable.subscribe(value => console.log(value));\n\n// Unsubscribe after 10 seconds\nsetTimeout(() => {\n  subscription.unsubscribe();\n  console.log('Subscription unsubscribed.');\n}, 10000);",Be=e(["const { Observable } = rxjs;"],d),h="import { Observable } from 'rxjs'; \n\nconst subscriptions = []; \n\n// Create 2 observables \nconst intervalObservable1 = interval(500); \nconst intervalObservable2 = interval(1000); \n\n// Subscribe intervalObservable1 and push subscription1 to subscriptions array \nconst subscription1 = intervalObservable1.subscribe(value => console.log('Subscription 1: ', value)); \nsubscriptions.push(subscription1); \n\n// Subscribe intervalObservable2 and push subscription2 to subscriptions array \nconst subscription2 = intervalObservable2.subscribe(value => console.log('Subscription 2: ', value)); \nsubscriptions.push(subscription2); \n\n// Unsubscribe after 5 seconds \nsetTimeout(() => { \n  for (let i = 0; i < subscriptions.length; i++) { \n    subscriptions[i].unsubscribe(); \n    console.log(`Subscription ${i} unsubscribed.`); \n  } \n}, 5000);",Ae=e(["const { interval } = rxjs;"],h),g="import { interval, Subscription } from 'rxjs'; \n\n// Create a Subscription to manage multiple subscriptions \nconst parentSubscription = new Subscription(); \n\n// Create two child subscriptions \nconst subscription1 = interval(1000).subscribe(value => { \n  console.log(`Subscription 1: ${value}`); \n}); \n\nconst subscription2 = interval(1500).subscribe(value => { \n  console.log(`Subscription 2: ${value}`); \n}); \n\n// Add the child subscriptions to the parent Subscription \nparentSubscription.add(subscription1); \nparentSubscription.add(subscription2); \n\n// Unsubscribe after 5 seconds\nsetTimeout(() => {\n  parentSubscription.unsubscribe();\n  console.log('Subscriptions unsubscribed.');\n}, 5000);",$e=e(["const { interval, Subscription } = rxjs;"],g),y="import { interval } from 'rxjs'; \nimport { take } from 'rxjs/operators'; \n\nconst observable = interval(1000); \n\nconst sub = observable.pipe( \n  take(5) // Automatically unsubscribes after receiving 5 values \n).subscribe(value => console.log(`Received value: ${value}`));",Re=e(["const { interval } = rxjs;","const { take } = rxjs.operators;"],y),Me="const observer = {\n  next: value => console.log('Next:', value),\n  error: error => console.error('Error:', error),\n  complete: () => console.log('Complete')\n};",S="import { Observable } from 'rxjs';\n\nconst observable = new Observable(observer => {\n  observer.next(1);\n  observer.next(2);\n  observer.complete();\n});\n\nconst observer = {\n  next: value => console.log('Next:', value),\n  error: error => console.error('Error:', error),\n  complete: () => console.log('Complete')\n};\n\nobservable.subscribe(observer);",Ve=e(["const { Observable } = rxjs;"],S),O="import { Observable } from 'rxjs';\n\nconst observable = new Observable(observer => {\n  observer.next(1);\n  observer.next(2);\n  observer.complete();\n});\n\nobservable.subscribe(\n  value => console.log('Next:', value),\n  error => console.error('Error:', error),\n  () => console.log('Complete')\n);",Te=e(["const { Observable } = rxjs;"],O),k="import { from } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\nconst source = from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n\nsource.pipe(\n  filter(x => x % 2 === 0) // Filter out even numbers\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",Ie=e(["const { from } = rxjs;","const { filter } = rxjs.operators;"],k),C="import { interval } from 'rxjs';\nimport { take } from 'rxjs/operators';\n\nconst source = interval(1000); // Emits a value every second\n\nsource.pipe(\n  take(5) // Take the first 5 values\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",We=e(["const { interval } = rxjs;","const { take } = rxjs.operators;"],C),w="import { of } from 'rxjs';\nimport { takeWhile } from 'rxjs/operators';\n\nconst source = of(1, 2, 3, 4, 5, 6);\n\nsource.pipe(\n  takeWhile(x => x <= 3) // Take values while x is less than or equal to 3\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",Ue=e(["const { of } = rxjs;","const { takeWhile } = rxjs.operators;"],w),E="import { interval } from 'rxjs';\nimport { skip, take } from 'rxjs/operators';\n\nconst source = interval(1000); // Emits a value every second\n\nsource.pipe(\n  skip(3), // Skip the first 3 values\n  take(5)  // Take the next 5 values\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",De=e(["const { interval } = rxjs;","const { skip, take } = rxjs.operators;"],E),B="import { of } from 'rxjs';\nimport { skipWhile } from 'rxjs/operators';\n\nconst source = of(1, 2, 3, 4, 5, 6);\n\nsource.pipe(\n  skipWhile(x => x <= 3) // Skip values while x is less than or equal to 3\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",Fe=e(["const { of } = rxjs;","const { skipWhile } = rxjs.operators;"],B),A="import { of } from 'rxjs';\nimport { distinctUntilChanged } from 'rxjs/operators';\n\nconst source = of(1, 1, 2, 2, 3, 3, 4, 4, 5);\n\nsource.pipe(\n  distinctUntilChanged() // Filter out consecutive duplicates\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",ze=e(["const { of } = rxjs;","const { distinctUntilChanged } = rxjs.operators;"],A),$="import { from } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nconst source = from([1, 2, 3, 4, 5]);\n\nsource.pipe(\n  map(x => x * 2) // Double each value\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",Je=e(["const { from } = rxjs;","const { map } = rxjs.operators;"],$),R="import { from } from 'rxjs';\nimport { pluck } from 'rxjs/operators';\n\nconst source = from([\n  { name: 'Alice', age: 28 },\n  { name: 'Bob', age: 32 },\n  { name: 'Charlie', age: 24 }\n]);\n\nsource.pipe(\n  pluck('name') // Extract the 'name' property from each object\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",Le=e(["const { from } = rxjs;","const { pluck } = rxjs.operators;"],R),M="import { from } from 'rxjs';\nimport { scan } from 'rxjs/operators';\n\nconst source = from([1, 2, 3, 4, 5]);\n\nsource.pipe(\n  scan((accumulator, currentValue) => accumulator + currentValue, 0) // Calculate the running sum\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",Ne=e(["const { from } = rxjs;","const { scan } = rxjs.operators;"],M),V="import { of } from 'rxjs';\nimport { toArray } from 'rxjs/operators';\n\nconst source = of(1, 2, 3, 4, 5);\n\nsource.pipe(\n  toArray() // Collect values into an array\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",He=e(["const { of } = rxjs;","const { toArray } = rxjs.operators;"],V),T="import { interval, merge } from 'rxjs'; \nimport { map, take } from 'rxjs/operators'; \n\nconst source1 = interval(750).pipe(map(x => `A-${x}`), take(5)); \nconst source2 = interval(500).pipe(map(x => `B-${x}`), take(5)); \n\nconst merged = merge(source1, source2); \n\nmerged.subscribe( \n  value => console.log(value), \n  err => console.error(err), \n  () => console.log('Complete') \n);",Pe=e(["const { interval, merge } = rxjs;","const { map, take } = rxjs.operators;"],T),I="import { concat, interval } from 'rxjs'; \nimport { map, take } from 'rxjs/operators'; \n\nconst source1 = interval(750).pipe(map(x => `A-${x}`), take(5)); \nconst source2 = interval(500).pipe(map(x => `B-${x}`), take(5)); \n\nconst concatenated = concat(source1, source2); \n\nconcatenated.subscribe( \n  value => console.log(value), \n  err => console.error(err), \n  () => console.log('Complete') \n);",Xe=e(["const { concat, interval } = rxjs;","const { map, take } = rxjs.operators;"],I),W="import { combineLatest, interval } from 'rxjs'; \nimport { map, take } from 'rxjs/operators'; \n\nconst source1 = interval(750).pipe(map(x => `A-${x}`), take(5)); \nconst source2 = interval(500).pipe(map(x => `B-${x}`), take(5)); \n\nconst combined = combineLatest(source1, source2); \n\ncombined.subscribe( \n  value => console.log(value), \n  err => console.error(err) \n);",Ye=e(["const { combineLatest, interval } = rxjs;","const { map, take } = rxjs.operators;"],W),U="import { forkJoin, of } from 'rxjs';\nimport { delay } from 'rxjs/operators';\n\nconst source1 = of('A').pipe(delay(2000));\nconst source2 = of('B').pipe(delay(1000));\n\nforkJoin([source1, source2]).subscribe(\n  values => console.log(values),\n  err => console.error(err),\n  () => console.log('Complete')\n);",Ze=e(["const { forkJoin, of } = rxjs;","const { delay } = rxjs.operators;"],U),D="import { of } from 'rxjs';\nimport { startWith } from 'rxjs/operators';\n\nconst source = of(1, 2, 3);\n\nsource.pipe(\n  startWith(0) // Prepend 0 to the values\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",Ke=e(["const { of } = rxjs;","const { startWith } = rxjs.operators;"],D),F="import { of } from 'rxjs'; \nimport { every } from 'rxjs/operators'; \n\nconst source = of(2, 4, 6, 8, 10); \n\nsource.pipe( \n  every(x => x % 2 === 0) // Check if all values are even \n).subscribe( \n  result => console.log(`All values are even: ${result}`), \n  err => console.error(err) \n);",Qe=e(["const { of } = rxjs;","const { every } = rxjs.operators;"],F),z="import { of } from 'rxjs'; \nimport { find } from 'rxjs/operators'; \n\nconst source = of(1, 2, 3, 4, 5); \n\nsource.pipe( \n  find(x => x > 2) // Find the first value greater than 2 \n).subscribe( \n  result => console.log(`First value greater than 2: ${result}`), \n  err => console.error(err) \n);",Ge=e(["const { of } = rxjs;","const { find } = rxjs.operators;"],z),J="import { of } from 'rxjs'; \nimport { findIndex } from 'rxjs/operators'; \n\nconst source = of(10, 20, 30, 40, 50); \n\nsource.pipe( \n  findIndex(x => x > 35) // Find the index of the first value greater than 35 \n).subscribe( \n  result => console.log(`Index of the first value greater than 35: ${result}`), \n  err => console.error(err) \n);",qe=e(["const { of } = rxjs;","const { findIndex } = rxjs.operators;"],J),L="import { of } from 'rxjs'; \nimport { isEmpty } from 'rxjs/operators'; \n\nconst source1 = of(); \nconst source2 = of(1, 2, 3); \n\nsource1.pipe( \n  isEmpty() // Check if the Observable is empty \n).subscribe( \n  result => console.log(`Is source1 empty? ${result}`), \n  err => console.error(err) \n); \n\nsource2.pipe( \n  isEmpty() // Check if the Observable is empty \n).subscribe( \n  result => console.log(`Is source2 empty? ${result}`), \n  err => console.error(err) \n);",er=e(["const { of } = rxjs;","const { isEmpty } = rxjs.operators;"],L),N="import { of } from 'rxjs'; \nimport { tap } from 'rxjs/operators'; \n\nconst source = of(1, 2, 3); \n\nsource.pipe( \n  tap(value => console.log(`Logging value: ${value}`)) \n).subscribe( \n  value => console.log(value), \n  err => console.error(err), \n  () => console.log('Complete') \n);",rr=e(["const { of } = rxjs;","const { tap } = rxjs.operators;"],N),H="import { of } from 'rxjs';\nimport { delay } from 'rxjs/operators';\n\nconst source = of(1, 2, 3);\n\nsource.pipe(\n  delay(2000) // Delay by 2 seconds\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",sr=e(["const { of } = rxjs;","const { delay } = rxjs.operators;"],H),P="import { of } from 'rxjs';\nimport { finalize } from 'rxjs/operators';\n\nconst source = of(1, 2, 3);\n\nsource.pipe(\n  finalize(() => console.log('Observation complete'))\n).subscribe(\n  value => console.log(value),\n  err => console.error(err)\n);",or=e(["const { of } = rxjs;","const { finalize } = rxjs.operators;"],P),X="import { interval } from 'rxjs';\nimport { take, timeout } from 'rxjs/operators';\n\nconst source = interval(1000).pipe(take(10));\n\nsource.pipe(\n  timeout(2000) // Timeout after 2 seconds\n).subscribe(\n  value => console.log(value),\n  err => console.error(err)\n);",tr=e(["const { interval } = rxjs;","const { take, timeout } = rxjs.operators;"],X),Y="import { of, throwError } from 'rxjs'; \nimport { catchError } from 'rxjs/operators'; \n\nconst source = throwError('An error occurred'); \n\nsource.pipe( \n  catchError(error => of(`Error handled: ${error}`)) \n).subscribe( \n  value => console.log(value), \n  err => console.error(`Caught error: ${err}`) \n);",nr=e(["const { of, throwError } = rxjs;","const { catchError } = rxjs.operators;"],Y),Z="import { of } from 'rxjs'; \nimport { retry, tap } from 'rxjs/operators'; \n\nconst source = of('A', 'B', 'C'); \n\nsource.pipe( \n  tap(value => { \n    if (value === 'C') \n      throw new Error('An error occurred'); \n  }), \n  retry(2) // Retry up to 2 times \n).subscribe( \n  value => console.log(value), \n  err => console.error(err) \n);",cr=e(["const { of } = rxjs;","const { tap, retry } = rxjs.operators;"],Z),K="import { of, throwError, timer } from 'rxjs'; \nimport { mergeMap, retryWhen, take } from 'rxjs/operators'; \n\nlet retryCount = 0; \n\nconst source = of('A', 'B', 'C'); \n\nsource.pipe( \n  tap(value => { \n    if (value === 'C') \n      throw new Error('An error occurred'); \n  }), \n  retryWhen(errors => \n    errors.pipe( \n      mergeMap((error, index) => { \n        if (index < 2) { \n          retryCount++; \n          console.error(`Error encountered (${retryCount} retries): ${error}`); \n          return timer(2000); // Retry after a delay \n        } else { \n          return throwError(error); // Stop retrying after 2 retries \n        } \n      }) \n    ) \n  ) \n).subscribe( \n  value => console.log(value), \n  err => console.error(`Final error: ${err}`) \n);",ar=e(["const { of, throwError, timer } = rxjs;","const { mergeMap, retryWhen, take, tap } = rxjs.operators;"],K),Q="import { of } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\n\nconst source = of(1, 2, 3, 4, 5);\n\nsource.pipe(\n  filter(x => x % 2 === 0), // Only even numbers\n  map(x => x * 2)           // Double the values\n).subscribe(result => console.log(result));",lr=e(["const { of } = rxjs;","const { map, filter } = rxjs.operators;"],Q),_r="import { of } from 'rxjs';\n\nconst source = of(1, 2, 3, 4, 5);\n\nsource\n  .filter(x => x % 2 === 0) // Only even numbers\n  .map(x => x * 2)          // Double the values\n  .subscribe(result => console.log(result));",G="import { interval, of } from 'rxjs'; \nimport { concatMap, map, take } from 'rxjs/operators'; \n\nconst source = of(1, 2, 3); \n\nsource.pipe( \n  concatMap(value => \n    interval(1000).pipe( \n      take(3), \n      map(innerValue => `Source: ${value}, Inner: ${innerValue}`) \n    ) \n  ) \n).subscribe(result => console.log(result));",ur=e(["const { of, interval } = rxjs;","const { concatMap, map, take } = rxjs.operators;"],G),q="import { of } from 'rxjs'; \nimport { delay, mergeMap } from 'rxjs/operators'; \n\nconst source = of(1, 2, 3); \n\nsource.pipe( \n  mergeMap(value => \n    of(`Processed: ${value}`).pipe( \n      delay(1000 / value) // Simulate some async processing. The value takes on 1, 2, and 3 respectively \n    ) \n  ) \n).subscribe(result => console.log(result));",ir=e(["const { of } = rxjs;","const { delay, mergeMap } = rxjs.operators;"],q),ee="import { interval, of } from 'rxjs'; \nimport { map, switchMap, take } from 'rxjs/operators'; \n\nconst source = of(1, 2, 3); \n\nsource.pipe( \n  switchMap(value => \n    interval(1000).pipe( \n      take(3), \n      map(innerValue => `Source: ${value}, Inner: ${innerValue}`) \n    ) \n  ) \n).subscribe(result => console.log(result));",br=e(["const { interval, of  } = rxjs;","const { map, switchMap, take } = rxjs.operators;"],ee),re="import { interval, of } from 'rxjs'; \nimport { exhaustMap, take } from 'rxjs/operators'; \n\n// Source observable emits values 1, 2, 3 \nconst source = of(1, 2, 3); \n\nsource.pipe( \n  exhaustMap(value => { \n    // Inner observable emits values based on source value \n    return interval(1000).pipe( \n      take(3), // Limit inner observable to emit 3 values \n      map(innerValue => `${value}-${innerValue}`) \n    ); \n  }) \n) \n.subscribe(result => { \n  console.log(result); \n});",pr=e(["const { interval, of  } = rxjs;","const { map, exhaustMap, take } = rxjs.operators;"],re),se="import { fromEvent } from 'rxjs'; \nimport { debounceTime, map } from 'rxjs/operators'; \n\n// Create an observable from input events (e.g., user typing) \nconst input = document.getElementById('search-input'); \nconst inputs = fromEvent(input, 'input'); \n\ninputs.pipe( \n  debounceTime(300), // Wait for 300 milliseconds of inactivity \n  map(event => event.target.value) \n).subscribe(value => console.log('Input Value:', value));",xr=e(["const { fromEvent  } = rxjs;","const { debounceTime, map } = rxjs.operators;"],se,'<label>Key in rapidly! </label><input id="search-input">'),oe="import { fromEvent } from 'rxjs'; \nimport { map, throttleTime } from 'rxjs/operators'; \n\n// Create an observable from mousemove events \nconst mousemove = fromEvent(document, 'mousemove'); \n\nmousemove.pipe( \n  throttleTime(1000), // Allow one event per 1000 milliseconds \n  map(event => `Mouse Position: (${event.clientX}, ${event.clientY})`) \n).subscribe(position => console.log(position));",jr=e(["const { fromEvent  } = rxjs;","const { map, throttleTime } = rxjs.operators;"],oe,"<p>Move mouse in this area!</p>"),te="import { fromEvent, interval } from 'rxjs'; \nimport { buffer, take } from 'rxjs/operators'; \n\n// Create a source observable that emits values every 500ms \nconst source = interval(500).pipe(take(20)); \n\n// Create a signal observable that emits values every 2000ms (2 seconds) \nconst signal = interval(2000).pipe(take(5)); \n\n// Use buffer to collect values from the source based on the signal \nconst bufferedSource = source.pipe(buffer(signal)); \n\n// Subscribe to the buffered source \nbufferedSource.subscribe(buffer => { \n  console.log('Buffered Values:', buffer); \n});",mr=e(["const { fromEvent, interval } = rxjs;","const { buffer, take } = rxjs.operators;"],te),ne="import { interval } from 'rxjs'; \nimport { mergeAll, take, window as win } from 'rxjs/operators'; \n\n// Create a source observable that emits values every 500ms \nconst source = interval(500); \n\n// Create a boundary observable that emits values every 2000ms (2 seconds) \nconst boundary = interval(2000); \n\n// Use window to create windows based on the boundary \nconst windowedSource = source.pipe(win(boundary)); \n\n// Merge all windows into a single observable \nconst mergedWindows = windowedSource.pipe(mergeAll()); \n\n// Take the first 3 values from each window \nconst result = mergedWindows.pipe(take(9)); \n\n// Subscribe to the result \nresult.subscribe(value => { \n  console.log('Value:', value); \n});",vr=e(["const { interval } = rxjs;","const { mergeAll, take, window: win } = rxjs.operators;"],ne),ce="import { of, pipe } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\n\n// The customOperator function is defined, taking a predicate as an argument\nconst customOperator = (predicate) => pipe(\n  filter(predicate),\n  map(value => value * 2)\n);\n\n// An observable named source is defined\nconst source = of(2, 4, 6, 8, 10);\n\n// The customOperator is applied to the source observable with a predicate function\nsource.pipe(\n  customOperator(x => x > 5)\n).subscribe(result => {\n  console.log(result);// Output: 12, 16, 20\n});",fr=e(["const { of, pipe } = rxjs;","const { filter, map } = rxjs.operators;"],ce),ae="import { Observable } from 'rxjs';\n\n// Define the custom operator function\nfunction multiplyBy(factor) {\n  // Return a function that takes the source observable as an argument\n  return (source) => {\n    // Create and return a new observable\n    return new Observable((observer) => {\n      // Subscribe to the source observable\n      const subscription = source.subscribe({\n        next(value) {\n          // Multiply the value by the specified factor\n          const result = value * factor;\n          // Emit the transformed value\n          observer.next(result);\n        },\n        error(error) {\n          // Pass along any errors\n          observer.error(error);\n        },\n        complete() {\n          // Complete the observer when the source completes\n          observer.complete();\n        },\n      });\n\n      // Return a cleanup function to unsubscribe from the source\n      return () => {\n        subscription.unsubscribe();\n      };\n    });\n  };\n}\n\n// Create an example observable\nconst source = new Observable((observer) => {\n  observer.next(1);\n  observer.next(2);\n  observer.next(3);\n  observer.complete();\n});\n\n// Use the custom operator\nsource.pipe(\n  multiplyBy(10) // Multiply each value by 10\n).subscribe((result) => {\n  console.log(result); // Output: 10, 20, 30\n});",dr=e(["const { Observable } = rxjs;"],ae),le="import { Subject } from 'rxjs'; \n\n// Create a new Subject \nconst subject = new Subject(); \n\n// Subscribe multiple observers to the Subject \nsubject.subscribe({ \n  next: value => console.log(`Observer A: ${value}`) \n}); \n\nsubject.subscribe({ \n  next: value => console.log(`Observer B: ${value}`) \n}); \n\n// Emit values from the Subject \nsubject.next(1); // Emits to both Observer A and Observer B \nsubject.next(2); // Emits to both Observer A and Observer B",hr=e(["const { Subject } = rxjs;"],le),_e="import { BehaviorSubject } from 'rxjs';\n\n// Create a BehaviorSubject with an initial value\nconst behaviorSubject = new BehaviorSubject('Initial value');\n\n// Subscribe to the BehaviorSubject\nbehaviorSubject.subscribe(value => console.log('Observer 1:', value)); // Outputs: Observer 1: Initial value\n\n// Emit a new value\nbehaviorSubject.next('New value'); // Outputs: Observer 1: New value\n\n// Subscribe to the BehaviorSubject after a value has been emitted\nbehaviorSubject.subscribe(value => console.log('Observer 2:', value)); // Outputs: Observer 2: New value",gr=e(["const { BehaviorSubject } = rxjs;"],_e),ue="import { ReplaySubject } from 'rxjs';\n\n// Create a ReplaySubject that replays the last 2 values\nconst replaySubject = new ReplaySubject(2);\n\n// Emit values to the ReplaySubject\nreplaySubject.next('Value 1');\nreplaySubject.next('Value 2');\nreplaySubject.next('Value 3');\n\n// Subscribe to the ReplaySubject\nreplaySubject.subscribe(value => console.log('Observer 1:', value)); // Outputs: Observer 1: Value 2, Observer 1: Value 3\n\n// Emit another value\nreplaySubject.next('Value 4');\n\n// Subscribe to the ReplaySubject after values have been emitted\nreplaySubject.subscribe(value => console.log('Observer 2:', value)); // Outputs: Observer 2: Value 3, Observer 2: Value 4",yr=e(["const { ReplaySubject } = rxjs;"],ue),ie="import { AsyncSubject } from 'rxjs';\n\n// Create an AsyncSubject\nconst asyncSubject = new AsyncSubject();\n\n// Subscribe to the AsyncSubject\nasyncSubject.subscribe(value => console.log('Observer 1:', value));\n\n// Emit values to the AsyncSubject\nasyncSubject.next('Value 1');\nasyncSubject.next('Value 2');\n\n// Complete the AsyncSubject\nasyncSubject.complete();\n\n// Subscribe to the AsyncSubject after completion\nasyncSubject.subscribe(value => console.log('Observer 2:', value)); // Outputs: Observer 2: Value 2",Sr=e(["const { AsyncSubject } = rxjs;"],ie),Or="import { of } from 'rxjs';\n\nconst coldObservable = of(1, 2, 3);\n\n// Subscribers get independent streams\ncoldObservable.subscribe(value => console.log('Subscriber A:', value));\ncoldObservable.subscribe(value => console.log('Subscriber B:', value));",kr="import { Subject } from 'rxjs';\n\nconst hotObservable = new Subject();\n\nhotObservable.subscribe(value => console.log('Subscriber A:', value));\nhotObservable.subscribe(value => console.log('Subscriber B:', value));\n\nhotObservable.next(1); // Both subscribers receive the same value";var Cr=t(7809);let c=(()=>{class r{constructor(){this.bookData=l}}return r.\u0275fac=function(s){return new(s||r)},r.\u0275cmp=n.Xpm({type:r,selectors:[["app-rxjs-chapter"]],decls:1,vars:1,consts:[[3,"bookData"]],template:function(s,a){1&s&&n._UZ(0,"app-chapter",0),2&s&&n.Q6J("bookData",a.bookData)},dependencies:[Cr.l]}),r})();const wr=[{path:"",component:xe,children:[{path:"chapter",component:c},{path:"chapter/:chid",component:c},{path:"chapter/:chid/section/:secid",component:c},{path:"**",component:c},{path:"",component:c}]}];let Er=(()=>{class r{}return r.\u0275fac=function(s){return new(s||r)},r.\u0275mod=n.oAB({type:r}),r.\u0275inj=n.cJS({imports:[_.Bz.forChild(wr),_.Bz]}),r})();var Br=t(1375);let Ar=(()=>{class r{}return r.\u0275fac=function(s){return new(s||r)},r.\u0275mod=n.oAB({type:r}),r.\u0275inj=n.cJS({imports:[be.ez,Er,Br.I]}),r})()}}]);