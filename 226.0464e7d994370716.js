"use strict";(self.webpackChunkweb_building=self.webpackChunkweb_building||[]).push([[226],{9226:(co,u,a)=>{a.r(u),a.d(u,{RxjsBookModule:()=>no});var l={};a.r(l),a.d(l,{rxjs_1_1_1:()=>he,rxjs_1_1_2:()=>ge,rxjs_1_1_3:()=>ve,rxjs_1_1_4:()=>fe,rxjs_1_1_5:()=>_e,rxjs_1_1_6:()=>ye,rxjs_2_2_1:()=>d,rxjs_2_2_1_1:()=>je,rxjs_2_2_2:()=>p,rxjs_2_2_2_1:()=>we,rxjs_2_2_3:()=>m,rxjs_2_2_3_1:()=>Se,rxjs_2_2_4:()=>b,rxjs_2_2_4_1:()=>Oe,rxjs_2_2_5:()=>x,rxjs_2_2_5_1:()=>Te,rxjs_2_2_6:()=>h,rxjs_2_2_6_1:()=>Re,rxjs_2_2_7:()=>g,rxjs_2_2_7_1:()=>Le,rxjs_2_3_1:()=>ke,rxjs_2_3_2:()=>Ce,rxjs_2_3_3:()=>Je,rxjs_2_3_4:()=>Ee,rxjs_2_3_5:()=>v,rxjs_2_3_5_1:()=>Ie,rxjs_2_4_1:()=>f,rxjs_2_4_1_1:()=>Ae,rxjs_2_4_2:()=>_,rxjs_2_4_2_1:()=>Me,rxjs_2_4_3:()=>y,rxjs_2_4_3_1:()=>Be,rxjs_2_4_4:()=>j,rxjs_2_4_4_1:()=>He,rxjs_2_5_1:()=>We,rxjs_2_5_2:()=>w,rxjs_2_5_2_1:()=>Ue,rxjs_2_5_3:()=>S,rxjs_2_5_3_1:()=>qe,rxjs_3_2_1:()=>O,rxjs_3_2_1_1:()=>Pe,rxjs_3_2_2:()=>T,rxjs_3_2_2_1:()=>Ve,rxjs_3_2_3:()=>R,rxjs_3_2_3_1:()=>$e,rxjs_3_2_4:()=>L,rxjs_3_2_4_1:()=>De,rxjs_3_2_5:()=>k,rxjs_3_2_5_1:()=>ze,rxjs_3_2_6:()=>C,rxjs_3_2_6_1:()=>Fe,rxjs_3_3_1:()=>J,rxjs_3_3_1_1:()=>Ye,rxjs_3_3_2:()=>E,rxjs_3_3_2_1:()=>Ne,rxjs_3_3_3:()=>I,rxjs_3_3_3_1:()=>Ke,rxjs_3_3_4:()=>A,rxjs_3_3_4_1:()=>Xe,rxjs_3_4_1:()=>M,rxjs_3_4_1_1:()=>Qe,rxjs_3_4_2:()=>B,rxjs_3_4_2_1:()=>Ze,rxjs_3_4_3:()=>H,rxjs_3_4_3_1:()=>Ge,rxjs_3_4_4:()=>W,rxjs_3_4_4_1:()=>et,rxjs_3_4_5:()=>U,rxjs_3_4_5_1:()=>tt,rxjs_3_5_1:()=>q,rxjs_3_5_1_1:()=>ot,rxjs_3_5_2:()=>P,rxjs_3_5_2_1:()=>rt,rxjs_3_5_3:()=>V,rxjs_3_5_3_1:()=>at,rxjs_3_5_4:()=>$,rxjs_3_5_4_1:()=>st,rxjs_3_6_1:()=>D,rxjs_3_6_1_1:()=>it,rxjs_3_6_2:()=>z,rxjs_3_6_2_1:()=>nt,rxjs_3_6_3:()=>F,rxjs_3_6_3_1:()=>lt,rxjs_3_6_4:()=>Y,rxjs_3_6_4_1:()=>ct,rxjs_3_7_1:()=>N,rxjs_3_7_1_1:()=>ut,rxjs_3_7_2:()=>K,rxjs_3_7_2_1:()=>dt,rxjs_3_7_3:()=>X,rxjs_3_7_3_1:()=>pt,rxjs_3_8_1:()=>Q,rxjs_3_8_1_1:()=>mt,rxjs_3_8_2:()=>bt,rxjs_4_1_1:()=>Z,rxjs_4_1_1_1:()=>xt,rxjs_4_2_1:()=>G,rxjs_4_2_1_1:()=>ht,rxjs_4_3_1:()=>ee,rxjs_4_3_1_1:()=>gt,rxjs_4_4_1:()=>te,rxjs_4_4_1_1:()=>vt,rxjs_4_5_1:()=>oe,rxjs_4_5_1_1:()=>ft,rxjs_4_6_1:()=>re,rxjs_4_6_1_1:()=>_t,rxjs_4_7_1:()=>ae,rxjs_4_7_1_1:()=>yt,rxjs_4_8_1:()=>se,rxjs_4_8_1_1:()=>jt,rxjs_4_9_1:()=>ie,rxjs_4_9_1_1:()=>wt,rxjs_4_9_2:()=>ne,rxjs_4_9_2_1:()=>St,rxjs_5_2_1:()=>Ot,rxjs_5_2_2:()=>Tt,rxjs_5_2_3:()=>Rt,rxjs_5_2_4:()=>Lt,rxjs_5_2_5:()=>kt,rxjs_5_2_6:()=>Ct,rxjs_5_2_7:()=>le,rxjs_5_2_7_1:()=>Jt,rxjs_5_3_1:()=>Et,rxjs_5_3_2:()=>It,rxjs_5_3_3:()=>At,rxjs_5_3_4:()=>Mt,rxjs_5_3_5:()=>Bt,rxjs_5_3_6:()=>Ht,rxjs_5_3_7:()=>Wt,rxjs_5_3_8:()=>ce,rxjs_5_3_8_1:()=>Ut,rxjs_5_4_1:()=>qt,rxjs_5_4_2:()=>Pt,rxjs_5_4_3:()=>Vt,rxjs_5_4_4:()=>$t,rxjs_5_4_5:()=>Dt,rxjs_5_4_6:()=>zt,rxjs_5_4_7:()=>Ft,rxjs_5_4_8:()=>ue,rxjs_5_4_8_1:()=>Yt,rxjs_5_5_1:()=>Nt,rxjs_5_5_2:()=>Kt,rxjs_5_5_3:()=>Xt,rxjs_5_5_4:()=>Qt,rxjs_5_5_5:()=>Zt,rxjs_5_5_6:()=>Gt,rxjs_5_5_7:()=>de,rxjs_5_5_7_1:()=>eo,rxjs_6_1_1:()=>to,rxjs_6_1_2:()=>oo});var pe=a(6895),c=a(9299);const me=[{category:"rxjs",chid:1,title:"Introduction to Reactive Programming and RxJS",sections:[{secid:1,subtitle:"What is Reactive Programming?",paragraphs:[{paraid:1,text:"Reactive Programming is a programming paradigm that focuses on handling asynchronous data streams and propagating changes in a reactive and declarative manner. It provides a way to structure your code around the flow of data and how it changes over time, rather than relying heavily on imperative control flow."},{paraid:2,text:"Key characteristics of Reactive Programming include:"},{paraid:3,text:"<ol><li><strong>Asynchronous Data Streams</strong></li></ol>"},{paraid:1,text:"<ul>Reactive programming deals with sequences of events or data over time. These sequences are represented as data streams, which can emit values asynchronously.</ul>"},{paraid:4,text:'<ol start="2"><li><strong>Data Flow</strong></li></ol>'},{paraid:1,text:"<ul>Instead of explicitly managing the order of operations and handling callbacks, reactive programming allows you to describe how data flows through a series of transformations. This makes the code more concise, readable, and easier to reason about.</ul>"},{paraid:5,text:'<ol start="3"><li><strong>Declarative Approach</strong></li></ol>'},{paraid:1,text:"<ul>Reactive programming encourages a declarative style of coding, where you specify what you want to achieve rather than the step-by-step instructions on how to achieve it. This reduces the complexity of managing state changes and leads to more maintainable code.</ul>"},{paraid:6,text:'<ol start="4"><li><strong>Reactive Extensions (Rx)</strong></li></ol>'},{paraid:1,text:"<ul>Reactive Programming often involves using libraries like RxJS (for JavaScript), RxJava (for Java), or Rx.NET (for .NET languages). These libraries provide a set of tools and operators to work with asynchronous data streams, making it easier to compose, transform, filter, and merge streams.</ul>"},{paraid:7,text:'<ol start="5"><li><strong>Event-driven and Event-Driven Architectures</strong></li></ol>'},{paraid:1,text:"<ul>Reactive programming is particularly suitable for event-driven architectures, where the system responds to events such as user interactions, network requests, sensor inputs, and more. It allows you to react to changes and events in a consistent manner.</ul>"},{paraid:8,text:'<ol start="6"><li><strong>Back Pressure Handling</strong></li></ol>'},{paraid:1,text:"<ul>Reactive programming also deals with back pressure, which is the concept of handling situations when the source of events emits data faster than the consumer can process. Reactive systems provide mechanisms to handle back pressure and prevent resource exhaustion.</ul>"},{paraid:9,text:"Overall, Reactive Programming provides a powerful way to handle complex asynchronous scenarios, such as user interfaces, real-time data processing, and network communications, by providing a clear and elegant way to manage data flows and changes over time."}]},{secid:2,subtitle:"Benefits of Reactive Programming",paragraphs:[{paraid:1,text:"Reactive Programming offers several benefits that make it a compelling approach for handling asynchronous and event-driven scenarios. Here are some of the key advantages:"},{paraid:2,text:"<ol><li><strong>Responsive User Interfaces</strong></li></ol>"},{paraid:1,text:"<ul>Reactive Programming is well-suited for building responsive and interactive user interfaces. It allows you to handle user interactions, events, and updates in a way that maintains a smooth and fluid user experience.</ul>"},{paraid:3,text:'<ol start="2"><li><strong>Concise and Readable Code</strong></li></ol>'},{paraid:1,text:"<ul>Reactive code tends to be more concise and readable compared to traditional imperative code with nested callbacks. The declarative nature of reactive programming allows you to describe data transformations and flows in a more intuitive manner.</ul>"},{paraid:4,text:'<ol start="3"><li><strong>Data Flow Clarity</strong></li></ol>'},{paraid:1,text:"<ul>Reactive systems emphasize the flow of data and how it changes over time. This leads to a clearer understanding of the sequence of operations and how they relate to each other.</ul>"},{paraid:5,text:'<ol start="4"><li><strong>Reusability and Composition</strong></li></ol>'},{paraid:1,text:"<ul>Reactive code encourages the creation of small, composable functions and operators. These can be reused across different parts of your application, leading to more modular and maintainable code.</ul>"},{paraid:6,text:'<ol start="5"><li><strong>Asynchronous Handling Simplification</strong></li></ol>'},{paraid:1,text:"<ul>Dealing with asynchronous operations, such as handling multiple API requests or managing event listeners, becomes simpler and less error-prone with reactive programming constructs.</ul>"},{paraid:7,text:'<ol start="6"><li><strong>Error Handling and Resilience</strong></li></ol>'},{paraid:1,text:"<ul>Reactive systems often come with built-in error handling mechanisms. Error propagation and handling can be managed more uniformly throughout the codebase.</ul>"},{paraid:8,text:'<ol start="7"><li><strong>Scalability and Performance</strong></li></ol>'},{paraid:1,text:"<ul>Reactive architectures are well-suited for building scalable systems, as they allow you to handle asynchronous and concurrent tasks efficiently. Reactive systems can also handle back pressure, preventing resource overload.</ul>"},{paraid:9,text:'<ol start="8"><li><strong>Event-Driven Architecture</strong></li></ol>'},{paraid:1,text:"<ul>Reactive programming aligns well with event-driven architectures, where systems respond to various events and signals. This makes it easier to design and implement systems that react to changes in real-time.</ul>"},{paraid:10,text:'<ol start="9"><li><strong>Hot and Cold Observables</strong></li></ol>'},{paraid:1,text:"<ul>Reactive systems provide options for managing data streams as hot or cold observables. This allows you to control when data starts emitting and how subscribers interact with that data.</ul>"},{paraid:11,text:'<ol start="10"><li><strong>Debugging and Testing</strong></li></ol>'},{paraid:1,text:"<ul>Reactive systems often come with debugging tools and utilities that help visualize the flow of data and events. This can aid in diagnosing issues and testing different scenarios.</ul>"},{paraid:12,text:'<ol start="11"><li><strong>Concurrent Processing</strong></li></ol>'},{paraid:1,text:"<ul>Reactive programming lends itself to concurrent processing. You can easily run multiple data streams in concurrency and merge them as needed, which is beneficial for tasks like data processing and real-time analytics.</ul>"},{paraid:13,text:'<ol start="12"><li><strong>Flexibility and Adaptability</strong></li></ol>'},{paraid:1,text:"<ul>Reactive systems can adapt to changes in the environment more easily. New data sources, events, or transformations can be integrated without major changes to the existing codebase.</ul>"},{paraid:14,text:"In summary, Reactive Programming offers a way to handle complex asynchronous scenarios with elegance and efficiency. Its focus on data flow, composability, and declarative style contributes to code that is more maintainable, scalable, and responsive."}]},{secid:3,subtitle:"Introduction to RxJS",paragraphs:[{paraid:1,text:"RxJS (Reactive Extensions for JavaScript) is a popular library that brings the principles of Reactive Programming to JavaScript applications. It allows you to work with asynchronous data streams and events using a wide range of powerful operators and concepts. RxJS is often used in web development, front-end frameworks like Angular, and various other JavaScript-based projects to handle complex asynchronous scenarios in a more elegant and manageable way."},{paraid:2,text:"Here's a brief introduction to RxJS:"},{paraid:3,text:"<ol><li><strong>Observables</strong></li></ul>"},{paraid:1,text:"<ul>At the core of RxJS are observables, which represent streams of data that can emit values over time. Observables can emit multiple values, including synchronous or asynchronous, and can also emit errors or signal that they've completed. Observables are the foundation of RxJS and are used to model various asynchronous data sources.</ul>"},{paraid:4,text:'<ol start="2"><li><strong>Operators</strong></li></ul>'},{paraid:1,text:"<ul>RxJS provides a rich set of operators that allow you to transform, filter, combine, and manipulate observables. These operators enable you to perform tasks like mapping values, filtering out unwanted data, merging multiple observables, and more. Operators are a key part of composing and processing asynchronous data streams.</ul>"},{paraid:5,text:'<ol start="3"><li><strong>Subscriptions</strong></li></ul>'},{paraid:1,text:"<ul>To interact with observables and start receiving data, you need to subscribe to them. A subscription establishes a connection between an observable and an observer (which is essentially a set of callback functions). Subscriptions can be managed and used to control the lifecycle of an observable's data emission.</ul>"},{paraid:6,text:'<ol start="4"><li><strong>Subjects</strong></li></ul>'},{paraid:1,text:"<ul>Subjects are a special type of observable that allows both emitting and subscribing to values. They act as bridges that connect the imperative world (e.g., user interactions) with the reactive world of observables. Subjects are often used for implementing event emitters and managing state.</ul>"},{paraid:7,text:'<ol start="5"><li><strong>Hot and Cold Observables</strong></li></ul>'},{paraid:1,text:"<ul>RxJS observables can be categorized as hot or cold. Cold observables start emitting data when a subscription is made, while hot observables emit data regardless of whether there are subscribers. Understanding this distinction is important when dealing with shared data sources.</ul>"},{paraid:8,text:'<ol start="6"><li><strong>Error Handling</strong></li></ul>'},{paraid:1,text:"<ul>RxJS provides mechanisms for handling errors that can occur while processing data streams. You can use operators like `<code>catchError</code>` to gracefully handle errors and continue processing the stream.</ul>"},{paraid:9,text:'<ol start="7"><li><strong>Back Pressure</strong></li></ul>'},{paraid:1,text:"<ul>RxJS supports back pressure handling, which means it can manage situations where a data source emits data faster than the consumer can process it. This prevents resource exhaustion and helps maintain a balanced flow of data.</ul>"},{paraid:10,text:'<ol start="8"><li><strong>Integrations with Frameworks</strong></li></ul>'},{paraid:1,text:"<ul>RxJS is commonly used with frameworks like Angular to manage asynchronous operations in components, services, and other parts of the application. Angular's HttpClient, for instance, returns observables for handling HTTP requests.</ul>"},{paraid:11,text:"Overall, RxJS provides a structured and elegant way to handle asynchronous programming in JavaScript. Its concepts and operators help developers manage complex data flows, handle events, and build responsive applications with less boilerplate code and improved maintainability."}]},{secid:4,subtitle:"Setting Up Your Development Environment",paragraphs:[{paraid:1,text:"Setting up your development environment for RxJS involves a few steps to ensure you have the necessary tools and dependencies in place. Here's a general guide to help you get started."},{paraid:2,text:"<ol><li><strong>Node.js and npm</strong></li></ol>"},{paraid:3,text:"<ul>RxJS is typically used in JavaScript applications, so you'll need Node.js and npm (Node Package Manager) installed on your system.</ul>"},{paraid:4,text:'<ul><ul><li>Download and install Node.js: Visit the official Node.js website <a href="https://nodejs.org/" target="_blank">(https://nodejs.org/)</a> and download the latest LTS (Long Term Support) version for your operating system. Follow the installation instructions.</li></ul></ul>'},{paraid:5,text:"<ul><ul><li>Verify installation: Open a terminal or command prompt and run the following commands to ensure Node.js and npm are installed and accessible:</li></ul></ul>"},{paraid:6,text:"",codeConfig:{codeid:"rxjs_1_1_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"BASH",exampleTitle:"",codeLangs:"bash",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"5rem"}},{paraid:7,text:'<ol start="2"><li><strong>Text Editor or IDE</strong></li></ol>'},{paraid:8,text:"<ul>Choose a text editor or integrated development environment (IDE) for writing your RxJS code. Some popular choices include Visual Studio Code, WebStorm, Sublime Text, and Atom.</ul>"},{paraid:9,text:"<ul><ul><li>Download and install your preferred text editor or IDE from their respective websites.</li></ul></ul>"},{paraid:10,text:'<ol start="3"><li><strong>RxJS Installation</strong></li></ol>'},{paraid:11,text:"<ul>Once you have Node.js and npm installed, you can start a new project and install RxJS as a dependency.</ul>"},{paraid:12,text:"<ul><ul><li>Create a new project folder: Open your terminal or command prompt and navigate to the directory where you want to create your project.</li></ul></ul>"},{paraid:13,text:"",codeConfig:{codeid:"rxjs_1_1_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"BASH",exampleTitle:"",codeLangs:"bash",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"5rem"}},{paraid:14,text:"<ul><ul><li>Initialize a new npm project: Run the following command and follow the prompts to set up your project. You can press Enter for most of the prompts to accept the default values.</li></ul></ul>"},{paraid:15,text:"",codeConfig:{codeid:"rxjs_1_1_3",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"BASH",exampleTitle:"",codeLangs:"bash",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"5rem"}},{paraid:16,text:"<ul><ul><li>Install RxJS: Use npm to install RxJS as a project dependency.</li></ul></ul>"},{paraid:17,text:"",codeConfig:{codeid:"rxjs_1_1_4",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"BASH",exampleTitle:"",codeLangs:"bash",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"5rem"}},{paraid:18,text:'<ol start="4"><li><strong>Writing RxJS Code</strong></li></ol>'},{paraid:19,text:"<ul>You can now start writing RxJS code in your project. Create JavaScript files (e.g., `<code>main.js</code>`) in your project folder and use your preferred text editor or IDE to write your RxJS code.</ul>"},{paraid:20,text:"<ul><ul><li>Here's a simple example of importing and using RxJS in your `<code>main.js</code>` file:</li></ul></ul>"},{paraid:21,text:"",codeConfig:{codeid:"rxjs_1_1_5",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"5rem"}},{paraid:22,text:'<ol start="5"><li><strong>Running Your Code</strong></li></ol>'},{paraid:23,text:"<ul>After writing your RxJS code, you can run it using Node.js.</ul>"},{paraid:24,text:"<ul><ul><li>In your terminal, navigate to your project folder containing the `<code>main.js</code>` file.</li></ul></ul>"},{paraid:25,text:"<ul><ul><li>Run the script using Node.js:</li></ul></ul>"},{paraid:26,text:"",codeConfig:{codeid:"rxjs_1_1_6",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"BASH",exampleTitle:"",codeLangs:"bash",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"5rem"}},{paraid:27,text:"<ul><ul>You should see the output of the subscribed values from the example above.</ul></ul>"},{paraid:28,text:"That's it! You've set up your development environment for RxJS and written a basic RxJS code snippet. From here, you can explore more RxJS concepts, experiment with observables and operators, and build more complex applications."}]}]},{category:"rxjs",chid:2,title:"Observables and Observers",sections:[{secid:1,subtitle:"Understanding Observables",paragraphs:[{paraid:1,text:"Observables are a fundamental concept in RxJS and reactive programming. They represent a way to work with asynchronous data streams and events in a structured and powerful manner. Let's dive deeper into understanding observables."},{paraid:2,text:"<ol><li><strong>Definition and Characteristics</strong></li></ol>"},{paraid:3,text:"<ul>An observable is an object that represents a stream of data that can be observed over time. It can emit values, errors, and a completion signal. Observables are used to model events, data from APIs, user interactions, and more:</ul>"},{paraid:4,text:"<ul><ul><li><strong>Emission of Values</strong></li></ul></ul>"},{paraid:4,text:"<ul><ul>Observables emit values over time. These values can be of any type, such as numbers, strings, objects, or custom data structures.</ul></ul>"},{paraid:5,text:"<ul><ul><li><strong>Completion</strong></li></ul></ul>"},{paraid:5,text:"<ul><ul>An observable can complete, indicating that it will no longer emit any more values. This can be useful to signal that a task has finished.</ul></ul>"},{paraid:6,text:"<ul><ul><li><strong>Error Handling</strong></li></ul></ul>"},{paraid:6,text:"<ul><ul>Observables can emit errors when something goes wrong in the data stream. This allows you to handle errors gracefully.</ul></ul>"},{paraid:7,text:'<ol start="2"><li><strong>Creating Observables</strong></li></ol>'},{paraid:8,text:"<ul>RxJS provides several ways to create observables:</ul>"},{paraid:9,text:"<ul><ul><li><strong>Creating from Data</strong></li></ul></ul>"},{paraid:9,text:"<ul><ul>You can create an observable from an array, iterable, or other data structures using the `<code>from</code>` function.</ul></ul>"},{paraid:10,text:"<ul><ul><li><strong>Creating from Events</strong></li></ul></ul>"},{paraid:10,text:"<ul><ul>Observables can be created from DOM events, node.js events, and more using the `<code>fromEvent</code>` function.</ul></ul>"},{paraid:11,text:"<ul><ul><li><strong>Creating Manually</strong></li></ul></ul>"},{paraid:11,text:"<ul><ul>You can manually create observables using the `<code>new Observable</code>` constructor and defining how values are emitted, errors are handled, and the observable is completed.</ul></ul>"},{paraid:12,text:'<ol start="3"><li><strong>Subscribing to Observables</strong></li></ol>'},{paraid:13,text:"<ul>To start receiving data from an observable, you need to subscribe to it. Subscribing involves providing an observer object that defines the behavior of handling emitted values, errors, and completion.</ul>"},{paraid:14,text:'<ol start="4"><li><strong>Unsubscribing</strong></li></ol>'},{paraid:15,text:"<ul>Subscriptions create a connection between an observable and an observer. It's important to manage subscriptions to avoid memory leaks. When you're done using an observable, unsubscribe from it to release any resources it's holding.</ul>"},{paraid:16,text:'<ol start="5"><li><strong>Hot and Cold Observables</strong></li></ol>'},{paraid:17,text:"<ul>Observables can be categorized as hot or cold:</ul>"},{paraid:18,text:"<ul><ul><li><strong>Cold Observables</strong></li></ul></ul>"},{paraid:18,text:"<ul><ul>They start emitting values when a subscription is made. Each subscriber gets its own separate stream of values.</ul></ul>"},{paraid:19,text:"<ul><ul><li><strong>Hot Observables</strong></li></ul></ul>"},{paraid:19,text:"<ul><ul>They emit values regardless of whether there are subscribers. Subscribers get the values emitted at the time they subscribe. Hot observables are often used for events or data sources that are shared among multiple subscribers.</ul></ul>"},{paraid:20,text:'<ol start="6"><li><strong>Observables and Async Operations</strong></li></ol>'},{paraid:21,text:"<ul>Observables are especially useful for handling asynchronous operations, such as fetching data from APIs or managing user interactions. They provide a consistent way to work with and transform data streams, making your code more readable and maintainable.</ul>"},{paraid:22,text:"Overall, observables are the building blocks of reactive programming in RxJS. They enable you to work with asynchronous data flows, events, and real-time interactions in a structured and powerful manner."}]},{secid:2,subtitle:"Creating Observables",paragraphs:[{paraid:1,text:"Creating observables is a fundamental step in working with RxJS. Observables represent streams of data that can emit values, errors, and a completion signal over time. RxJS provides various methods to create observables based on different data sources and scenarios. Here are some common ways to create observables:"},{paraid:3,text:"<ol><li><strong>Creating from Data Using `<code>of</code>`</strong></li></ol>"},{paraid:4,text:"<ul>You can use the `<code>of</code>` function to create an Observable from a list of values. It emits each value in the list sequentially and then completes:</ul>"},{paraid:5,text:"",codeConfig:{codeid:"rxjs_2_2_1",exampleid:"rxjs_2_2_1_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:6,text:'<ol start="2"><li><strong>Creating from Data Using `<code>from</code>`</strong></li></ol>'},{paraid:7,text:"<ul>You can create observables from existing data, such as arrays, iterables, or other data structures, using the `<code>from</code>` function. This is useful when you want to work with data that is available synchronously:</ul>"},{paraid:8,text:"",codeConfig:{codeid:"rxjs_2_2_2",exampleid:"rxjs_2_2_2_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:9,text:'<ol start="3"><li><strong>Creating from Promises</strong></li></ol>'},{paraid:10,text:"<ul>You can convert a promise into an observable using the `<code>from</code>` function as well. This allows you to work with asynchronous operations that resolve with a single value:</ul>"},{paraid:11,text:"",codeConfig:{codeid:"rxjs_2_2_3",exampleid:"rxjs_2_2_3_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:12,text:'<ol start="4"><li><strong>Creating from Events</strong></li></ol>'},{paraid:13,text:"<ul>The `<code>fromEvent</code>` function is used to create observables from DOM events or events in other environments (e.g., Node.js). This is useful for reacting to user interactions and other asynchronous events:</ul>"},{paraid:14,text:"",codeConfig:{codeid:"rxjs_2_2_4",exampleid:"rxjs_2_2_4_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:15,text:'<ol start="5"><li><strong>Creating Manually</strong></li></ol>'},{paraid:16,text:"<ul>You can manually create observables using the `<code>Observable</code>` constructor. This gives you fine-grained control over how values are emitted, errors are handled, and the observable completes:</ul>"},{paraid:17,text:"",codeConfig:{codeid:"rxjs_2_2_5",exampleid:"rxjs_2_2_5_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:18,text:'<ol start="6"><li><strong>Creating Timed Observables</strong></li></ol>'},{paraid:19,text:"<ul>RxJS provides functions like `<code>interval</code>` and `<code>timer</code>` to create observables that emit values at specific time intervals. These are useful for scenarios like polling or creating animations:</ul>"},{paraid:20,text:"",codeConfig:{codeid:"rxjs_2_2_6",exampleid:"rxjs_2_2_6_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:21,text:'<ol start="7"><li><strong>Creating Observables with Other Operators</strong></li></ol>'},{paraid:22,text:"<ul>Operators like `<code>range</code>`, `<code>defer</code>`, and `<code>scheduled</code>` provide additional ways to create observables with specific characteristics. For instance, the `<code>scheduled</code>` operator creates an observable that uses a scheduler for fine-grained control over timing:</ul>"},{paraid:23,text:"",codeConfig:{codeid:"rxjs_2_2_7",exampleid:"rxjs_2_2_7_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:24,text:"These are just a few examples of how you can create observables in RxJS. Depending on your use case and data source, you can choose the appropriate method to create observables and start working with reactive data streams."}]},{secid:3,subtitle:"Subscribing to Observables",paragraphs:[{paraid:1,text:"Subscribing to observables is a critical step in RxJS, as it allows you to start receiving data from the observable's data stream. When you subscribe to an observable, you provide an observer object that defines how to handle emitted values, errors, and the completion of the observable. Here's a detailed explanation of how subscribing to observables works in RxJS:"},{paraid:1,text:"<ol><li><strong>Creating an `<code>Observable</code>`</strong></li></ol>"},{paraid:1,text:"<ul>Before you can subscribe to an observable, you first need to have an observable. This can be created in several ways, such as from events, HTTP requests, or custom logic. For example:</ul>"},{paraid:17,text:"",codeConfig:{codeid:"rxjs_2_3_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="2"><li><strong>Subscribing to the `<code>Observable</code>`</strong></li></ol>'},{paraid:1,text:"<ul>To start receiving values from the observable, you subscribe to it using the `<code>subscribe()</code>` method. This method takes up to three arguments: handlers for the next value, error, and completion:</ul>"},{paraid:1,text:"<ul><ul><li><strong>Next Handler</strong></li></ul></ul>"},{paraid:1,text:"<ul><ul>A function that handles receiving each value emitted by the observable.</ul></ul>"},{paraid:1,text:"<ul><ul><li><strong>Error Handler</strong></li></ul></ul>"},{paraid:1,text:"<ul><ul>(Optional) A function that handles a potential error emitted by the observable.</ul></ul>"},{paraid:1,text:"<ul><ul><li><strong>Complete Handler</strong></li></ul></ul>"},{paraid:1,text:"<ul><ul>(Optional) A function that handles the completion signal from the observable.</ul></ul>"},{paraid:17,text:"",codeConfig:{codeid:"rxjs_2_3_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"5rem"}},{paraid:1,text:"<ul><ul>Or, as a shorthand, you can directly provide the functions as arguments:</ul></ul>"},{paraid:17,text:"",codeConfig:{codeid:"rxjs_2_3_3",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"5rem"}},{paraid:1,text:'<ol start="3"><li><strong>Unsubscribing from the `<code>Observable</code>`</strong></li></ol>'},{paraid:1,text:"<ul>Once you have subscribed to an observable, it will continue to emit values, and the subscription will continue to listen to these values until the observable completes, an error occurs, or you manually unsubscribe. Unsubscribing is essential to prevent memory leaks, especially in scenarios like Angular components where observables might continue emitting values even after the component is destroyed.</ul>"},{paraid:17,text:"",codeConfig:{codeid:"rxjs_2_3_4",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="4"><li><strong>Handling Multiple Values</strong></li></ol>'},{paraid:1,text:"<ul>Observables can emit multiple values over time, and each of these emissions will trigger the next handler in your subscription.</ul>"},{paraid:1,text:'<ol start="5"><li><strong>Asynchronous Nature</strong></li></ol>'},{paraid:1,text:"<ul>Observables can emit values asynchronously, as shown in the initial example where a value is emitted after a timeout.</ul>"},{paraid:2,text:'<ol start="6"><li><strong>An Example Subscribing to an Observable</strong></li></ol>'},{paraid:3,text:"",codeConfig:{codeid:"rxjs_2_3_5",exampleid:"rxjs_2_3_5_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:13,text:"Keep in mind that subscribing to an observable creates a connection between the observable and the observer. This connection allows the observer to receive emitted values and other signals. Properly managing subscriptions, including unsubscribing when they're no longer needed, is essential to prevent memory leaks in your application."}]},{secid:4,subtitle:"Unsubscribing and Managing Subscriptions",paragraphs:[{paraid:1,text:"Unsubscribing from an RxJS Observable is a crucial operation to prevent memory leaks and stop receiving emissions when you're done with the Observable. RxJS provides a Subscription object that represents the link between the Observable and the observer (the subscriber). When you unsubscribe, you essentially terminate this link. Here's a detailed explanation of how unsubscribing works in RxJS:"},{paraid:2,text:"<ol><li><strong>Unsubscribing from a Single Subscription</strong></li></ol>"},{paraid:3,text:"<ul>When you subscribe to an observable, the `<code>subscribe</code>` method returns a subscription object. You can call the `<code>unsubscribe</code>` method on this object to stop receiving data from the observable and release resources associated with the subscription:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"rxjs_2_4_1",exampleid:"rxjs_2_4_1_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:5,text:"<ul>In the example above, we're using the returned function from the observable's constructor to clean up resources (in this case, clearing an interval) when the subscription is unsubscribed.</ul>"},{paraid:6,text:'<ol start="2"><li><strong>Managing Multiple Subscriptions</strong></li></ol>'},{paraid:7,text:"<ul>When dealing with multiple subscriptions, you can store them in an array or another data structure and then loop through the collection to unsubscribe from all of them when needed:</ul>"},{paraid:8,text:"",codeConfig:{codeid:"rxjs_2_4_2",exampleid:"rxjs_2_4_2_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:9,text:"<ul>You can use the `<code>Subscription</code>` class to manage and unsubscribe from multiple subscriptions at once. This can be particularly useful when you have several subscriptions that you want to clean up together:</ul>"},{paraid:10,text:"",codeConfig:{codeid:"rxjs_2_4_3",exampleid:"rxjs_2_4_3_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:11,text:'<ol start="3"><li><strong>Auto-Unsubscribing</strong></li></ol>'},{paraid:12,text:"<ul>RxJS provides operators like `<code>take</code>`, `<code>first</code>`, `<code>takeWhile</code>`, and `<code>takeUntil</code>` that can automatically unsubscribe for you when a certain condition is met or a specific number of values is emitted. These operators are handy when you only want to observe a limited portion of an observable:</ul>"},{paraid:13,text:"",codeConfig:{codeid:"rxjs_2_4_4",exampleid:"rxjs_2_4_4_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:14,text:"<ul>In this example, the `<code>take(5)</code>` operator ensures that the subscription automatically unsubscribes after receiving 5 values.</ul>"},{paraid:15,text:"In summary, unsubscribing from an RxJS Observable is a critical practice to manage resources, prevent memory leaks, and control the lifecycle of your observables. Always remember to unsubscribe when you're done with an observable to ensure clean and efficient resource management in your application."}]},{secid:5,subtitle:"Creating Observers",paragraphs:[{paraid:1,text:"Observers play a crucial role in the RxJS ecosystem as they define how to handle the values, errors, and completion signals emitted by observables. An observer is an object that typically consists of three callback functions: `<code>next</code>`, `<code>error</code>`, and `<code>complete</code>`. These functions define how to react to the different types of notifications that an observable can emit."},{paraid:2,text:"<ol><li><strong>Creating Observers</strong></li></ol>"},{paraid:3,text:"<ul>Here's how you can create and use observers in RxJS:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"rxjs_2_5_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:5,text:"<ul>In the example above, we've defined an observer object with three functions: `<code>next</code>`, `<code>error</code>`, and `<code>complete</code>`. These functions will be called by the observable depending on the type of notification it emits.</ul>"},{paraid:6,text:'<ol start="2"><li><strong>Using Observers</strong></li></ol>'},{paraid:7,text:"<ul>To use this observer, you would typically pass it as an argument to the `<code>subscribe</code>` method of an observable:</ul>"},{paraid:9,text:"",codeConfig:{codeid:"rxjs_2_5_2",exampleid:"rxjs_2_5_2_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:8,text:"<ul>When you subscribe to the observable, the `<code>next</code>` function of the observer will be called each time the observable emits a value, the `<code>error</code>` function will be called if an error occurs, and the `<code>complete</code>` function will be called when the observable completes.</ul>"},{paraid:10,text:"<ul>You can also directly define the observer inline when subscribing:</ul>"},{paraid:11,text:"",codeConfig:{codeid:"rxjs_2_5_3",exampleid:"rxjs_2_5_3_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:12,text:"<ul>In many cases, you might not need to handle all three types of notifications (next, error, complete). For example, if you're only interested in handling the emitted values, you can omit the `<code>error</code>` and `<code>complete</code>` functions from your observer object.</ul>"},{paraid:13,text:"Creating observers allows you to define the logic for reacting to the data emitted by observables in a flexible and customizable way. This separation of concerns between observables (data sources) and observers (data consumers) contributes to the modularity and reusability of your RxJS code."}]}]},{category:"rxjs",chid:3,title:"Operators",sections:[{secid:1,subtitle:"Introduction to Operators",paragraphs:[{paraid:1,text:"Operators are a central concept in RxJS that enable you to transform, filter, combine, and manipulate data streams emitted by observables. Operators provide a way to perform operations on the emitted values and create new observables with modified data. They allow you to work with data in a more declarative and functional way, leading to more concise and readable code."},{paraid:2,text:"Operators in RxJS are categorized into several types based on their functionality:"},{paraid:3,text:"<ol><li><strong>Filtering Operators</strong></li></ol>"},{paraid:4,text:"<ul>RxJS filtering operators are a category of operators that allow you to filter the values emitted by an Observable based on certain criteria. These operators help you selectively pass through or reject values from the source Observable, creating a new Observable with a filtered subset of data. Filtering operators are essential for managing and processing data streams efficiently. Examples include `<code>filter</code>`, `<code>take</code>`, `<code>skip</code>`, and `<code>distinctUntilChanged</code>`.</ul>"},{paraid:5,text:"<ul></ul>"},{paraid:6,text:'<ol start="2"><li><strong>Transformation Operators</strong></li></ol>'},{paraid:7,text:"<ul>RxJS transformation operators are a category of operators that allow you to transform the data emitted by an Observable in various ways. These operators take an Observable as their source and produce a new Observable with modified or transformed data. Transformation operators are a powerful tool in reactive programming because they enable you to manipulate data streams in a declarative and composable manner. Examples include `<code>map</code>`, `<code>pluck</code>`, `<code>scan</code>`, and `<code>concatMap</code>`.</ul>"},{paraid:8,text:"<ul></ul>"},{paraid:9,text:'<ol start="3"><li><strong>Combination Operators</strong></li></ol>'},{paraid:10,text:"<ul>RxJS combination operators are a category of operators that enable you to combine or merge multiple Observables into a single Observable. These operators are useful when you need to work with multiple data streams concurrently, such as combining data from different sources or coordinating events. RxJS provides a variety of combination operators to suit different scenarios. Examples include `<code>merge</code>`, `<code>concat</code>`, `<code>combineLatest</code>`, and `<code>zip</code>`.</ul>"},{paraid:11,text:"<ul></ul>"},{paraid:12,text:'<ol start="4"><li><strong>Conditional and Boolean Operators</strong></li></ol>'},{paraid:13,text:"<ul>RxJS conditional and boolean operators are a category of operators that enable you to make decisions based on the values emitted by Observables. These operators allow you to perform conditional checks, filter values based on certain conditions, and determine whether values meet specific criteria. Here are some common RxJS conditional and boolean operators. Examples include `<code>every</code>`, `<code>defaultIfEmpty</code>`, `<code>isEmpty</code>`, and `<code>sequenceEqual</code>`.</ul>"},{paraid:14,text:"<ul></ul>"},{paraid:15,text:'<ol start="5"><li><strong>Error Handling Operators</strong></li></ol>'},{paraid:16,text:"<ul>RxJS error handling operators are a category of operators that allow you to handle errors emitted by Observables gracefully. These operators help you manage and recover from errors, control the error flow, and perform actions in response to errors. Handling errors properly is crucial for building robust and reliable reactive applications. Examples include `<code>catchError</code>`, `<code>retry</code>`, and `<code>retryWhen</code>`.</ul>"},{paraid:17,text:"<ul></ul>"},{paraid:18,text:'<ol start="6"><li><strong>Utility Operators</strong></li></ol>'},{paraid:19,text:"<ul>RxJS utility operators are a category of operators that provide various utility functions to work with Observables. These operators are used to perform tasks like inspecting, modifying, or controlling the behavior of Observables. Utility operators are not directly involved in data transformation but rather help you manage Observables effectively. Examples include `<code>do</code>`, `<code>finalize</code>`, `<code>delay</code>`, and `<code>toPromise</code>`.</ul>"},{paraid:20,text:"These are just a few examples of the wide range of operators available in RxJS. Operators can be chained together using the `<code>pipe</code>` method to perform complex operations on observables, making your code more expressive and allowing you to handle data streams in a powerful and efficient manner."}]},{secid:2,subtitle:"Filtering Operators",paragraphs:[{paraid:1,text:"Filtering operators in RxJS allow you to selectively include or exclude values emitted by an observable based on certain conditions. These operators help you work with specific subsets of the data stream and manage the data you're interested in. Here are some commonly used filtering operators in RxJS:"},{paraid:2,text:"<ol><li><strong>`<code>filter</code>` Operator</strong></li></ol>"},{paraid:3,text:"<ul>The `<code>filter</code>` operator in RxJS is used to selectively emit values from an Observable based on a specified condition. It filters out values that do not satisfy the condition:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"rxjs_3_2_1",exampleid:"rxjs_3_2_1_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:5,text:"<ul>In this example, we have an `<code>source</code>` Observable that emits values from 1 to 10. The `<code>filter</code>` operator is used to filter out even numbers from the sequence (values where `<code>x % 2 === 0</code>` is true). As a result, only the odd numbers will be emitted to the subscriber.</ul>"},{paraid:6,text:'<ol start="2"><li><strong>`<code>take</code>` Operator</strong></li></ol>'},{paraid:7,text:"<ul>The `<code>take</code>` operator limits the number of values emitted by the source Observable to a specified count. Once the specified count is reached, the Observable completes:</ul>"},{paraid:8,text:"",codeConfig:{codeid:"rxjs_3_2_2",exampleid:"rxjs_3_2_2_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:9,text:"<ul>In this example, the source Observable emits values continuously, but the `<code>take(5)</code>` operator ensures that only the first 5 values are emitted. After emitting those 5 values, the Observable completes.</ul>"},{paraid:10,text:'<ol start="3"><li><strong>`<code>takeWhile</code>` Operator</strong></li></ol>'},{paraid:11,text:"<ul>The `<code>takeWhile</code>` operator emits values from the source Observable as long as they satisfy a specified condition. It creates a new Observable that stops emitting values once the condition is not met:</ul>"},{paraid:12,text:"",codeConfig:{codeid:"rxjs_3_2_3",exampleid:"rxjs_3_2_3_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:13,text:"<ul>In this example, the `<code>takeWhile</code>` operator is used to take values from the source Observable as long as `<code>x</code>` is less than or equal to 3. Once the condition is not met (when `<code>x</code>` becomes 4), the Observable completes, and no further values are emitted.</ul>"},{paraid:14,text:'<ol start="4"><li><strong>`<code>skip</code>` Operator</strong></li></ol>'},{paraid:15,text:"<ul>The `<code>skip</code>` operator skips a specified number of values emitted by the source Observable before allowing subsequent values to be emitted:</ul>"},{paraid:16,text:"",codeConfig:{codeid:"rxjs_3_2_4",exampleid:"rxjs_3_2_4_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:17,text:"<ul>In this example, the `<code>skip(3)</code>` operator skips the first 3 values emitted by the source Observable. After skipping those 3 values, the `<code>take(5)</code>` operator takes the next 5 values, and then the Observable completes.</ul>"},{paraid:18,text:'<ol start="5"><li><strong>`<code>skipWhile</code>` Operator</strong></li></ol>'},{paraid:19,text:"<ul>The `<code>skipWhile</code>` operator skips values emitted by the source Observable until a specified condition is no longer met:</ul>"},{paraid:20,text:"",codeConfig:{codeid:"rxjs_3_2_5",exampleid:"rxjs_3_2_5_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:21,text:"<ul>In this example, the `<code>skipWhile</code>` operator is used to skip values from the source Observable as long as `<code>x</code>` is less than or equal to 3. Once the condition is not met (when `<code>x</code>` becomes 4), the Observable starts emitting values, and it completes after emitting all remaining values.</ul>"},{paraid:22,text:'<ol start="6"><li><strong>`<code>distinctUntilChanged</code>` Operator</strong></li></ol>'},{paraid:23,text:"<ul>The `<code>distinctUntilChanged</code>` operator in RxJS is used to filter out consecutive duplicate values emitted by an Observable. It ensures that only distinct, non-consecutive values are emitted to the subscriber:</ul>"},{paraid:24,text:"",codeConfig:{codeid:"rxjs_3_2_6",exampleid:"rxjs_3_2_6_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:25,text:"<ul>In this example, the `<code>distinctUntilChanged</code>` operator is used to filter out consecutive duplicate values from the source Observable. As a result, only the first occurrence of each distinct value is emitted to the subscriber.</ul>"},{paraid:26,text:"These are just a few examples of filtering operators available in RxJS. By using filtering operators, you can control which values are emitted by observables, ensuring that your application responds only to the relevant data changes."}]},{secid:3,subtitle:"Transformation Operators",paragraphs:[{paraid:1,text:"Transformation operators in RxJS allow you to modify, transform, and manipulate the values emitted by an observable. These operators provide powerful ways to work with the data stream, converting it into a more suitable format, performing calculations, or applying modifications. Here are some commonly used transformation operators in RxJS:"},{paraid:2,text:"<ol><li><strong>`<code>map</code>` Operator</strong></li></ol>"},{paraid:3,text:"<ul>The `<code>map</code>` operator is used to transform the values emitted by an Observable by applying a given function to each value:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"rxjs_3_3_1",exampleid:"rxjs_3_3_1_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:5,text:"<ul>In this example, the `<code>map</code>` operator is used to double each value emitted by the `<code>source</code>` Observable. </ul>"},{paraid:6,text:'<ol start="2"><li><strong>`<code>pluck</code>` Operator</strong></li></ol>'},{paraid:7,text:"<ul>The `<code>pluck</code>` operator is used to extract a specific property from each emitted object in an Observable:</ul>"},{paraid:8,text:"",codeConfig:{codeid:"rxjs_3_3_2",exampleid:"rxjs_3_3_2_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:9,text:"<ul>In this example, the `<code>pluck</code>` operator is used to extract the `<code>name</code>` property from each object emitted by the `<code>source</code>` Observable.</ul>"},{paraid:10,text:'<ol start="3"><li><strong>`<code>scan</code>` Operator</strong></li></ol>'},{paraid:11,text:"<ul>The `<code>scan</code>` operator is used to accumulate values emitted by an Observable by applying an accumulator function. It produces a running total of values:</ul>"},{paraid:12,text:"",codeConfig:{codeid:"rxjs_3_3_3",exampleid:"rxjs_3_3_3_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:13,text:"<ul>In this example, the `<code>scan</code>` operator is used to calculate the running sum of values emitted by the `<code>source</code>` Observable. </ul>"},{paraid:14,text:'<ol start="4"><li><strong>`<code>toArray</code>` Operator</strong></li></ol>'},{paraid:15,text:"<ul>The toArray operator collects all values emitted by an Observable and emits them as an array when the source Observable completes:</ul>"},{paraid:16,text:"",codeConfig:{codeid:"rxjs_3_3_4",exampleid:"rxjs_3_3_4_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:17,text:"<ul>In this example, the `<code>toArray</code>` operator collects all values emitted by the `<code>source</code>` Observable and emits them as an array when the source completes.</ul>"},{paraid:18,text:"These are just a few examples of transformation operators in RxJS. By using these operators, you can manipulate and process the values emitted by observables in various ways, making your code more expressive and enabling you to achieve complex data transformations with ease."}]},{secid:4,subtitle:"Combination Operators",paragraphs:[{paraid:1,text:"Combination operators in RxJS allow you to work with multiple observables, combining their emissions in various ways. These operators are useful when you need to coordinate the values emitted by different observables or when you want to merge, concatenate, or otherwise interact with multiple data streams. Here are some commonly used combination operators in RxJS:"},{paraid:2,text:"<ol><li><strong>`<code>merge</code>` Operator</strong></li></ol>"},{paraid:3,text:"<ul>The `<code>merge</code>` operator combines multiple Observables into a single Observable. It interleaves the emissions from each source Observable:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"rxjs_3_4_1",exampleid:"rxjs_3_4_1_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:5,text:"<ul>In this example, two source Observables, `<code>source1</code>` and `<code>source2</code>`, are merged using the `<code>merge</code>` operator. </ul>"},{paraid:6,text:'<ol start="2"><li><strong>`<code>concat</code>` Operator</strong></li></ol>'},{paraid:7,text:"<ul>The `<code>concat</code>` operator concatenates multiple Observables, emitting values from one source Observable before moving to the next:</ul>"},{paraid:8,text:"",codeConfig:{codeid:"rxjs_3_4_2",exampleid:"rxjs_3_4_2_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:9,text:"<ul>In this example, `<code>source1</code>` is concatenated with `<code>source2</code>` using the `<code>concat</code>` operator.</ul>"},{paraid:10,text:'<ol start="3"><li><strong>`<code>combineLatest</code>` Operator</strong></li></ol>'},{paraid:11,text:"<ul>The `<code>combineLatest</code>` operator combines the latest values from multiple Observables whenever any of the source Observables emits a new value:</ul>"},{paraid:12,text:"",codeConfig:{codeid:"rxjs_3_4_3",exampleid:"rxjs_3_4_3_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:13,text:"<ul>In this example, `<code>source1</code>` and `<code>source2</code>` are combined using the `<code>combineLatest</code>` operator. As each source emits values at different intervals, the operator combines the latest values from both sources. The output will continuously update with the latest combinations.</ul>"},{paraid:14,text:'<ol start="4"><li><strong>`<code>forkJoin</code>` Operator</strong></li></ol>'},{paraid:15,text:"<ul>The `<code>forkJoin</code>` operator waits for all source Observables to complete and then emits an array containing the last values emitted by each source Observable:</ul>"},{paraid:16,text:"",codeConfig:{codeid:"rxjs_3_4_4",exampleid:"rxjs_3_4_4_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:17,text:"<ul>In this example, `<code>forkJoin</code>` waits for both `<code>source1</code>` and `<code>source2</code>` to complete and then emits an array with the last values emitted by each source.</ul>"},{paraid:18,text:'<ol start="5"><li><strong>`<code>startWith</code>` Operator</strong></li></ol>'},{paraid:19,text:"<ul>The `<code>startWith</code>` operator prepends a specified initial value to the values emitted by an Observable:</ul>"},{paraid:20,text:"",codeConfig:{codeid:"rxjs_3_4_5",exampleid:"rxjs_3_4_5_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:21,text:"<ul>In this example, the `<code>startWith</code>` operator is used to prepend the value `<code>0</code>` to the values emitted by the `<code>source</code>` Observable. </ul>"},{paraid:22,text:"These examples demonstrate the usage of combination operators in RxJS for various scenarios where you need to combine, concatenate, or modify Observables."}]},{secid:5,subtitle:"Conditional Operators",paragraphs:[{paraid:1,text:"Conditional operators in RxJS allow you to work with emitted values to produce boolean results, make decisions, and control the flow of data. These operators help you evaluate conditions, determine whether values meet certain criteria, and implement logic based on the emitted data. Here are some commonly used conditional and boolean operators in RxJS:"},{paraid:2,text:"<ol><li><strong>`<code>every</code>` Operator</strong></li></ol>"},{paraid:3,text:"<ul>The `<code>every</code>` operator checks whether all the values emitted by an Observable meet a specified condition:</ul>"},{paraid:5,text:"",codeConfig:{codeid:"rxjs_3_5_1",exampleid:"rxjs_3_5_1_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:4,text:"<ul>In this example, the `<code>every</code>` operator checks if all values emitted by the `<code>source</code>` Observable are even numbers.</ul>"},{paraid:6,text:'<ol start="2"><li><strong>`<code>find</code>` Operator</strong></li></ol>'},{paraid:7,text:"<ul>The `<code>find</code>` operator is used to find the first value emitted by an Observable that satisfies a given condition:</ul>"},{paraid:9,text:"",codeConfig:{codeid:"rxjs_3_5_2",exampleid:"rxjs_3_5_2_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:8,text:"<ul>In this example, the `<code>find</code>` operator searches for the first value emitted by the `<code>source</code>` Observable that is greater than 2.</ul>"},{paraid:10,text:'<ol start="3"><li><strong>`<code>findIndex</code>` Operator</strong></li></ol>'},{paraid:11,text:"<ul>The `<code>findIndex</code>` operator is used to find the index of the first value emitted by an Observable that satisfies a given condition:</ul>"},{paraid:13,text:"",codeConfig:{codeid:"rxjs_3_5_3",exampleid:"rxjs_3_5_3_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:12,text:"<ul>In this example, the `<code>findIndex</code>` operator searches for the index of the first value emitted by the `<code>source</code>` Observable that is greater than 35. </ul>"},{paraid:14,text:'<ol start="4"><li><strong>`<code>isEmpty</code>` Operator</strong></li></ol>'},{paraid:15,text:"<ul>The `<code>isEmpty</code>` operator checks whether an Observable emits any values or completes without emitting any values:</ul>"},{paraid:17,text:"",codeConfig:{codeid:"rxjs_3_5_4",exampleid:"rxjs_3_5_4_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:16,text:"<ul>In this example, the `<code>isEmpty</code>` operator is used to check if `<code>source1</code>` and `<code>source2</code>` are empty Observables. `<code>source1</code>` is empty, so the output will be `<code>Is source1 empty? true</code>`. `<code>source2</code>` contains values, so the output will be `<code>Is source2 empty? false</code>`.</ul>"},{paraid:18,text:"These are some examples of conditional operators available in RxJS. By using these operators, you can introduce logic, evaluate conditions, and control the flow of data within your reactive programming pipelines."}]},{secid:6,subtitle:"Utility Operators",paragraphs:[{paraid:1,text:"RxJS utility operators are a category of operators that provide various utility functions to work with Observables. These operators are used to perform tasks like inspecting, modifying, or controlling the behavior of Observables. Utility operators are not directly involved in data transformation but rather help you manage Observables effectively. Here are some common RxJS utility operators:"},{paraid:2,text:"<ol><li><strong>`<code>tap</code>` Operator</strong></li></ol>"},{paraid:3,text:"<ul>The `<code>tap</code>` operator (`<code>do</code>` operator has the same functionality) allows you to perform side effects or log values from an Observable without affecting the emitted values:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"rxjs_3_6_1",exampleid:"rxjs_3_6_1_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:5,text:"<ul>In this example, the `<code>tap</code>` operator is used to log each value emitted by the `<code>source</code>` Observable without modifying the values.</ul>"},{paraid:6,text:'<ol start="2"><li><strong>`<code>delay</code>` Operator</strong></li></ol>'},{paraid:7,text:"<ul>The `<code>delay</code>` operator adds a time delay to the emissions from an Observable:</ul>"},{paraid:8,text:"",codeConfig:{codeid:"rxjs_3_6_2",exampleid:"rxjs_3_6_2_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:9,text:"<ul>In this example, the `<code>delay</code>` operator delays the emissions from the `<code>source</code>` Observable by 2 seconds.</ul>"},{paraid:10,text:'<ol start="3"><li><strong>`<code>finalize</code>` Operator</strong></li></ol>'},{paraid:11,text:"<ul>The `<code>finalize</code>` operator allows you to run a specified function when an Observable completes, whether it completes successfully or with an error:</ul>"},{paraid:12,text:"",codeConfig:{codeid:"rxjs_3_6_3",exampleid:"rxjs_3_6_3_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:13,text:"<ul>In this example, the `<code>finalize</code>` operator is used to log a message when the `<code>source</code>` Observable completes.</ul>"},{paraid:14,text:'<ol start="4"><li><strong>`<code>timeout</code>` Operator</strong></li></ol>'},{paraid:15,text:"<ul>The `<code>timeout</code>` operator sets a time limit for how long an Observable can take to emit values. If the Observable takes longer than the specified timeout, it produces an error:</ul>"},{paraid:16,text:"",codeConfig:{codeid:"rxjs_3_6_4",exampleid:"rxjs_3_6_4_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:17,text:"<ul>In this example, the `<code>timeout</code>` operator is used to set a 2-second timeout for the `<code>source</code>` Observable. If the Observable takes longer than 2 seconds to emit a value, it will produce an error.</ul>"},{paraid:22,text:"These RxJS utility operators provide various functionalities to work with Observables more effectively, whether it's for debugging, time-based operations, error handling, or converting Observables into other data structures like Promises or arrays. They are essential tools for managing and manipulating Observables in your reactive applications."}]},{secid:7,subtitle:"Error Handling Operators",paragraphs:[{paraid:1,text:"Handling errors in observables is an essential part of writing robust and resilient RxJS code. Errors can occur at any point in the data stream, and proper error handling ensures that your application can gracefully respond to and recover from unexpected situations. RxJS provides several ways to handle errors in observables:"},{paraid:2,text:"<ol><li><strong>`<code>catchError</code>` Operator</strong></li></ol>"},{paraid:3,text:"<ul>The `<code>catchError</code>` operator is used to handle errors emitted by an Observable by replacing them with a fallback Observable:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"rxjs_3_7_1",exampleid:"rxjs_3_7_1_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:5,text:"<ul>In this example, the `<cdoe>catchError</code>` operator catches the error emitted by the `<code>source</code>` Observable and replaces it with a new Observable created using `<code>of</code>`. </ul>"},{paraid:6,text:'<ol start="2"><li><strong>`<code>retry</code>` Operator</strong></li></ol>'},{paraid:7,text:"<ul>The `<code>retry</code>` operator is used to automatically resubscribe to an Observable when it encounters an error, up to a specified number of retries:</ul>"},{paraid:8,text:"",codeConfig:{codeid:"rxjs_3_7_2",exampleid:"rxjs_3_7_2_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:9,text:"<ul>In this example, the `<code>retry</code>` operator retries the `<code>source</code>` Observable up to 2 times when an error occurs. </ul>"},{paraid:10,text:'<ol start="3"><li><strong>`<code>retryWhen</code>` Operator</strong></li></ol>'},{paraid:11,text:"<ul>The `<code>retryWhen</code>` operator is used to control when and how an Observable should be retried by providing a custom logic based on a notifier Observable:</ul>"},{paraid:12,text:"",codeConfig:{codeid:"rxjs_3_7_3",exampleid:"rxjs_3_7_3_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:13,text:"<ul>In this example, the `<code>retryWhen</code>` operator is used to implement custom retry logic. It retries the `<code>source</code>` Observable up to 2 times, with a 2-second delay between retries. After the specified number of retries, it emits a final error. </ul>"},{paraid:14,text:"Proper error handling in observables ensures that your application gracefully handles unexpected scenarios, provides meaningful feedback to users, and maintains its stability. By combining operators like `<code>catchError</code>`, `<code>retry</code>`, and `<code>retryWhen</code>`, you can implement error handling strategies that suit your application's requirements."}]}]},{category:"rxjs",chid:4,title:"Advanced Operators",sections:[{secid:1,subtitle:"Introduction to Advanced Operators",paragraphs:[{paraid:1,text:'It may be somewhat subjective to categorize certain operators as "advanced". Here, we use the complexity of these operators as a criterion for their classification. Advanced RxJS operators empower developers to manipulate and orchestrate observables in sophisticated ways, providing powerful tools for controlling the flow of data, managing concurrency, and implementing various asynchronous patterns. Understanding and effectively using these advanced operators is essential for mastering reactive programming with RxJS.'},{paraid:2,text:"<ol><li><strong>`<code>concatMap</code>` Operator</strong></li></ol>"},{paraid:3,text:"<ul>`<code>concatMap</code>` is a higher-order mapping operator that processes each inner observable sequentially. It waits for the current inner observable to complete before moving on to the next. This operator is useful when you want to maintain the order of emissions.</ul>"},{paraid:4,text:'<ol start="2"><li><strong>`<code>mergeMap</code>` Operator</strong></li></ol>'},{paraid:5,text:"<ul>`<code>mergeMap</code>` processes inner observables concurrently and merges their emissions into a single output observable. It doesn't guarantee the order of emissions from inner observables.</ul>"},{paraid:6,text:'<ol start="3"><li><strong>`<code>switchMap</code>` Operator</strong></li></ol>'},{paraid:7,text:"<ul>`<code>switchMap</code>` cancels the previous inner observable as soon as a new value arrives from the source observable. It's often used for scenarios where you want to switch to the latest inner observable and disregard previous ones.</ul>"},{paraid:8,text:'<ol start="4"><li><strong>`<code>exhaustMap</code>` Operator</strong></li></ol>'},{paraid:9,text:"<ul>`<code>exhaustMap</code>` ignores new values from the source observable until the current inner observable completes. It's useful when you want to prevent overlapping requests or actions.</ul>"},{paraid:10,text:'<ol start="5"><li><strong>`<code>debounceTime</code>` Operator</strong></li></ol>'},{paraid:11,text:'<ul>`<code>debounceTime</code>` is used to filter out rapid emissions from the source observable. It waits for a specified period of inactivity (the "debounce time") and emits the most recent value when that time elapses without new emissions.</ul>'},{paraid:12,text:'<ol start="6"><li><strong>`<code>throttleTime</code>` Operator</strong></li></ol>'},{paraid:13,text:'<ul>`<code>throttleTime</code>` emits the first value from the source observable immediately and then ignores subsequent values for a specified time period (the "throttle time"). It\'s often used to limit the rate of emissions.</ul>'},{paraid:14,text:'<ol start="7"><li><strong>`<code>buffer</code>` Operator</strong></li></ol>'},{paraid:15,text:"<ul>`<code>buffer</code>` collects values from the source observable over a specified time period or when a signal from another observable is received. It emits an array of buffered values.</ul>"},{paraid:16,text:'<ol start="8"><li><strong>`<code>window</code>` Operator</strong></li></ol>'},{paraid:17,text:"<ul>`<code>window</code>` segments the source observable into smaller observables based on a specified condition or time frame. It emits these smaller observables as higher-order observables.</ul>"},{paraid:18,text:'<ol start="9"><li><strong>Custom Operators</strong></li></ol>'},{paraid:19,text:"<ul>Custom operators are user-defined RxJS operators that encapsulate specific logic for transforming, filtering, or processing data in a way that suits your application's needs.</ul>"},{paraid:20,text:"In summary, advanced RxJS operators provide powerful functionality for controlling the flow of data and managing asynchronous operations. These operators are essential for creating responsive, efficient, and well-structured RxJS applications."}]},{secid:2,subtitle:"ConcatMap Operator",paragraphs:[{paraid:1,text:"The `<code>concatMap</code>` operator in RxJS is a higher-order mapping operator that is used to transform the values emitted by an observable into inner observables and then flatten and merge those inner observables into a single output observable. This operator processes each inner observable sequentially, maintaining the order of their emissions."},{paraid:2,text:"Here's a detailed breakdown of how `<code>concatMap</code>` works:"},{paraid:3,text:"<ol><li><strong>Mapping</strong></li></ol>"},{paraid:3,text:'<ul>When a source observable emits a value, `<code>concatMap</code>` applies a function to this value. This function typically returns a new observable (the "inner observable"). This is the mapping step, where each source value gets converted into an observable.</ul>'},{paraid:1,text:'<ol start="2"><li><strong>Queueing and Flattening</strong></li></ol>'},{paraid:1,text:"<ul>`<code>concatMap</code>` maintains the order of emitted values. It subscribes to each inner observable one after the other, in the order they were emitted by the source observable. This means it waits for the current inner observable to complete before subscribing to the next one.</ul>"},{paraid:4,text:'<ol start="3"><li><strong>Sequential Processing</strong></li></ol>'},{paraid:5,text:"<ul>The values emitted by the inner observables are merged together into a single output observable. This output observable emits these values in the same order in which they were emitted by the inner observables.</ul>"},{paraid:1,text:'<ol start="4"><li><strong>Use Cases</strong></li></ol>'},{paraid:13,text:"<ul>Common use cases for `<code>concatMap</code>` include scenarios where you need to perform operations that depend on the order of the values, such as making HTTP requests one at a time in the order they were triggered, or processing data that must maintain a specific order.</ul>"},{paraid:1,text:'<ol start="5"><li><strong>Example of `<code>concatMap</code>`</strong></li></ol>'},{paraid:7,text:"",codeConfig:{codeid:"rxjs_4_1_1",exampleid:"rxjs_4_1_1_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:14,text:"It's important to note that while `<code>concatMap</code>` ensures sequential processing, it may introduce delays if the inner observables have long-running operations. If you need more control over concurrency or you want to process inner observables concurrently, you can explore other operators like `<code>mergeMap</code>`, `<code>switchMap</code>`, or `<code>exhaustMap</code>`."}]},{secid:3,subtitle:"MergeMap Operator",paragraphs:[{paraid:1,text:"The `<code>mergeMap</code>` operator in RxJS is a higher-order mapping operator that is used to transform values emitted by an observable into inner observables and then flatten and merge those inner observables into a single output observable. Unlike `<code>concatMap</code>`, `<code>mergeMap</code>` processes inner observables concurrently, meaning it doesn't wait for one inner observable to complete before subscribing to the next one. This can introduce concurrency into your data processing."},{paraid:2,text:"<ol><li><strong>Mapping</strong></li></ol>"},{paraid:2,text:'<ul>Similar to other mapping operators, `<code>mergeMap</code>` takes each value emitted by the source observable and applies a function to it. This function returns a new observable, referred to as the "inner observable". This is the mapping step where each value from the source is transformed into an observable.</ul>'},{paraid:3,text:'<ol start="2"><li><strong>Merging</strong></li></ol>'},{paraid:3,text:"<ul>`<code>mergeMap</code>` does not preserve the order of the emitted values. Instead, it subscribes to each inner observable as soon as it is created. If multiple inner observables are active at the same time, their emissions are merged into the output observable as they occur.</ul>"},{paraid:4,text:'<ol start="3"><li><strong>Concurrency</strong></li></ol>'},{paraid:4,text:"<ul>One of the key features of `<code>mergeMap</code>` is its ability to handle concurrent inner observables. It can subscribe to multiple inner observables simultaneously. This behavior is particularly useful for scenarios where you want to initiate and process multiple asynchronous tasks (like HTTP requests) in parallel.</ul>"},{paraid:1,text:'<ol start="4"><li><strong>Overlapping Emissions</strong></li></ol>'},{paraid:1,text:"<ul>Since `<code>mergeMap</code>` subscribes to inner observables concurrently, it allows their emissions to overlap. This means that the order of emissions in the output observable might not match the order of values emitted by the source observable.</ul>"},{paraid:1,text:'<ol start="5"><li><strong>Use Cases</strong></li></ol>'},{paraid:12,text:"<ul>Common use cases for `<code>mergeMap</code>` include scenarios where you want to process data concurrently, such as making multiple asynchronous HTTP requests in concurrency or handling events from multiple sources simultaneously.</ul>"},{paraid:1,text:'<ol start="5"><li><strong>Example of `<code>mergeMap</code>`</strong></li></ol>'},{paraid:6,text:"",codeConfig:{codeid:"rxjs_4_2_1",exampleid:"rxjs_4_2_1_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:13,text:"Keep in mind that because `<code>mergeMap</code>` processes inner observables concurrently, it may not maintain the order of emissions."}]},{secid:4,subtitle:"SwitchMap Operator",paragraphs:[{paraid:1,text:"The `<code>switchMap</code>` operator in RxJS is a higher-order mapping operator used to transform values emitted by an observable into inner observables and switch to the most recent inner observable, unsubscribing from the previous one. This operator is particularly useful when dealing with scenarios where you want to cancel or switch to a new inner observable whenever a new value is emitted by the source observable."},{paraid:2,text:"Here's a detailed breakdown of how `<code>switchMap</code>` works:"},{paraid:3,text:"<ol><li><strong>Mapping</strong></li></ol>"},{paraid:3,text:"<ul>`<code>switchMap</code>` starts by taking each value emitted by the source observable and applying a function to it. This function returns an observable, which is the inner observable.</ul>"},{paraid:4,text:'<ol start="2"><li><strong>Switching</strong></li></ol>'},{paraid:4,text:'<ul>The key feature of `<code>switchMap</code>` is its switching behavior. Whenever a new value is emitted by the source observable, `<code>switchMap</code>` applies the transformation function to create a new inner observable. It then unsubscribes from the previous inner observable (if there was one) and subscribes to the new inner observable. In essence, it "switches" to the latest observable.</ul>'},{paraid:5,text:'<ol start="3"><li><strong>Cancellation of Ongoing Observables</strong></li></ol>'},{paraid:5,text:"<ul>As a result of this switching, any ongoing emissions from previous inner observables are cancelled. This is especially useful for scenarios where the latest value supersedes any previous values. For example, in the case of a search input where the search query is continuously updated, you're typically only interested in the results of the latest query.</ul>"},{paraid:1,text:'<ol start="4"><li><strong>Non-overlapping Emissions</strong></li></ol>'},{paraid:1,text:"<ul>`<code>switchMap</code>` ensures that emissions from different inner observables do not overlap. Since it subscribes to only one inner observable at a time, the values emitted to the output observable are always from the most recent inner observable.</ul>"},{paraid:1,text:'<ol start="5"><li><strong>Use Cases</strong></li></ol>'},{paraid:1,text:"<ul>`<code>switchMap</code>` is commonly used in scenarios where only the latest emission is relevant, and any ongoing processes initiated by previous emissions should be cancelled. This is typical in scenarios like type-ahead search suggestions, where the results of the previous search queries become irrelevant as soon as a new query is made.</ul>"},{paraid:1,text:'<ol start="6"><li><strong>Example of `<code>switchMap</code>`</strong></li></ol>'},{paraid:7,text:"",codeConfig:{codeid:"rxjs_4_3_1",exampleid:"rxjs_4_3_1_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:14,text:"`<code>switchMap</code>` is an operator that helps manage concurrency and ensures that only the most recent inner observable's emissions are considered, which can be critical in real-time and interactive applications."}]},{secid:5,subtitle:"ExhaustMap Operator",paragraphs:[{paraid:1,text:"The `<code>exhaustMap</code>` operator in RxJS is a higher-order mapping operator used to transform values emitted by an observable into inner observables and ignore new values from the source observable until the current inner observable completes. It's particularly useful when you want to prevent multiple inner observables from being active simultaneously and only consider the inner observable produced by the latest value from the source observable."},{paraid:2,text:"Here's a detailed breakdown of how `<code>exhaustMap</code>` works:"},{paraid:3,text:"<ol><li><strong>Mapping</strong></li><ol>"},{paraid:4,text:"<ul>`<code>exhaustMap</code>` takes each value emitted by the source observable and applies a function to it. This function typically returns a new observable, known as the inner observable. This is the mapping step where each source value is transformed into an observable.<ul>"},{paraid:4,text:'<ol start="2"><li><strong>First Emission Handling</strong></li><ol>'},{paraid:4,text:"<ul>When the first value is emitted by the source observable, `<code>exhaustMap</code>` applies the transformation function and subscribes to the resulting inner observable. It begins to emit values from this inner observable to the output.<ul>"},{paraid:5,text:'<ol start="3"><li><strong>Ignoring Subsequent Emissions</strong></li><ol>'},{paraid:5,text:"<ul>While this first inner observable is still active (i.e., it hasn't completed or errored out), any new values emitted by the source observable are ignored. `<code>exhaustMap</code>` does not subscribe to any new inner observables created from these values. This is the key characteristic that differentiates `<code>exhaustMap</code>` from other flattening operators.<ul>"},{paraid:6,text:'<ol start="4"><li><strong>Resumption Post Completion</strong></li><ol>'},{paraid:6,text:"<ul>Once the first inner observable completes, `<code>exhaustMap</code>` is ready to handle the next value emitted by the source observable. It will then apply the transformation function to this next value and subscribe to the new inner observable, repeating the process.<ul>"},{paraid:1,text:'<ol start="5"><li><strong>Use Cases</strong></li></ol>'},{paraid:1,text:"<ul>`<code>exhaustMap</code>` is particularly useful in scenarios where you want to prevent overlapping processing. For example, it's often used to handle scenarios like button clicks where you don't want to initiate a new process (like an API call) if the previous process triggered by a prior click is still ongoing.</ul>"},{paraid:1,text:'<ol start="6"><li><strong>Example of `<code>exhaustMap</code>`</strong></li></ol>'},{paraid:8,text:"",codeConfig:{codeid:"rxjs_4_4_1",exampleid:"rxjs_4_4_1_1",codeOutput:!0,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:15,text:"`<code>exhaustMap</code>` is particularly useful when you want to ensure that only one inner observable is active at a time and that subsequent events are ignored until the current inner observable completes. This can help avoid issues related to concurrent processing."}]},{secid:6,subtitle:"DebounceTime Operator",paragraphs:[{paraid:1,text:"The `<code>debounceTime</code>` operator in RxJS is used to control the rate at which values are emitted by an observable. It's particularly useful when dealing with events that may fire rapidly, such as user input events like keystrokes, mouse movements, or any event that generates frequent emissions. `<code>debounceTime</code>` emits the most recent value from the source observable only after a specified time period has passed without any new values being emitted."},{paraid:2,text:"Here's a detailed breakdown of how `<code>debounceTime</code>` works:"},{paraid:3,text:"<ol><li><strong>Delaying Emissions</strong></li></ol>"},{paraid:3,text:"<ul>When the source observable emits a value, `<code>debounceTime</code>` starts a timer with a specified duration (in milliseconds). If another value is emitted from the source observable before this timer expires, the timer is reset and starts over with the new value.</ul>"},{paraid:4,text:'<ol start="2"><li><strong>Emitting the Latest Value</strong></li></ol>'},{paraid:4,text:"<ul>The value is only sent to the observer if the timer completes without the source observable emitting another value. This means that `<code>debounceTime</code>` effectively ignores all values except the last one emitted before the specified time period elapses.</ul>"},{paraid:6,text:'<ol start="3"><li><strong>Repeat Process</strong></li></ol>'},{paraid:6,text:"<ul>After emitting a value, `<code>debounceTime</code>` starts the timer again and waits for the debounce time to pass before considering new values.</ul>"},{paraid:1,text:'<ol start="4"><li><strong>Use Cases</strong></li></ol>'},{paraid:1,text:"<ul>ommon use case for `<code>debounceTime</code>` is in search inputs where you want to wait for the user to stop typing before sending a request to the server. This reduces the number of requests made and improves performance.</ul>"},{paraid:1,text:'<ol start="5"><li><strong>Example of `<code>debounceTime</code>`</strong></li></ol>'},{paraid:8,text:"",codeConfig:{codeid:"rxjs_4_5_1",exampleid:"rxjs_4_5_1_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:16,text:"In summary, the `<code>debounceTime</code>` operator in RxJS is a powerful tool for controlling the rate of emissions from an observable. It helps filter out rapid changes and ensures that only the most relevant and recent values are considered, reducing unnecessary processing and improving the efficiency of your applications, especially in scenarios involving user interactions."}]},{secid:7,subtitle:"ThrottleTime Operator",paragraphs:[{paraid:1,text:"The `<code>throttleTime</code>` operator in RxJS is used to limit the rate at which values are emitted by an observable. It's particularly useful when dealing with events that may occur frequently, such as mouse movements or other continuous data streams. throttleTime allows values to pass through at a controlled frequency while ignoring values emitted within a specified time window."},{paraid:2,text:"Here's a detailed breakdown of how `<code>throttleTime</code>` works:"},{paraid:3,text:"<ol><li><strong>Initial Emission</strong></li></ol>"},{paraid:3,text:"<ul>When the source observable emits a value, `<code>throttleTime</code>` immediately allows this first value to pass through to its output. This is the start of the throttling period.</ul>"},{paraid:4,text:'<ol start="2"><li><strong>Throttling Period</strong></li></ol>'},{paraid:4,text:"<ul>After the first value is emitted, `<code>throttleTime</code>` begins a timer for the specified duration (in milliseconds). During this time, any further values emitted by the source observable are ignored.</ul>"},{paraid:5,text:'<ol start="3"><li><strong>Next Emission</strong></li></ol>'},{paraid:5,text:"<ul>Once the throttling period is over (i.e., the timer expires), the next value emitted by the source observable is allowed through, and a new throttling period begins.</ul>"},{paraid:6,text:'<ol start="4"><li><strong>Repeat Process</strong></li></ol>'},{paraid:6,text:"<ul>`<code>throttleTime</code>` continues to apply this behavior for each emitted value. If a new value is emitted before the current throttle time window ends, it is ignored. Only the first value within the window is allowed to pass.</ul>"},{paraid:1,text:'<ol start="5"><li><strong>Use Cases</strong></li></ol>'},{paraid:1,text:"<ul>This operator is particularly useful in scenarios where you want to limit the frequency of handling events or actions. A common example is limiting the rate at which a function is called in response to a button click or a scroll event, to avoid performance issues due to rapid firing of events.</ul>"},{paraid:1,text:'<ol start="6"><li><strong>Example of `<code>throttleTime</code>`</strong></li></ol>'},{paraid:7,text:"",codeConfig:{codeid:"rxjs_4_6_1",exampleid:"rxjs_4_6_1_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:15,text:"In summary, the `<code>throttleTime</code>` operator in RxJS provides control over the rate of emissions from an observable, allowing you to balance the processing of events with the desired frequency of updates in your application."}]},{secid:8,subtitle:"Buffer Operator",paragraphs:[{paraid:1,text:"The `<code>buffer</code>` operator in RxJS is used to collect and group values emitted by an observable into arrays (buffers) based on a specified signal from another observable. It's a powerful operator for managing and processing values in batches or chunks."},{paraid:2,text:"Here's a detailed `<code>breakdown</code>` of how the buffer operator works:"},{paraid:3,text:"<ol><li><strong>Signal Observable</strong></li></ol>"},{paraid:3,text:'<ul>The `<code>buffer</code>` operator requires another observable, often referred to as the "signal observable." This signal observable determines when to create a new buffer and emit the collected values.</ul>'},{paraid:4,text:'<ol start="2"><li><strong>Buffer Creation</strong></li></ol>'},{paraid:4,text:"<ul>When the signal observable emits a value, a new buffer is created to collect values from the source observable.</ul>"},{paraid:5,text:'<ol start="3"><li><strong>Value Collection</strong></li></ol>'},{paraid:5,text:"<ul>As values are emitted by the source observable, they are collected into the current buffer until the signal observable emits again.</ul>"},{paraid:6,text:'<ol start="4"><li><strong>Buffer Emission</strong></li></ol>'},{paraid:6,text:"<ul>When the signal observable emits, the current buffer is emitted as an array to the observer. After emission, a new empty buffer is created to start collecting values again.</ul>"},{paraid:7,text:'<ol start="5"><li><strong>Repeat Process</strong></li></ol>'},{paraid:7,text:"<ul>The process repeats for each signal emitted by the signal observable. This allows you to collect and process values in batches, where each batch corresponds to the values collected between two signal emissions.</ul>"},{paraid:1,text:'<ol start="6"><li><strong>Use Cases</strong></li></ol>'},{paraid:15,text:"<ul>Common use cases for the `<code>buffer</code>` operator include scenarios where you want to group data into chunks or batches for processing, such as implementing sliding windows for data analysis, capturing user input within specific time intervals, or managing data streams with variable emission rates.</ul>"},{paraid:1,text:'<ol start="7"><li><strong>Example of `<code>buffer</code>`</strong></li></ol>'},{paraid:9,text:"",codeConfig:{codeid:"rxjs_4_7_1",exampleid:"rxjs_4_7_1_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:16,text:"In summary, the `<code>buffer</code>` operator is employed to manage and process values emitted by an observable in a batched manner, making it easier to work with data in chunks or for implementing operations that require aggregating values over time or based on specific conditions."}]},{secid:9,subtitle:"Window Operator",paragraphs:[{paraid:1,text:'The `<code>window</code>` operator in RxJS is used to divide an observable into sub-observables, often referred to as "windows". Each window contains values emitted by the source observable within a specified time frame or based on the emissions of another "boundary" observable. It\'s a powerful operator for segmenting and processing data streams into manageable chunks.'},{paraid:2,text:"Here's a detailed breakdown of how the `<code>window</code>` operator works:"},{paraid:3,text:"<ol><li><strong>Boundary Observable</strong></li></ol>"},{paraid:3,text:'<ul>The `<code>window</code>` operator can optionally take another observable as its argument, often referred to as the "boundary" observable. This boundary observable determines when to open and close windows. If not provided, the operator uses a timer to open and close windows based on a specified time frame.</ul>'},{paraid:4,text:'<ol start="2"><li><strong>Window Creation</strong></li></ol>'},{paraid:4,text:"<ul>When the boundary observable emits a signal (or when the timer elapses, in the absence of a boundary observable), a new window is created.</ul>"},{paraid:5,text:'<ol start="3"><li><strong>Value Collection</strong></li></ol>'},{paraid:5,text:"<ul>As values are emitted by the source observable, they are collected into the current window until the boundary observable emits again or the timer elapses, indicating the window should close.</ul>"},{paraid:6,text:'<ol start="4"><li><strong>Window Emission</strong></li></ol>'},{paraid:6,text:"<ul>When the boundary observable emits (or the timer elapses), the current window, containing all the values collected since its creation, is emitted as a new observable to the observer.</ul>"},{paraid:7,text:'<ol start="5"><li><strong>Repeat Process</strong></li></ol>'},{paraid:7,text:"<ul>The process repeats for each boundary signal or timer elapse, creating new windows and collecting values accordingly. Each emitted window is an observable that can be subscribed to independently.</ul>"},{paraid:1,text:'<ol start="6"><li><strong>Use Cases</strong></li></ol>'},{paraid:16,text:"Common use cases for the `<code>window</code>` operator include scenarios where you want to segment and process data streams in a controlled manner, such as implementing sliding time-based windows for data analysis, dividing user interactions into distinct sessions, or managing data streams based on specific events or criteria."},{paraid:1,text:'<ol start="2"><li><strong>Example of `<code>window</code>`</strong></li></ol>'},{paraid:9,text:"",codeConfig:{codeid:"rxjs_4_8_1",exampleid:"rxjs_4_8_1_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:17,text:"In summary, the `<code>window</code>` operator in RxJS is used to create and manage windows of values within an observable, enabling more controlled and organized processing of data streams."}]},{secid:10,subtitle:"Custom Operators",paragraphs:[{paraid:1,text:"Creating custom RxJS operators allows you to encapsulate reusable logic for data transformation, filtering, or any other operation you want to perform on observables. Custom operators can enhance code readability, maintainability, and reusability."},{paraid:2,text:"<ol><li><strong>Creating Operators by Extending Existing Operators</strong></li></ol>"},{paraid:3,text:"<ul>The preferred approach for customizing RxJS operators is to use the `<code>pipe</code>` method along with pipeable operators. You can create custom operators by chaining together existing operators in a sequence within the `<code>pipe</code>` method. This approach is clean, modular, and allows you to create reusable custom operators. Here's an example:</ul>"},{paraid:4,text:"",codeConfig:{codeid:"rxjs_4_9_1",exampleid:"rxjs_4_9_1_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:5,text:"<ul>In the example:</ul>"},{paraid:6,text:"<ul><ul><li>A custom operator function named `<code>customOperator</code>` is defined. This function takes a single argument, `<code>predicate</code>`, which is a function used for filtering values in the observable. The `<code>customOperator</code>` function returns a new function that can be used with the `<code>pipe</code>` method to create a custom operator sequence. </li></ul></ul>"},{paraid:7,text:"<ul><ul><li>A `<code>source</code>` observable is created using the `<code>of</code>` operator. It emits a sequence of numbers (`<code>2</code>`, `<code>4</code>`, `<code>6</code>`, `<code>8</code>`, `<code>10</code>`).</li></ul></ul>"},{paraid:8,text:"<ul><ul><li>The `<code>customOperator</code>` is applied to the `<code>source</code>` observable using the `<code>pipe</code>` method. In this case, the `<code>x => x > 5</code>` function is used as the `<code>predicate</code>` for the `<code>filter</code>` operator. This predicate filters out values that are greater than 5.</li></ul></ul>"},{paraid:9,text:"<ul><ul><li>The `<code>subscribe</code>` method is called on the result observable to start listening to emissions from the custom operator sequence. When values are emitted, the provided callback function is executed.</li></ul></ul>"},{paraid:10,text:"<ul><ul><li>The values that pass through the custom operator sequence are `<code>6</code>`, `<code>8</code>`, and `<code>10</code>` (values greater than `<code>5</code>`), and these values are doubled by the `<code>map</code>` operator before being logged to the console.</li></ul></ul>"},{paraid:11,text:'<ol start="2"><li><strong>Creating Operators from Scratch</strong></li></ol>'},{paraid:12,text:"<ul>Creating a custom RxJS operator from scratch involves defining a function that returns a new observable with your custom logic. Let's create a simple custom operator called `<code>multiplyBy</code>` that multiplies each emitted value by a specified `<code>factor</code>`. We'll create this custom operator from scratch:</ul>"},{paraid:13,text:"",codeConfig:{codeid:"rxjs_4_9_2",exampleid:"rxjs_4_9_2_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:14,text:"<ul>In the example:</ul>"},{paraid:15,text:"<ul><ul><li>The `<code>multiplyBy</code>` function is defined as the custom operator. This function takes a single argument, `<code>factor</code>, which represents the value by which the emitted values will be multiplied. The `<code>multiplyBy</code>` function returns a function that will be used with the `<code>pipe</code>` method to apply the custom operator to an observable.</li></ul></ul>"},{paraid:16,text:"<ul><ul><li>Inside the function that takes the `<code>source</code>` observable, create a new observable using the Observable constructor. Within the new observable you've created, subscribe to the `<code>source</code>` observable using the `<code>subscribe</code>` method. You can define the `<code>next</code>`, `<code>error</code>`, and `<code>complete</code>` handlers to process values from the `<code>source</code>` observable.</li></ul></ul>"},{paraid:17,text:"<ul><ul><li>In the end of `<code>multiplyBy</code>` function, return a cleanup function that unsubscribes from the `<code>source</code> observable when the new observable created by your custom operator is unsubscribed.</li></ul></ul>"},{paraid:18,text:"<ul><ul><li>Create the `<code>source</code>` observable using Observable constructor.</li></ul></ul>"},{paraid:19,text:"<ul><ul><li>Apply the `<code>multiplyBy</code>` custom operator to the `<code>source</code>` observale in the same way as normal operators.</li></ul></ul>"},{paraid:20,text:"In summary, custom operators empower developers to tailor the behavior of observables to their specific needs. They enhance the modularity, readability, and reusability of RxJS code by encapsulating custom logic into composable functions that can be applied to observable streams."}]}]},{category:"rxjs",chid:5,title:"Subjects and Multicasting",sections:[{secid:1,subtitle:"Understanding Subjects",paragraphs:[{paraid:1,text:"In RxJS, a `<code>Subject</code>` is a special type of observable that can act as both a source of values and an observer that can subscribe to other observables. Subjects are used to multicast values to multiple subscribers, making them a powerful tool for communication and coordination in reactive programming. They can be thought of as a bridge between non-observable code and observable code:"},{paraid:2,text:"<ol><li><strong>`<code>Subject</code>`</strong></li></ol>"},{paraid:3,text:"<ul>A basic subject implementation where values are emitted and observed by subscribers. It doesn't have any initial value, and it doesn't remember the previously emitted values.</ul>"},{paraid:4,text:'<ol start="2"><li><strong>`<code>BehaviorSubject</code>`</strong></li></ol>'},{paraid:5,text:"<ul>A `<code>BehaviorSubject</code>` is similar to a regular subject but has an initial value. It always emits the most recent value to new subscribers or whenever a subscriber subscribes.</ul>"},{paraid:6,text:'<ol start="3"><li><strong>`<code>ReplaySubject</code>`</strong></li></ol>'},{paraid:7,text:'<ul>A `<code>ReplaySubject</code>` records a specified number of previous values and emits them to new subscribers. It can "replay" a buffer of past values.</ul>'},{paraid:8,text:'<ol start="4"><li><strong>`<code>AsyncSubject</code>`</strong></li></ol>'},{paraid:9,text:"<ul>An `<code>AsyncSubject</code>` only emits the last value when it completes, regardless of how many values were nexted.</ul>"},{paraid:10,text:"Subjects are commonly used for scenarios where you want to multicast data to multiple subscribers, such as sharing state between components or implementing event communication. However, when using subjects, be cautious about potential memory leaks, as subjects keep references to subscribers, and unsubscribing is important to avoid unwanted behavior."}]},{secid:2,subtitle:"Subject",paragraphs:[{paraid:1,text:"RxJS `<code>Subject</code>` is a type of observable that acts as both an observer and an observable. It allows values to be multicasted to multiple subscribers. This is different from plain observables, where each subscribed observer owns an independent execution of the observable."},{paraid:1,text:"Here's a basic guide on how to use an RxJS `<code>Subject</code>`:"},{paraid:1,text:"<ol><li><strong>Importing `<code>Subject</code>`</strong></li></ol>"},{paraid:1,text:"<ul>First, you need to import `<code>Subject</code>` from the `<code>rxjs</code>` package.</ul>"},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_2_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="2"><li><strong>Creating a `<code>Subject</code>`</strong></li></ol>'},{paraid:1,text:"<ul>Instantiate a new `<code>Subject</code>`.</ul>"},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_2_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="3"><li><strong>Subscribing Observers</strong></li></ol>'},{paraid:1,text:"<ul>Observers can subscribe to the `<code>Subject</code>` just like they would with an observable. Each observer will receive the same emitted values.</ul>"},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_2_3",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="4"><li><strong>Emitting Values</strong></li></ol>'},{paraid:1,text:"<ul>The `<code>Subject</code>` can emit values using the `<code>next()</code>` method. All subscribers will receive the same value.</ul>"},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_2_4",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="5"><li><strong>Completing the `<code>Subject</code>`</strong></li></ol>'},{paraid:1,text:"<ul>You can complete a `<code>Subject</code>`, signaling that no more values will be emitted, using the `<code>complete()</code>` method.</ul>"},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_2_5",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="6"><li><strong>Error Handling</strong></li></ol>'},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_2_6",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>If there\u2019s an error, you can use the `<code>error()</code>` method to emit an error notification to all subscribers.</ul>"},{paraid:2,text:'<ol start="7"><li><strong>Example of `<code>Subject</code>`:</strong></li></ol>'},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_2_7",exampleid:"rxjs_5_2_7_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:9,text:"As you can see, both observers receive the values emitted by the `<code>Subject</code>`. `<code>Subject</code>` is commonly used when you want to multicast values to multiple subscribers and is a fundamental building block in RxJS for creating more complex data flow scenarios."}]},{secid:3,subtitle:"BehaviorSubject",paragraphs:[{paraid:1,text:"RxJS `<code>BehaviorSubject</code>` is a type of subject in RxJS that stores the latest value emitted by the observable and emits it immediately to any new subscriber. It always holds a single value and ensures that subscribers receive the most recent value even if they subscribe after the value was emitted. This makes `<code>BehaviorSubject</code>` particularly useful for scenarios where you want to maintain and share state across components or manage initial values."},{paraid:1,text:"<ol><li><strong>Importing `<code>BehaviorSubject</code>`</strong></li></ol>"},{paraid:1,text:"<ul>First, import `<code>BehaviorSubject</code>` from the `<code>rxjs</code>` package.</ul>"},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_3_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="2"><li><strong>Creating a `<code>BehaviorSubject</code>`</strong></li></ol>'},{paraid:1,text:"<ul>Instantiate a `<code>BehaviorSubject</code>` with an initial value. This value is emitted to any subscriber upon subscription.</ul>"},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_3_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="3"><li><strong>Subscribing Observers</strong></li></ol>'},{paraid:1,text:"<ul>Observers can subscribe to the `<code>BehaviorSubject</code>` to receive current and future values.</ul>"},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_3_3",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>When a new observer subscribes, it will immediately receive the most recent value from the `<code>BehaviorSubject</code>`.</ul>"},{paraid:1,text:'<ol start="4"><li><strong>Emitting New Values</strong></li></ol>'},{paraid:1,text:"<ul>You can emit new values using the `<code>next()</code>` method. All current subscribers will receive these new values.</ul>"},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_3_4",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="5"><li><strong>Getting the Current Value</strong></li></ol>'},{paraid:1,text:"<ul>You can get the current value held by the `<code>BehaviorSubject</code>` without subscribing to it, using the `<code>getValue()</code>` method.</ul>"},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_3_5",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="6"><li><strong>Completing the `<code>BehaviorSubject</code>`</strong></li></ol>'},{paraid:1,text:"<ul>To signal that no more values will be emitted, you can complete the `<code>BehaviorSubject</code>` using the `<code>complete()</code>` method. This will also complete all its observers.</ul>"},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_3_6",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="7"><li><strong>Error Handling</strong></li></ol>'},{paraid:1,text:"<ul>In case of an error, you can use the `<code>error()</code>` method to emit an error notification to all subscribers. This will also complete the `<code>BehaviorSubject</code>`.</ul>"},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_3_7",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:2,text:'<ol start="8"><li><strong>Example of `<code>BehaviorSubject</code>`:</strong></li></ol>'},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_3_8",exampleid:"rxjs_5_3_8_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:9,text:"`<code>BehaviorSubject</code>` is commonly used in scenarios where you want to maintain and share the current state across different parts of your application, such as managing user authentication status, global settings, or any kind of shared data. However, be cautious when using `<code>BehaviorSubject</code>` to avoid unintentionally exposing or modifying your application's state in unexpected ways."}]},{secid:4,subtitle:"ReplaySubject",paragraphs:[{paraid:1,text:"RxJS `<code>ReplaySubject</code>` is a type of subject in RxJS that records a specified number of previous values and replays those values to new subscribers. This makes it useful for scenarios where you want new subscribers to receive a buffered history of emitted values. `<code>ReplaySubject</code>` is particularly handy for implementing caching mechanisms or providing historical data to late subscribers."},{paraid:1,text:"<ol><li><strong>Importing `<code>ReplaySubject</code>`</strong></li></ol>"},{paraid:1,text:"<ul>First, you need to import `<code>ReplaySubject</code>` from the `<code>rxjs</code>` package.</ul>"},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_4_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="2"><li><strong>Creating a `<code>ReplaySubject</code>`</strong></li></ol>'},{paraid:1,text:"<ul>When you instantiate a `<code>ReplaySubject</code>`, you can specify the number of values to replay. Optionally, you can also specify a window time to limit how old the replayed values can be.</ul>"},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_4_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="3"><li><strong>Subscribing Observers</strong></li></ol>'},{paraid:1,text:"<ul>Observers subscribe to the `<code>ReplaySubject</code>` like any other observable. They will receive the last emitted values up to the specified buffer size or within the time window.</ul>"},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_4_3",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="4"><li><strong>Emitting Values</strong></li></ol>'},{paraid:1,text:"<ul>The `<code>ReplaySubject</code>` can emit values using the `<code>next()</code>` method, just like other subjects.</ul>"},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_4_4",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="5"><li><strong>Late Subscriptions</strong></li></ol>'},{paraid:1,text:"<ul>If a new observer subscribes later, it will receive the replayed values immediately upon subscription, according to the buffer size or time window specified.</ul>"},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_4_5",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="6"><li><strong>Completing the `<code>ReplaySubject</code>`</strong></li></ol>'},{paraid:1,text:"<ul>You can complete a `<code>ReplaySubject</code>` using the `<code>complete()</code>` method, signaling that no more values will be emitted.</ul>"},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_4_6",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="7"><li><strong>Error Handling</strong></li></ol>'},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_4_7",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>If there's an error, you can use the `<code>error()</code>` method to emit an error notification to all subscribers. This will also complete the `<code>ReplaySubject</code>`.</ul>"},{paraid:2,text:'<ol start="8"><li><strong>Example of `<code>ReplaySubject</code>`:</strong></li></ol>'},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_4_8",exampleid:"rxjs_5_4_8_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:10,text:"`<code>ReplaySubject</code>` is useful when you want to provide a historical context to subscribers or when you want to implement caching mechanisms where late subscribers can still access the most recent values. Keep in mind that using large buffer sizes with `<code>ReplaySubject</code>` can lead to increased memory usage, so it's important to choose an appropriate buffer size based on your use case."}]},{secid:5,subtitle:"AsyncSubject",paragraphs:[{paraid:1,text:"An `<code>AsyncSubject</code>` is a specialized subject in RxJS that only emits the last value emitted by the source observable when it completes. It's especially useful when you're interested in capturing the final state or result of an asynchronous operation. The `<code>AsyncSubject</code>` emits this value to all its subscribers only when the source observable completes."},{paraid:1,text:"<ol><li><strong>Importing `<code>AsyncSubject</code>`</strong></li></ol>"},{paraid:1,text:"<ul>First, import `<code>AsyncSubject</code>` from the `<code>rxjs</code>` package.</ul>"},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_5_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="2"><li><strong>Creating an `<code>AsyncSubject</code>`</strong></li></ol>'},{paraid:1,text:"<ul>Instantiate a new `<code>AsyncSubject</code>`.</ul>"},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_5_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="3"><li><strong>Subscribing Observers</strong></li></ol>'},{paraid:1,text:"<ul>Observers can subscribe to the `<code>AsyncSubject</code>` just like they would with any other observable. However, they won\u2019t receive any values until the `<code>AsyncSubject</code>` completes.</ul>"},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_5_3",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="4"><li><strong>Emitting Values</strong></li></ol>'},{paraid:1,text:"<ul>You can emit values using the `<code>next()</code>` method. Unlike other subjects, these values will not be immediately relayed to the subscribers.</ul>"},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_5_4",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:'<ol start="5"><li><strong>Completing the `<code>AsyncSubject</code>`</strong></li></ol>'},{paraid:1,text:"<ul>When the `<code>complete()</code>` method is called on the `<code>AsyncSubject</code>`, it emits the last value it received via `<code>next()</code>` to all of its subscribers, and then completes. No further values can be emitted after this.</ul>"},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_5_5",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:1,text:"<ul>Upon completion, all current subscribers will receive the last value. Any observers that subscribe after the completion will also receive the last value immediately upon subscription.</ul>"},{paraid:1,text:'<ol start="6"><li><strong>Error Handling</strong></li></ol>'},{paraid:1,text:"<ul>If the `<code>AsyncSubject</code>` encounters an error by calling the `<code>error()</code>` method, it will emit an error notification to all current and future subscribers and will not emit any value.</ul>"},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_5_6",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"2.5rem"}},{paraid:2,text:'<ol start="7"><li><strong>Example of `<code>AsyncSubject</code>`:</strong></li></ol>'},{paraid:3,text:"",codeConfig:{codeid:"rxjs_5_5_7",exampleid:"rxjs_5_5_7_1",codeOutput:!1,exampleOutput:!0,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",hideExample:!0,marginLeft:"2.5rem"}},{paraid:11,text:"`<code>AsyncSubject</code>` is useful in scenarios where you want to emit a single value representing the final state of an asynchronous operation, such as the result of an HTTP request or the value produced after a sequence of events. It's important to note that the value is only emitted when the source observable completes, so make sure to complete the `<code>AsyncSubject</code>` when you have all the relevant data to emit."}]},{secid:6,subtitle:"Multicasting with Subjects",paragraphs:[{paraid:1,text:"Multicasting with Subjects in RxJS is a mechanism for sharing a single source observable's execution among multiple subscribers. Unlike regular observables, which are unicast and execute independently for each subscriber, multicasting allows multiple subscribers to share the same source observable, thereby conserving resources and potentially avoiding redundant operations. Subjects are a key tool for implementing multicasting in RxJS. Here's a detailed explanation of multicasting with Subjects."},{paraid:2,text:"<ol><li><strong>Unicast vs. Multicast Observables</strong></li></ol>"},{paraid:3,text:"<ul><ul><li><strong>Unicast Observables</strong>: When you subscribe to a regular observable, it creates a separate execution stream for each subscriber. Each subscriber gets its copy of the observable sequence, and they operate independently. This can be resource-intensive and inefficient in some scenarios, especially when dealing with hot observables.</li></ul></ul>"},{paraid:4,text:"<ul><ul><li><strong>Multicast Observables</strong>: With multicasting, multiple subscribers share the same source observable. This means there's only one execution stream of the source observable, and all subscribers receive values from the same stream. This can be more efficient and practical in scenarios where you want to share data among multiple consumers, such as event handling.</li></ul></ul>"},{paraid:5,text:'<ol start="2"><li><strong>Subjects as Multicast Observables</strong></li></ol>'},{paraid:6,text:"<ul><ul><li>Subjects including `<code>Subject</code>`, `<code>BehaviorSubject</code>`, `<code>ReplaySubject</code>`, and `<code>AsyncSubject</code>` are special types of observables that are also observers. They act as bridges or proxies that can multicast values to multiple subscribers.</li></ul></ul>"},{paraid:7,text:'<ol start="3"><li><strong>Implementing Multicasting with Subjects</strong></li></ol>'},{paraid:8,text:"<ul>To implement multicasting with subjects, you typically follow these steps:</ul>"},{paraid:9,text:"<ul><ul><li>Create a subject of your choice (e.g., `<code>Subject</code>`, `<code>BehaviorSubject</code>`, etc.).</li></ul></ul>"},{paraid:10,text:"<ul><ul><li>Subscribe your subject to the source observable you want to multicast.</li></ul></ul>"},{paraid:11,text:"<ul><ul><li>Subscribe multiple observers to the subject.</li></ul></ul>"},{paraid:12,text:"<ul><ul><li>The values emitted by the source observable are now multicast to all subscribers of the subject.</li></ul></ul>"},{paraid:13,text:'<ol start="4"><li><strong>Benefits of Multicasting</strong></li></ol>'},{paraid:14,text:"<ul><ul><li>Efficient resource usage: Multicasting can save resources by sharing a single execution stream.</li></ul></ul>"},{paraid:15,text:"<ul><ul><li>Avoiding redundant work: Some operations, such as making HTTP requests, can be costly, and multicasting helps avoid redundancy.</li></ul></ul>"},{paraid:16,text:"<ul><ul><li>Sharing data among multiple subscribers: Multicasting is essential when you need to broadcast data or events to multiple consumers.</li></ul></ul>"},{paraid:17,text:"Multicasting with Subjects in RxJS is a powerful technique for sharing data and events among multiple subscribers efficiently. It's commonly used in scenarios where you have multiple observers interested in the same data source."}]}]},{category:"rxjs",chid:6,title:"Best Practices and Performance Optimization",sections:[{secid:1,subtitle:"Hot vs. Cold Observables",paragraphs:[{paraid:1,text:"In RxJS, observables can be categorized into two main types: hot and cold observables. Understanding the differences between these two types is crucial for effectively working with reactive programming. Here's an explanation of hot and cold observables:"},{paraid:2,text:"<ol><li><strong>Cold Observables</strong></li></ol>"},{paraid:3,text:"<ul><ul><li><strong>Lazy Execution</strong>: Cold observables are lazy, meaning they don't start emitting values until someone subscribes to them. Each subscription to a cold observable triggers a new execution or production of values.</li></ul></ul>"},{paraid:4,text:"<ul><ul><li><strong>Unicast</strong>: Each subscriber to a cold observable gets its independent stream of data. Subscribers do not share the emitted values. When one subscriber receives a value, it does not affect the emissions received by other subscribers.</li></ul></ul>"},{paraid:5,text:"<ul><ul><li><strong>Examples</strong>: Most operators like `<code>of</code>`, `<code>from</code>`, and HTTP requests in RxJS create cold observables. When you call `<code>of(1, 2, 3)</code>`, it generates a new stream of values for each subscription.</li></ul></ul>"},{paraid:6,text:"",codeConfig:{codeid:"rxjs_6_1_1",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"5rem"}},{paraid:7,text:'<ol start="2"><li><strong>Hot Observables</strong></li></ol>'},{paraid:8,text:"<ul><ul><li><strong>Eager Execution</strong>: Hot observables, on the other hand, emit values regardless of whether there are subscribers or not. They start producing values as soon as they are created, and subscribers may miss some values if they subscribe later.</li></ul></ul>"},{paraid:9,text:"<ul><ul><li><strong>Multicast</strong>: Hot observables are shared among subscribers. When a value is emitted, all subscribers receive that same value. Subscribers share the same stream of data.</li></ul></ul>"},{paraid:10,text:"<ul><ul><li><strong>Examples</strong>: Subjects, WebSocket connections, and DOM events are common sources of hot observables. For instance, when you create a subject, it starts emitting values immediately, and all subscribers share those emissions.</li></ul></ul>"},{paraid:11,text:"",codeConfig:{codeid:"rxjs_6_1_2",exampleid:"",codeOutput:!1,exampleOutput:!1,codeTitle:"RxJS",exampleTitle:"",codeLangs:"ts",exampleLangs:"",codeSource:"",exampleSource:"",marginLeft:"5rem"}},{paraid:12,text:'<ol start="3"><li><strong>Choosing Between Hot and Cold Observables</strong></li></ol>'},{paraid:13,text:"<ul><ul><li><strong>Use Cold Observables When</strong>:</li></ul></ul>"},{paraid:14,text:"<ul><ul>You want each subscriber to receive its independent stream of data.</ul></ul>"},{paraid:15,text:"<ul><ul>Lazy execution is beneficial, and you want to avoid resource consumption until subscribers appear.</ul></ul>"},{paraid:16,text:"<ul><ul>You want to ensure that all subscribers receive all emitted values.</ul></ul>"},{paraid:17,text:"<ul><ul><li><strong>Use Hot Observables When</strong>:</li></ul></ul>"},{paraid:18,text:"<ul><ul>You have a shared source of data that should be observed by multiple subscribers.</ul></ul>"},{paraid:19,text:"<ul><ul>You want to broadcast events, such as user interactions or server updates, to all interested parties.</ul></ul>"},{paraid:20,text:"<ul><ul>Eager execution is suitable for your use case, and it's acceptable for late subscribers to miss earlier values.</ul></ul>"},{paraid:21,text:"In summary, the choice between hot and cold observables depends on the specific requirements of your application and the behavior you want to achieve. Understanding the differences between these two types is essential for designing effective and efficient reactive systems."}]},{secid:2,subtitle:"Performance Optimization Tips",paragraphs:[{paraid:1,text:"Performance optimization is a critical aspect of software development, and it's particularly important in applications that rely heavily on RxJS and reactive programming. Here are some performance optimization tips when working with RxJS:"},{paraid:2,text:"<ol><li><strong>Choose the Right Operators</strong></li></ol>"},{paraid:3,text:"<ul>Select operators that best fit your use case. Some operators are more performant for specific scenarios than others. For example, use `<code>switchMap</code>` instead of `<code>concatMap</code>` if you want to switch to a new inner observable and cancel the previous one.</ul>"},{paraid:4,text:'<ol start="2"><li><strong>Avoid Unnecessary Operations</strong></li></ol>'},{paraid:5,text:"<ul>Be mindful of applying unnecessary operators in your observable chains. Every operator introduces some level of overhead, so only use the ones you need.</ul>"},{paraid:6,text:'<ol start="3"><li><strong>Use `<code>unsubscribe</code>` and Cleanup</strong></li></ol>'},{paraid:7,text:"<ul>Always unsubscribe from observables when they are no longer needed to prevent memory leaks.</ul>"},{paraid:8,text:'<ol start="4"><li><strong>Use Operators for Filtering and Reducing Data</strong></li></ol>'},{paraid:9,text:"<ul>Use operators like `<code>filter</code>`, `<code>take</code>`, and `<code>reduce</code>` to limit the amount of data you process. Filtering out unnecessary data early in the pipeline can significantly improve performance.</ul>"},{paraid:10,text:'<ol start="5"><li><strong>Use Debounce and Throttle</strong></li></ol>'},{paraid:11,text:"<ul>When dealing with user input or frequent events, consider using `<code>debounceTime</code>` and `<code>throttleTime</code>` operators to control the rate of emissions and reduce unnecessary processing.</ul>"},{paraid:12,text:'<ol start="6"><li><strong>Avoid Nesting Observables Unnecessarily</strong></li></ol>'},{paraid:13,text:"<ul>Avoid deeply nested observable chains. Excessive nesting can make your code harder to read and understand, and it can also impact performance.</ul>"},{paraid:14,text:'<ol start="7"><li><strong>Upgrade to the Latest RxJS Version</strong></li></ol>'},{paraid:15,text:"<ul>Keep your RxJS version up to date. Newer versions often include performance improvements and bug fixes.</ul>"},{paraid:16,text:"Remember that performance optimization is often an iterative process, and it's essential to profile and test your application regularly to measure the impact of your optimizations. Prioritize optimization efforts based on the parts of your application that have the most significant impact on user experience."}]}]}];var s=a(4650),be=a(4214);let xe=(()=>{class t{constructor(o){this.coreService=o}ngOnInit(){this.coreService.sentBookData(me)}ngOnDestroy(){}}return t.\u0275fac=function(o){return new(o||t)(s.Y36(be.p))},t.\u0275cmp=s.Xpm({type:t,selectors:[["app-rxjs-book"]],decls:1,vars:0,template:function(o,n){1&o&&s._UZ(0,"router-outlet")},dependencies:[c.lC]}),t})();function e(t,r,o=""){return`<!DOCTYPE html>\n  <html>\n  <head>\n    <style>\n      html { font-size: 16px; }\n      a { text-decoration: none; }\n    </style>\n    <script src="assets/js/utils2.js"><\/script>\n    <script src="https://unpkg.com/rxjs@^7/dist/bundles/rxjs.umd.min.js"><\/script>\n  </head>\n  <body>\n    ${o}\n    <script>\n      ${t.join(" ")}\n      ${r.replace(/import {/g,"//import {")}\n    <\/script>\n  </body>\n  </html>`}const he="node -v\nnpm -v",ge="mkdir rxjs-tutorial\ncd rxjs-tutorial",ve="npm init",fe="npm install rxjs",_e="// main.ts\n// Import RxJS\nimport { from } from 'rxjs';\n\n// Create an observable from an array\nconst numbers = from([1, 2, 3, 4, 5]);\n\n// Subscribe to the observable\nnumbers.subscribe(number => console.log(number));",ye="node main.js",d="import { of } from 'rxjs';\n\n// Creating an Observable from individual values\nconst observable = of(1, 2, 3, 4, 5);\n\n// Subscribing to the Observable\nobservable.subscribe({\n  next: value => console.log(value),\n  complete: () => console.log('Observable complete')\n});",je=e(["const { of } = rxjs;"],d),p="import { from } from 'rxjs';\n\nconst array = [1, 2, 3, 4, 5];\nconst observable = from(array);\n\nobservable.subscribe(value => console.log(value));",we=e(["const { from } = rxjs;"],p),m="import { from } from 'rxjs';\n\nconst promise = fetch('assets/data/json/integer-array.json');\nconst observable = from(promise.then(response => response.json()));\n\nobservable.subscribe(response => console.log(response));",Se=e(["const { from } = rxjs;"],m),b="import { fromEvent } from 'rxjs';\n\nconst button = document.querySelector('button');\nconst clickObservable = fromEvent(button, 'click');\n\nclickObservable.subscribe(event => console.log('Button clicked!'));",Oe=e(["const { fromEvent } = rxjs;"],b,"<button>Click Me!</button>"),x="import { Observable } from 'rxjs';\n\nconst customObservable = new Observable(observer => {\n  observer.next(1);     // Emitting values\n  observer.next(2);\n  observer.complete();  // Completing the observable\n});\n\ncustomObservable.subscribe(\n  value => console.log(value),\n  error => console.error(error),\n  () => console.log('Observable completed')\n);",Te=e(["const { Observable } = rxjs;"],x),h="import { interval } from 'rxjs';\n\nconst intervalObservable = interval(1000); // Emit value every second\n\nconst subscription = intervalObservable.subscribe(value => console.log(value));\n\n// Unsubscribe after 5 seconds \nsetTimeout(() => { \n  subscription.unsubscribe(); \n  console.log('Subscription unsubscribed.'); \n}, 5000);",Re=e(["const { interval } = rxjs;"],h),g="import { interval, queueScheduler, scheduled } from 'rxjs'; \nimport { observeOn } from 'rxjs/operators'; \n\n// Create an Observable that emits values at 1-second intervals \nconst source = interval(1000); \n\n// Use the scheduled operator to change the scheduler to queueScheduler \nconst scheduledSource = scheduled(source, queueScheduler); \n\n// Subscribe to the scheduled Observable \nconst subscription = scheduledSource.subscribe(value => { \n  console.log(`Emitted value: ${value}`); \n}); \n\n// Unsubscribe after 5 seconds \nsetTimeout(() => { \n  subscription.unsubscribe(); \n  console.log('Subscription unsubscribed.'); \n}, 5000);",Le=e(["const { interval, queueScheduler, scheduled } = rxjs;","const { observeOn } = rxjs.operators;"],g),ke="import { Observable } from 'rxjs';\n\nconst observable = new Observable(subscriber => {\n  subscriber.next(1);\n  subscriber.next(2);\n  subscriber.next(3);\n  setTimeout(() => {\n    subscriber.next(4);\n    subscriber.complete();\n  }, 1000);\n});",Ce="observable.subscribe({\n  next(x) { console.log('got value ' + x); },\n  error(err) { console.error('something wrong occurred: ' + err); },\n  complete() { console.log('done'); }\n});",Je="observable.subscribe(\n  x => console.log('got value ' + x),\n  err => console.error('something wrong occurred: ' + err),\n  () => console.log('done')\n);",Ee="const subscription = observable.subscribe(x => console.log(x));\n// Later:\nsubscription.unsubscribe();",v="import { Observable } from 'rxjs';\n\n// Create an observable that emits values\nconst observable = new Observable(observer => {\n  observer.next(1);\n  observer.next(2);\n  observer.next(3);\n  observer.complete(); // Signal that the observable is completed\n});\n\n// Subscribe to the observable\nconst subscription = observable.subscribe(\n  value => console.log(value),     // Handle emitted values\n  error => console.error(error),   // Handle errors\n  () => console.log('Completed')   // Handle completion\n);\n\n// Later, when you're done with the observable, unsubscribe\nsubscription.unsubscribe();",Ie=e(["const { Observable } = rxjs;"],v),f="import { Observable } from 'rxjs';\n\nconst observable = new Observable(observer => {\n  const intervalHandle = setInterval(() => {\n    observer.next('Value');\n  }, 2000);\n\n  // Clean up when unsubscribing\n  return () => {\n    clearInterval(intervalHandle);\n  };\n});\n\nconst subscription = observable.subscribe(value => console.log(value));\n\n// Unsubscribe after 10 seconds\nsetTimeout(() => {\n  subscription.unsubscribe();\n  console.log('Subscription unsubscribed.');\n}, 10000);",Ae=e(["const { Observable } = rxjs;"],f),_="import { Observable } from 'rxjs'; \n\nconst subscriptions = []; \n\n// Create 2 observables \nconst intervalObservable1 = interval(500); \nconst intervalObservable2 = interval(1000); \n\n// Subscribe intervalObservable1 and push subscription1 to subscriptions array \nconst subscription1 = intervalObservable1.subscribe(value => console.log('Subscription 1: ', value)); \nsubscriptions.push(subscription1); \n\n// Subscribe intervalObservable2 and push subscription2 to subscriptions array \nconst subscription2 = intervalObservable2.subscribe(value => console.log('Subscription 2: ', value)); \nsubscriptions.push(subscription2); \n\n// Unsubscribe after 5 seconds \nsetTimeout(() => { \n  for (let i = 0; i < subscriptions.length; i++) { \n    subscriptions[i].unsubscribe(); \n    console.log(`Subscription ${i} unsubscribed.`); \n  } \n}, 5000);",Me=e(["const { interval } = rxjs;"],_),y="import { interval, Subscription } from 'rxjs'; \n\n// Create a Subscription to manage multiple subscriptions \nconst parentSubscription = new Subscription(); \n\n// Create two child subscriptions \nconst subscription1 = interval(1000).subscribe(value => { \n  console.log(`Subscription 1: ${value}`); \n}); \n\nconst subscription2 = interval(1500).subscribe(value => { \n  console.log(`Subscription 2: ${value}`); \n}); \n\n// Add the child subscriptions to the parent Subscription \nparentSubscription.add(subscription1); \nparentSubscription.add(subscription2); \n\n// Unsubscribe after 5 seconds\nsetTimeout(() => {\n  parentSubscription.unsubscribe();\n  console.log('Subscriptions unsubscribed.');\n}, 5000);",Be=e(["const { interval, Subscription } = rxjs;"],y),j="import { interval } from 'rxjs'; \nimport { take } from 'rxjs/operators'; \n\nconst observable = interval(1000); \n\nconst sub = observable.pipe( \n  take(5) // Automatically unsubscribes after receiving 5 values \n).subscribe(value => console.log(`Received value: ${value}`));",He=e(["const { interval } = rxjs;","const { take } = rxjs.operators;"],j),We="const observer = {\n  next: value => console.log('Next:', value),\n  error: error => console.error('Error:', error),\n  complete: () => console.log('Complete')\n};",w="import { Observable } from 'rxjs';\n\nconst observable = new Observable(observer => {\n  observer.next(1);\n  observer.next(2);\n  observer.complete();\n});\n\nconst observer = {\n  next: value => console.log('Next:', value),\n  error: error => console.error('Error:', error),\n  complete: () => console.log('Complete')\n};\n\nobservable.subscribe(observer);",Ue=e(["const { Observable } = rxjs;"],w),S="import { Observable } from 'rxjs';\n\nconst observable = new Observable(observer => {\n  observer.next(1);\n  observer.next(2);\n  observer.complete();\n});\n\nobservable.subscribe(\n  value => console.log('Next:', value),\n  error => console.error('Error:', error),\n  () => console.log('Complete')\n);",qe=e(["const { Observable } = rxjs;"],S),O="import { from } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\nconst source = from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n\nsource.pipe(\n  filter(x => x % 2 === 0) // Filter out even numbers\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",Pe=e(["const { from } = rxjs;","const { filter } = rxjs.operators;"],O),T="import { interval } from 'rxjs';\nimport { take } from 'rxjs/operators';\n\nconst source = interval(1000); // Emits a value every second\n\nsource.pipe(\n  take(5) // Take the first 5 values\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",Ve=e(["const { interval } = rxjs;","const { take } = rxjs.operators;"],T),R="import { of } from 'rxjs';\nimport { takeWhile } from 'rxjs/operators';\n\nconst source = of(1, 2, 3, 4, 5, 6);\n\nsource.pipe(\n  takeWhile(x => x <= 3) // Take values while x is less than or equal to 3\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",$e=e(["const { of } = rxjs;","const { takeWhile } = rxjs.operators;"],R),L="import { interval } from 'rxjs';\nimport { skip, take } from 'rxjs/operators';\n\nconst source = interval(1000); // Emits a value every second\n\nsource.pipe(\n  skip(3), // Skip the first 3 values\n  take(5)  // Take the next 5 values\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",De=e(["const { interval } = rxjs;","const { skip, take } = rxjs.operators;"],L),k="import { of } from 'rxjs';\nimport { skipWhile } from 'rxjs/operators';\n\nconst source = of(1, 2, 3, 4, 5, 6);\n\nsource.pipe(\n  skipWhile(x => x <= 3) // Skip values while x is less than or equal to 3\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",ze=e(["const { of } = rxjs;","const { skipWhile } = rxjs.operators;"],k),C="import { of } from 'rxjs';\nimport { distinctUntilChanged } from 'rxjs/operators';\n\nconst source = of(1, 1, 2, 2, 3, 3, 4, 4, 5);\n\nsource.pipe(\n  distinctUntilChanged() // Filter out consecutive duplicates\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",Fe=e(["const { of } = rxjs;","const { distinctUntilChanged } = rxjs.operators;"],C),J="import { from } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nconst source = from([1, 2, 3, 4, 5]);\n\nsource.pipe(\n  map(x => x * 2) // Double each value\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",Ye=e(["const { from } = rxjs;","const { map } = rxjs.operators;"],J),E="import { from } from 'rxjs';\nimport { pluck } from 'rxjs/operators';\n\nconst source = from([\n  { name: 'Alice', age: 28 },\n  { name: 'Bob', age: 32 },\n  { name: 'Charlie', age: 24 }\n]);\n\nsource.pipe(\n  pluck('name') // Extract the 'name' property from each object\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",Ne=e(["const { from } = rxjs;","const { pluck } = rxjs.operators;"],E),I="import { from } from 'rxjs';\nimport { scan } from 'rxjs/operators';\n\nconst source = from([1, 2, 3, 4, 5]);\n\nsource.pipe(\n  scan((accumulator, currentValue) => accumulator + currentValue, 0) // Calculate the running sum\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",Ke=e(["const { from } = rxjs;","const { scan } = rxjs.operators;"],I),A="import { of } from 'rxjs';\nimport { toArray } from 'rxjs/operators';\n\nconst source = of(1, 2, 3, 4, 5);\n\nsource.pipe(\n  toArray() // Collect values into an array\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",Xe=e(["const { of } = rxjs;","const { toArray } = rxjs.operators;"],A),M="import { interval, merge } from 'rxjs'; \nimport { map, take } from 'rxjs/operators'; \n\nconst source1 = interval(750).pipe(map(x => `A-${x}`), take(5)); \nconst source2 = interval(500).pipe(map(x => `B-${x}`), take(5)); \n\nconst merged = merge(source1, source2); \n\nmerged.subscribe( \n  value => console.log(value), \n  err => console.error(err), \n  () => console.log('Complete') \n);",Qe=e(["const { interval, merge } = rxjs;","const { map, take } = rxjs.operators;"],M),B="import { concat, interval } from 'rxjs'; \nimport { map, take } from 'rxjs/operators'; \n\nconst source1 = interval(750).pipe(map(x => `A-${x}`), take(5)); \nconst source2 = interval(500).pipe(map(x => `B-${x}`), take(5)); \n\nconst concatenated = concat(source1, source2); \n\nconcatenated.subscribe( \n  value => console.log(value), \n  err => console.error(err), \n  () => console.log('Complete') \n);",Ze=e(["const { concat, interval } = rxjs;","const { map, take } = rxjs.operators;"],B),H="import { combineLatest, interval } from 'rxjs'; \nimport { map, take } from 'rxjs/operators'; \n\nconst source1 = interval(750).pipe(map(x => `A-${x}`), take(5)); \nconst source2 = interval(500).pipe(map(x => `B-${x}`), take(5)); \n\nconst combined = combineLatest(source1, source2); \n\ncombined.subscribe( \n  value => console.log(value), \n  err => console.error(err) \n);",Ge=e(["const { combineLatest, interval } = rxjs;","const { map, take } = rxjs.operators;"],H),W="import { forkJoin, of } from 'rxjs';\nimport { delay } from 'rxjs/operators';\n\nconst source1 = of('A').pipe(delay(2000));\nconst source2 = of('B').pipe(delay(1000));\n\nforkJoin([source1, source2]).subscribe(\n  values => console.log(values),\n  err => console.error(err),\n  () => console.log('Complete')\n);",et=e(["const { forkJoin, of } = rxjs;","const { delay } = rxjs.operators;"],W),U="import { of } from 'rxjs';\nimport { startWith } from 'rxjs/operators';\n\nconst source = of(1, 2, 3);\n\nsource.pipe(\n  startWith(0) // Prepend 0 to the values\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",tt=e(["const { of } = rxjs;","const { startWith } = rxjs.operators;"],U),q="import { of } from 'rxjs'; \nimport { every } from 'rxjs/operators'; \n\nconst source = of(2, 4, 6, 8, 10); \n\nsource.pipe( \n  every(x => x % 2 === 0) // Check if all values are even \n).subscribe( \n  result => console.log(`All values are even: ${result}`), \n  err => console.error(err) \n);",ot=e(["const { of } = rxjs;","const { every } = rxjs.operators;"],q),P="import { of } from 'rxjs'; \nimport { find } from 'rxjs/operators'; \n\nconst source = of(1, 2, 3, 4, 5); \n\nsource.pipe( \n  find(x => x > 2) // Find the first value greater than 2 \n).subscribe( \n  result => console.log(`First value greater than 2: ${result}`), \n  err => console.error(err) \n);",rt=e(["const { of } = rxjs;","const { find } = rxjs.operators;"],P),V="import { of } from 'rxjs'; \nimport { findIndex } from 'rxjs/operators'; \n\nconst source = of(10, 20, 30, 40, 50); \n\nsource.pipe( \n  findIndex(x => x > 35) // Find the index of the first value greater than 35 \n).subscribe( \n  result => console.log(`Index of the first value greater than 35: ${result}`), \n  err => console.error(err) \n);",at=e(["const { of } = rxjs;","const { findIndex } = rxjs.operators;"],V),$="import { of } from 'rxjs'; \nimport { isEmpty } from 'rxjs/operators'; \n\nconst source1 = of(); \nconst source2 = of(1, 2, 3); \n\nsource1.pipe( \n  isEmpty() // Check if the Observable is empty \n).subscribe( \n  result => console.log(`Is source1 empty? ${result}`), \n  err => console.error(err) \n); \n\nsource2.pipe( \n  isEmpty() // Check if the Observable is empty \n).subscribe( \n  result => console.log(`Is source2 empty? ${result}`), \n  err => console.error(err) \n);",st=e(["const { of } = rxjs;","const { isEmpty } = rxjs.operators;"],$),D="import { of } from 'rxjs'; \nimport { tap } from 'rxjs/operators'; \n\nconst source = of(1, 2, 3); \n\nsource.pipe( \n  tap(value => console.log(`Logging value: ${value}`)) \n).subscribe( \n  value => console.log(value), \n  err => console.error(err), \n  () => console.log('Complete') \n);",it=e(["const { of } = rxjs;","const { tap } = rxjs.operators;"],D),z="import { of } from 'rxjs';\nimport { delay } from 'rxjs/operators';\n\nconst source = of(1, 2, 3);\n\nsource.pipe(\n  delay(2000) // Delay by 2 seconds\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",nt=e(["const { of } = rxjs;","const { delay } = rxjs.operators;"],z),F="import { of } from 'rxjs';\nimport { finalize } from 'rxjs/operators';\n\nconst source = of(1, 2, 3);\n\nsource.pipe(\n  finalize(() => console.log('Observation complete'))\n).subscribe(\n  value => console.log(value),\n  err => console.error(err)\n);",lt=e(["const { of } = rxjs;","const { finalize } = rxjs.operators;"],F),Y="import { interval } from 'rxjs';\nimport { take, timeout } from 'rxjs/operators';\n\nconst source = interval(1000).pipe(take(10));\n\nsource.pipe(\n  timeout(2000) // Timeout after 2 seconds\n).subscribe(\n  value => console.log(value),\n  err => console.error(err)\n);",ct=e(["const { interval } = rxjs;","const { take, timeout } = rxjs.operators;"],Y),N="import { of, throwError } from 'rxjs'; \nimport { catchError } from 'rxjs/operators'; \n\nconst source = throwError('An error occurred'); \n\nsource.pipe( \n  catchError(error => of(`Error handled: ${error}`)) \n).subscribe( \n  value => console.log(value), \n  err => console.error(`Caught error: ${err}`) \n);",ut=e(["const { of, throwError } = rxjs;","const { catchError } = rxjs.operators;"],N),K="import { of } from 'rxjs'; \nimport { retry, tap } from 'rxjs/operators'; \n\nconst source = of('A', 'B', 'C'); \n\nsource.pipe( \n  tap(value => { \n    if (value === 'C') \n      throw new Error('An error occurred'); \n  }), \n  retry(2) // Retry up to 2 times \n).subscribe( \n  value => console.log(value), \n  err => console.error(err) \n);",dt=e(["const { of } = rxjs;","const { tap, retry } = rxjs.operators;"],K),X="import { of, throwError, timer } from 'rxjs'; \nimport { mergeMap, retryWhen, take } from 'rxjs/operators'; \n\nlet retryCount = 0; \n\nconst source = of('A', 'B', 'C'); \n\nsource.pipe( \n  tap(value => { \n    if (value === 'C') \n      throw new Error('An error occurred'); \n  }), \n  retryWhen(errors => \n    errors.pipe( \n      mergeMap((error, index) => { \n        if (index < 2) { \n          retryCount++; \n          console.error(`Error encountered (${retryCount} retries): ${error}`); \n          return timer(2000); // Retry after a delay \n        } else { \n          return throwError(error); // Stop retrying after 2 retries \n        } \n      }) \n    ) \n  ) \n).subscribe( \n  value => console.log(value), \n  err => console.error(`Final error: ${err}`) \n);",pt=e(["const { of, throwError, timer } = rxjs;","const { mergeMap, retryWhen, take, tap } = rxjs.operators;"],X),Q="import { of } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\n\nconst source = of(1, 2, 3, 4, 5);\n\nsource.pipe(\n  filter(x => x % 2 === 0), // Only even numbers\n  map(x => x * 2)           // Double the values\n).subscribe(result => console.log(result));",mt=e(["const { of } = rxjs;","const { map, filter } = rxjs.operators;"],Q),bt="import { of } from 'rxjs';\n\nconst source = of(1, 2, 3, 4, 5);\n\nsource\n  .filter(x => x % 2 === 0) // Only even numbers\n  .map(x => x * 2)          // Double the values\n  .subscribe(result => console.log(result));",Z="import { interval, of } from 'rxjs'; \nimport { concatMap, map, take } from 'rxjs/operators'; \n\n// Create an observable that emits 1, 2, and 3 \nconst source = of(1, 2, 3); \n\nsource.pipe( \n  concatMap(value => \n    // Create an interval observable that emits a value every 1000 milliseconds \n    interval(1000).pipe( \n      take(3), // Take the first three emissions from the interval observable \n      map(innerValue => `Source: ${value}, Inner: ${innerValue}`) \n    ) \n  ) \n).subscribe(result => console.log(result));",xt=e(["const { of, interval } = rxjs;","const { concatMap, map, take } = rxjs.operators;"],Z),G="import { of } from 'rxjs'; \nimport { delay, mergeMap } from 'rxjs/operators'; \n\n// Create an observable that emits 1, 2, and 3 \nconst source = of(1, 2, 3); \n\nsource.pipe( \n  mergeMap(value => \n    of(`Processed: ${value}`).pipe( \n      delay(1000 / value) // Simulate some async processing. The value takes on 1, 2, and 3 respectively \n    ) \n  ) \n).subscribe(result => console.log(result));",ht=e(["const { of } = rxjs;","const { delay, mergeMap } = rxjs.operators;"],G),ee="import { interval, of } from 'rxjs'; \nimport { map, switchMap, take } from 'rxjs/operators'; \n\n// Create an observable that emits 1, 2, and 3 \nconst source = of(1, 2, 3); \n\nsource.pipe( \n  switchMap(value => \n    // Create an interval observable that emits a value every 1000 milliseconds \n    interval(1000).pipe( \n      take(3), // Take the first three emissions from the interval observable \n      map(innerValue => `Source: ${value}, Inner: ${innerValue}`) \n    ) \n  ) \n).subscribe(result => console.log(result));",gt=e(["const { interval, of  } = rxjs;","const { map, switchMap, take } = rxjs.operators;"],ee),te="import { interval, of } from 'rxjs'; \nimport { exhaustMap, take } from 'rxjs/operators'; \n\n// Source observable emits values 1, 2, 3 \nconst source = of(1, 2, 3); \n\nsource.pipe( \n  exhaustMap(value => { \n    // Inner observable emits values based on source value \n    return interval(1000).pipe( \n      take(3), // Limit inner observable to emit 3 values \n      map(innerValue => `${value}-${innerValue}`) \n    ); \n  }) \n) \n.subscribe(result => { \n  console.log(result); \n});",vt=e(["const { interval, of  } = rxjs;","const { map, exhaustMap, take } = rxjs.operators;"],te),oe="import { fromEvent } from 'rxjs'; \nimport { debounceTime, map } from 'rxjs/operators'; \n\n// Create an observable from input events (e.g., user typing) \nconst input = document.getElementById('search-input'); \nconst inputs = fromEvent(input, 'input'); \n\ninputs.pipe( \n  debounceTime(300), // Wait for 300 milliseconds of inactivity \n  map(event => event.target.value) \n).subscribe(value => console.log('Input Value:', value));",ft=e(["const { fromEvent  } = rxjs;","const { debounceTime, map } = rxjs.operators;"],oe,'<label>Key in rapidly! </label><input id="search-input">'),re="import { fromEvent } from 'rxjs'; \nimport { map, throttleTime } from 'rxjs/operators'; \n\n// Create an observable from mousemove events \nconst mousemove = fromEvent(document, 'mousemove'); \n\nmousemove.pipe( \n  throttleTime(1000), // Allow one event per 1000 milliseconds \n  map(event => `Mouse Position: (${event.clientX}, ${event.clientY})`) \n).subscribe(position => console.log(position));",_t=e(["const { fromEvent  } = rxjs;","const { map, throttleTime } = rxjs.operators;"],re,"<p>Move mouse in this area!</p>"),ae="import { fromEvent, interval } from 'rxjs'; \nimport { buffer, take } from 'rxjs/operators'; \n\n// Create a source observable that emits values every 500ms \nconst source = interval(500).pipe(take(20)); \n\n// Create a signal observable that emits values every 2000ms (2 seconds) \nconst signal = interval(2000).pipe(take(5)); \n\n// Use buffer to collect values from the source based on the signal \nconst bufferedSource = source.pipe(buffer(signal)); \n\n// Subscribe to the buffered source \nbufferedSource.subscribe(buffer => { \n  console.log('Buffered Values:', buffer); \n});",yt=e(["const { fromEvent, interval } = rxjs;","const { buffer, take } = rxjs.operators;"],ae),se="import { interval } from 'rxjs'; \nimport { mergeAll, take, window as win } from 'rxjs/operators'; \n\n// Create a source observable that emits values every 500ms \nconst source = interval(500); \n\n// Create a boundary observable that emits values every 2000ms (2 seconds) \nconst boundary = interval(2000); \n\n// Use window to create windows based on the boundary \nconst windowedSource = source.pipe(win(boundary)); \n\n// Merge all windows into a single observable \nconst mergedWindows = windowedSource.pipe(mergeAll()); \n\n// Take the first 3 values from each window \nconst result = mergedWindows.pipe(take(9)); \n\n// Subscribe to the result \nresult.subscribe(value => { \n  console.log('Value:', value); \n});",jt=e(["const { interval } = rxjs;","const { mergeAll, take, window: win } = rxjs.operators;"],se),ie="import { of, pipe } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\n\n// The customOperator function is defined, taking a predicate as an argument\nconst customOperator = (predicate) => pipe(\n  filter(predicate),\n  map(value => value * 2)\n);\n\n// An observable named source is defined\nconst source = of(2, 4, 6, 8, 10);\n\n// The customOperator is applied to the source observable with a predicate function\nsource.pipe(\n  customOperator(x => x > 5)\n).subscribe(result => {\n  console.log(result);// Output: 12, 16, 20\n});",wt=e(["const { of, pipe } = rxjs;","const { filter, map } = rxjs.operators;"],ie),ne="import { Observable } from 'rxjs';\n\n// Define the custom operator function\nfunction multiplyBy(factor) {\n  // Return a function that takes the source observable as an argument\n  return (source) => {\n    // Create and return a new observable\n    return new Observable((observer) => {\n      // Subscribe to the source observable\n      const subscription = source.subscribe({\n        next(value) {\n          // Multiply the value by the specified factor\n          const result = value * factor;\n          // Emit the transformed value\n          observer.next(result);\n        },\n        error(error) {\n          // Pass along any errors\n          observer.error(error);\n        },\n        complete() {\n          // Complete the observer when the source completes\n          observer.complete();\n        },\n      });\n\n      // Return a cleanup function to unsubscribe from the source\n      return () => {\n        subscription.unsubscribe();\n      };\n    });\n  };\n}\n\n// Create an example observable\nconst source = new Observable((observer) => {\n  observer.next(1);\n  observer.next(2);\n  observer.next(3);\n  observer.complete();\n});\n\n// Use the custom operator\nsource.pipe(\n  multiplyBy(10) // Multiply each value by 10\n).subscribe((result) => {\n  console.log(result); // Output: 10, 20, 30\n});",St=e(["const { Observable } = rxjs;"],ne),Ot="import { Subject } from 'rxjs';",Tt="const subject = new Subject();",Rt="subject.subscribe(data => console.log(`Observer 1: ${data}`)); \nsubject.subscribe(data => console.log(`Observer 2: ${data}`));",Lt="subject.next('Hello');\nsubject.next('World');",kt="subject.complete();",Ct="subject.error(new Error('Something went wrong'));",le="import { Subject } from 'rxjs'; \n\n// Create a new Subject \nconst subject = new Subject(); \n\n// Subscribe multiple observers to the Subject \nsubject.subscribe({ \n  next: value => console.log(`Observer A: ${value}`) \n}); \n\nsubject.subscribe({ \n  next: value => console.log(`Observer B: ${value}`) \n}); \n\n// Emit values from the Subject \nsubject.next(1); // Emits to both Observer A and Observer B \nsubject.next(2); // Emits to both Observer A and Observer B",Jt=e(["const { Subject } = rxjs;"],le),Et="import { BehaviorSubject } from 'rxjs';",It="const behaviorSubject = new BehaviorSubject('Initial Value');",At="behaviorSubject.subscribe(value => console.log(`Observer 1: ${value}`));",Mt="behaviorSubject.next('New Value');",Bt="const currentValue = behaviorSubject.getValue();",Ht="behaviorSubject.complete();",Wt="behaviorSubject.error(new Error('An error occurred'));",ce="import { BehaviorSubject } from 'rxjs';\n\n// Create a BehaviorSubject with an initial value\nconst behaviorSubject = new BehaviorSubject('Initial value');\n\n// Subscribe to the BehaviorSubject\nbehaviorSubject.subscribe(value => console.log('Observer 1:', value)); // Outputs: Observer 1: Initial value\n\n// Emit a new value\nbehaviorSubject.next('New value'); // Outputs: Observer 1: New value\n\n// Subscribe to the BehaviorSubject after a value has been emitted\nbehaviorSubject.subscribe(value => console.log('Observer 2:', value)); // Outputs: Observer 2: New value",Ut=e(["const { BehaviorSubject } = rxjs;"],ce),qt="import { ReplaySubject } from 'rxjs';",Pt="// This will replay the last 3 values to new subscribers\nconst replaySubject = new ReplaySubject(3);\n\n// This will replay the last 2 values within a 500ms time window\nconst timedReplaySubject = new ReplaySubject(2, 500);",Vt="replaySubject.subscribe(data => console.log(`Observer 1: ${data}`));",$t="replaySubject.next('Value 1');\nreplaySubject.next('Value 2');\nreplaySubject.next('Value 3');",Dt="// This new observer will receive the last 3 values immediately. \nreplaySubject.subscribe(data => console.log(`Observer 2: ${data}`));",zt="replaySubject.complete();",Ft="replaySubject.error(new Error('Something went wrong'));",ue="import { ReplaySubject } from 'rxjs';\n\n// Create a ReplaySubject that replays the last 2 values\nconst replaySubject = new ReplaySubject(2);\n\n// Emit values to the ReplaySubject\nreplaySubject.next('Value 1');\nreplaySubject.next('Value 2');\nreplaySubject.next('Value 3');\n\n// Subscribe to the ReplaySubject\nreplaySubject.subscribe(value => console.log('Observer 1:', value)); // Outputs: Observer 1: Value 2, Observer 1: Value 3\n\n// Emit another value\nreplaySubject.next('Value 4');\n\n// Subscribe to the ReplaySubject after values have been emitted\nreplaySubject.subscribe(value => console.log('Observer 2:', value)); // Outputs: Observer 2: Value 3, Observer 2: Value 4",Yt=e(["const { ReplaySubject } = rxjs;"],ue),Nt="import { AsyncSubject } from 'rxjs';",Kt="const asyncSubject = new AsyncSubject();",Xt="asyncSubject.subscribe(value => console.log(`Observer 1: ${value}`));",Qt="asyncSubject.next('First Value');\nasyncSubject.next('Second Value');",Zt="asyncSubject.complete();",Gt="asyncSubject.error(new Error('Something went wrong'));",de="import { AsyncSubject } from 'rxjs';\n\n// Create an AsyncSubject\nconst asyncSubject = new AsyncSubject();\n\n// Subscribe to the AsyncSubject\nasyncSubject.subscribe(value => console.log('Observer 1:', value));\n\n// Emit values to the AsyncSubject\nasyncSubject.next('Value 1');\nasyncSubject.next('Value 2');\n\n// Complete the AsyncSubject\nasyncSubject.complete();\n\n// Subscribe to the AsyncSubject after completion\nasyncSubject.subscribe(value => console.log('Observer 2:', value)); // Outputs: Observer 2: Value 2",eo=e(["const { AsyncSubject } = rxjs;"],de),to="import { of } from 'rxjs';\n\nconst coldObservable = of(1, 2, 3);\n\n// Subscribers get independent streams\ncoldObservable.subscribe(value => console.log('Subscriber A:', value));\ncoldObservable.subscribe(value => console.log('Subscriber B:', value));",oo="import { Subject } from 'rxjs';\n\nconst hotObservable = new Subject();\n\nhotObservable.subscribe(value => console.log('Subscriber A:', value));\nhotObservable.subscribe(value => console.log('Subscriber B:', value));\n\nhotObservable.next(1); // Both subscribers receive the same value";var ro=a(7359);let i=(()=>{class t{constructor(){this.bookData=l}}return t.\u0275fac=function(o){return new(o||t)},t.\u0275cmp=s.Xpm({type:t,selectors:[["app-rxjs-chapter"]],decls:1,vars:1,consts:[[3,"bookData"]],template:function(o,n){1&o&&s._UZ(0,"app-chapter",0),2&o&&s.Q6J("bookData",n.bookData)},dependencies:[ro.l]}),t})();const ao=[{path:"",component:xe,children:[{path:"chapter",component:i},{path:"chapter/:chid",component:i},{path:"chapter/:chid/section/:secid",component:i},{path:"**",component:i},{path:"",component:i}]}];let so=(()=>{class t{}return t.\u0275fac=function(o){return new(o||t)},t.\u0275mod=s.oAB({type:t}),t.\u0275inj=s.cJS({imports:[c.Bz.forChild(ao),c.Bz]}),t})();var io=a(1375);let no=(()=>{class t{}return t.\u0275fac=function(o){return new(o||t)},t.\u0275mod=s.oAB({type:t}),t.\u0275inj=s.cJS({imports:[pe.ez,so,io.I]}),t})()}}]);