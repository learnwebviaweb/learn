"use strict";(self.webpackChunkweb_building=self.webpackChunkweb_building||[]).push([[60],{8060:(Xr,b,c)=>{c.r(b),c.d(b,{RxjsBookModule:()=>Dr});var i={};c.r(i),c.d(i,{rxjs_1_1_1:()=>he,rxjs_1_1_2:()=>de,rxjs_1_1_3:()=>ge,rxjs_1_1_4:()=>ye,rxjs_1_1_5:()=>Se,rxjs_1_1_6:()=>Ce,rxjs_2_2_1:()=>j,rxjs_2_2_1_1:()=>Oe,rxjs_2_2_2:()=>m,rxjs_2_2_2_1:()=>ke,rxjs_2_2_3:()=>v,rxjs_2_2_3_1:()=>we,rxjs_2_2_4:()=>f,rxjs_2_2_4_1:()=>Ee,rxjs_2_2_5:()=>h,rxjs_2_2_5_1:()=>$e,rxjs_2_2_6:()=>d,rxjs_2_2_6_1:()=>Ae,rxjs_2_2_7:()=>g,rxjs_2_2_7_1:()=>Be,rxjs_2_3_1:()=>y,rxjs_2_3_1_1:()=>Re,rxjs_2_4_1:()=>S,rxjs_2_4_1_1:()=>Te,rxjs_2_4_2:()=>C,rxjs_2_4_2_1:()=>Me,rxjs_2_4_3:()=>O,rxjs_2_4_3_1:()=>Ie,rxjs_2_4_4:()=>k,rxjs_2_4_4_1:()=>Ve,rxjs_2_5_1:()=>Ye,rxjs_2_5_2:()=>w,rxjs_2_5_2_1:()=>Je,rxjs_2_5_3:()=>E,rxjs_2_5_3_1:()=>Ue,rxjs_3_2_1:()=>$,rxjs_3_2_1_1:()=>Qe,rxjs_3_2_2:()=>A,rxjs_3_2_2_1:()=>Fe,rxjs_3_2_3:()=>B,rxjs_3_2_3_1:()=>We,rxjs_3_2_4:()=>R,rxjs_3_2_4_1:()=>De,rxjs_3_2_5:()=>T,rxjs_3_2_5_1:()=>Ne,rxjs_3_2_6:()=>M,rxjs_3_2_6_1:()=>Ze,rxjs_3_3_1:()=>I,rxjs_3_3_1_1:()=>He,rxjs_3_3_2:()=>V,rxjs_3_3_2_1:()=>Le,rxjs_3_3_3:()=>Y,rxjs_3_3_3_1:()=>ze,rxjs_3_3_4:()=>J,rxjs_3_3_4_1:()=>Pe,rxjs_3_4_1:()=>U,rxjs_3_4_1_1:()=>Xe,rxjs_3_4_2:()=>Q,rxjs_3_4_2_1:()=>Ke,rxjs_3_4_3:()=>F,rxjs_3_4_3_1:()=>Ge,rxjs_3_4_4:()=>W,rxjs_3_4_4_1:()=>qe,rxjs_3_4_5:()=>D,rxjs_3_4_5_1:()=>er,rxjs_3_5_1:()=>N,rxjs_3_5_1_1:()=>rr,rxjs_3_5_2:()=>Z,rxjs_3_5_2_1:()=>or,rxjs_3_5_3:()=>H,rxjs_3_5_3_1:()=>sr,rxjs_3_5_4:()=>L,rxjs_3_5_4_1:()=>nr,rxjs_3_6_1:()=>z,rxjs_3_6_1_1:()=>tr,rxjs_3_6_2:()=>P,rxjs_3_6_2_1:()=>cr,rxjs_3_6_3:()=>X,rxjs_3_6_3_1:()=>ar,rxjs_3_6_4:()=>K,rxjs_3_6_4_1:()=>lr,rxjs_3_7_1:()=>G,rxjs_3_7_1_1:()=>_r,rxjs_3_7_2:()=>q,rxjs_3_7_2_1:()=>ir,rxjs_3_7_3:()=>ee,rxjs_3_7_3_1:()=>ur,rxjs_3_8_1:()=>re,rxjs_3_8_1_1:()=>pr,rxjs_3_8_2:()=>br,rxjs_4_1_1:()=>oe,rxjs_4_1_1_1:()=>xr,rxjs_4_2_1:()=>se,rxjs_4_2_1_1:()=>jr,rxjs_4_3_1:()=>ne,rxjs_4_3_1_1:()=>mr,rxjs_4_4_1:()=>te,rxjs_4_4_1_1:()=>vr,rxjs_4_5_1:()=>ce,rxjs_4_5_1_1:()=>fr,rxjs_4_6_1:()=>ae,rxjs_4_6_1_1:()=>hr,rxjs_4_7_1:()=>le,rxjs_4_7_1_1:()=>dr,rxjs_4_8_1:()=>_e,rxjs_4_8_1_1:()=>gr,rxjs_4_9_1:()=>ie,rxjs_4_9_1_1:()=>yr,rxjs_4_9_2:()=>ue,rxjs_4_9_2_1:()=>Sr,rxjs_5_2_1:()=>pe,rxjs_5_2_1_1:()=>Cr,rxjs_5_3_1:()=>be,rxjs_5_3_1_1:()=>Or,rxjs_5_4_1:()=>xe,rxjs_5_4_1_1:()=>kr,rxjs_5_5_1:()=>je,rxjs_5_5_1_1:()=>wr,rxjs_6_1_1:()=>Er,rxjs_6_1_2:()=>$r});var _=c(6895),a=c(9299),e=c(4650),x=c(4214);let ve=(()=>{class o{constructor(s){this.coreService=s}ngOnInit(){this.coreService.getRxjsBookData()}ngOnDestroy(){}}return o.\u0275fac=function(s){return new(s||o)(e.Y36(x.p))},o.\u0275cmp=e.Xpm({type:o,selectors:[["app-rxjs-book"]],decls:1,vars:0,template:function(s,t){1&s&&e._UZ(0,"router-outlet")},dependencies:[a.lC]}),o})();var fe=c(9117);function r(o,n,s=""){return`<!DOCTYPE html>\n  <html>\n  <head>\n    <style>\n      html { font-size: 16px; }\n      a { text-decoration: none; }\n    </style>\n    <script src="assets/js/utils2.js"><\/script>\n    <script src="https://unpkg.com/rxjs@^7/dist/bundles/rxjs.umd.min.js"><\/script>\n  </head>\n  <body>\n    ${s}\n    <script>\n      ${o.join(" ")}\n      ${n.replace(/import {/g,"//import {")}\n    <\/script>\n  </body>\n  </html>`}const he="node -v\nnpm -v",de="mkdir rxjs-tutorial\ncd rxjs-tutorial",ge="npm init",ye="npm install rxjs",Se="// main.ts\n// Import RxJS\nimport { from } from 'rxjs';\n\n// Create an observable from an array\nconst numbers = from([1, 2, 3, 4, 5]);\n\n// Subscribe to the observable\nnumbers.subscribe(number => console.log(number));",Ce="node main.js",j="import { of } from 'rxjs';\n\n// Creating an Observable from individual values\nconst observable = of(1, 2, 3, 4, 5);\n\n// Subscribing to the Observable\nobservable.subscribe({\n  next: value => console.log(value),\n  complete: () => console.log('Observable complete')\n});",Oe=r(["const { of } = rxjs;"],j),m="import { from } from 'rxjs';\n\nconst array = [1, 2, 3, 4, 5];\nconst observable = from(array);\n\nobservable.subscribe(value => console.log(value));",ke=r(["const { from } = rxjs;"],m),v="import { from } from 'rxjs';\n\nconst promise = fetch('assets/data/json/integer-array.json');\nconst observable = from(promise.then(response => response.json()));\n\nobservable.subscribe(response => console.log(response));",we=r(["const { from } = rxjs;"],v),f="import { fromEvent } from 'rxjs';\n\nconst button = document.querySelector('button');\nconst clickObservable = fromEvent(button, 'click');\n\nclickObservable.subscribe(event => console.log('Button clicked!'));",Ee=r(["const { fromEvent } = rxjs;"],f,"<button>Click Me!</button>"),h="import { Observable } from 'rxjs';\n\nconst customObservable = new Observable(observer => {\n  observer.next(1);     // Emitting values\n  observer.next(2);\n  observer.complete();  // Completing the observable\n});\n\ncustomObservable.subscribe(\n  value => console.log(value),\n  error => console.error(error),\n  () => console.log('Observable completed')\n);",$e=r(["const { Observable } = rxjs;"],h),d="import { interval } from 'rxjs';\n\nconst intervalObservable = interval(1000); // Emit value every second\n\nconst subscription = intervalObservable.subscribe(value => console.log(value));\n\n// Unsubscribe after 5 seconds \nsetTimeout(() => { \n  subscription.unsubscribe(); \n  console.log('Subscription unsubscribed.'); \n}, 5000);",Ae=r(["const { interval } = rxjs;"],d),g="import { interval, queueScheduler, scheduled } from 'rxjs'; \nimport { observeOn } from 'rxjs/operators'; \n\n// Create an Observable that emits values at 1-second intervals \nconst source = interval(1000); \n\n// Use the scheduled operator to change the scheduler to queueScheduler \nconst scheduledSource = scheduled([source], queueScheduler); \n\n// Subscribe to the scheduled Observable \nconst subscription = scheduledSource.subscribe(value => { \n  console.log(`Emitted value: ${value}`); \n}); \n\n// Unsubscribe after 5 seconds \nsetTimeout(() => { \n  subscription.unsubscribe(); \n  console.log('Subscription unsubscribed.'); \n}, 5000);",Be=r(["const { interval, queueScheduler, scheduled } = rxjs;","const { observeOn } = rxjs.operators;"],g),y="import { Observable } from 'rxjs';\n\n// Create an observable that emits values\nconst observable = new Observable(observer => {\n  observer.next(1);\n  observer.next(2);\n  observer.next(3);\n  observer.complete(); // Signal that the observable is completed\n});\n\n// Subscribe to the observable\nconst subscription = observable.subscribe(\n  value => console.log(value),     // Handle emitted values\n  error => console.error(error),   // Handle errors\n  () => console.log('Completed')   // Handle completion\n);\n\n// Later, when you're done with the observable, unsubscribe\nsubscription.unsubscribe();",Re=r(["const { Observable } = rxjs;"],y),S="import { Observable } from 'rxjs';\n\nconst observable = new Observable(observer => {\n  const intervalHandle = setInterval(() => {\n    observer.next('Value');\n  }, 2000);\n\n  // Clean up when unsubscribing\n  return () => {\n    clearInterval(intervalHandle);\n  };\n});\n\nconst subscription = observable.subscribe(value => console.log(value));\n\n// Unsubscribe after 10 seconds\nsetTimeout(() => {\n  subscription.unsubscribe();\n  console.log('Subscription unsubscribed.');\n}, 10000);",Te=r(["const { Observable } = rxjs;"],S),C="import { Observable } from 'rxjs'; \n\nconst subscriptions = []; \n\n// Create 2 observables \nconst intervalObservable1 = interval(500); \nconst intervalObservable2 = interval(1000); \n\n// Subscribe intervalObservable1 and push subscription1 to subscriptions array \nconst subscription1 = intervalObservable1.subscribe(value => console.log('Subscription 1: ', value)); \nsubscriptions.push(subscription1); \n\n// Subscribe intervalObservable2 and push subscription2 to subscriptions array \nconst subscription2 = intervalObservable2.subscribe(value => console.log('Subscription 2: ', value)); \nsubscriptions.push(subscription2); \n\n// Unsubscribe after 5 seconds \nsetTimeout(() => { \n  for (let i = 0; i < subscriptions.length; i++) { \n    subscriptions[i].unsubscribe(); \n    console.log(`Subscription ${i} unsubscribed.`); \n  } \n}, 5000);",Me=r(["const { interval } = rxjs;"],C),O="import { interval, Subscription } from 'rxjs'; \n\n// Create a Subscription to manage multiple subscriptions \nconst parentSubscription = new Subscription(); \n\n// Create two child subscriptions \nconst subscription1 = interval(1000).subscribe(value => { \n  console.log(`Subscription 1: ${value}`); \n}); \n\nconst subscription2 = interval(1500).subscribe(value => { \n  console.log(`Subscription 2: ${value}`); \n}); \n\n// Add the child subscriptions to the parent Subscription \nparentSubscription.add(subscription1); \nparentSubscription.add(subscription2); \n\n// Unsubscribe after 5 seconds\nsetTimeout(() => {\n  parentSubscription.unsubscribe();\n  console.log('Subscriptions unsubscribed.');\n}, 5000);",Ie=r(["const { interval, Subscription } = rxjs;"],O),k="import { interval } from 'rxjs'; \nimport { take } from 'rxjs/operators'; \n\nconst observable = interval(1000); \n\nconst sub = observable.pipe( \n  take(5) // Automatically unsubscribes after receiving 5 values \n).subscribe(value => console.log(`Received value: ${value}`));",Ve=r(["const { interval } = rxjs;","const { take } = rxjs.operators;"],k),Ye="const observer = {\n  next: value => console.log('Next:', value),\n  error: error => console.error('Error:', error),\n  complete: () => console.log('Complete')\n};",w="import { Observable } from 'rxjs';\n\nconst observable = new Observable(observer => {\n  observer.next(1);\n  observer.next(2);\n  observer.complete();\n});\n\nconst observer = {\n  next: value => console.log('Next:', value),\n  error: error => console.error('Error:', error),\n  complete: () => console.log('Complete')\n};\n\nobservable.subscribe(observer);",Je=r(["const { Observable } = rxjs;"],w),E="import { Observable } from 'rxjs';\n\nconst observable = new Observable(observer => {\n  observer.next(1);\n  observer.next(2);\n  observer.complete();\n});\n\nobservable.subscribe(\n  value => console.log('Next:', value),\n  error => console.error('Error:', error),\n  () => console.log('Complete')\n);",Ue=r(["const { Observable } = rxjs;"],E),$="import { from } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\nconst source = from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n\nsource.pipe(\n  filter(x => x % 2 === 0) // Filter out even numbers\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",Qe=r(["const { from } = rxjs;","const { filter } = rxjs.operators;"],$),A="import { interval } from 'rxjs';\nimport { take } from 'rxjs/operators';\n\nconst source = interval(1000); // Emits a value every second\n\nsource.pipe(\n  take(5) // Take the first 5 values\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",Fe=r(["const { interval } = rxjs;","const { take } = rxjs.operators;"],A),B="import { of } from 'rxjs';\nimport { takeWhile } from 'rxjs/operators';\n\nconst source = of(1, 2, 3, 4, 5, 6);\n\nsource.pipe(\n  takeWhile(x => x <= 3) // Take values while x is less than or equal to 3\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",We=r(["const { of } = rxjs;","const { takeWhile } = rxjs.operators;"],B),R="import { interval } from 'rxjs';\nimport { skip, take } from 'rxjs/operators';\n\nconst source = interval(1000); // Emits a value every second\n\nsource.pipe(\n  skip(3), // Skip the first 3 values\n  take(5)  // Take the next 5 values\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",De=r(["const { interval } = rxjs;","const { skip, take } = rxjs.operators;"],R),T="import { of } from 'rxjs';\nimport { skipWhile } from 'rxjs/operators';\n\nconst source = of(1, 2, 3, 4, 5, 6);\n\nsource.pipe(\n  skipWhile(x => x <= 3) // Skip values while x is less than or equal to 3\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",Ne=r(["const { of } = rxjs;","const { skipWhile } = rxjs.operators;"],T),M="import { of } from 'rxjs';\nimport { distinctUntilChanged } from 'rxjs/operators';\n\nconst source = of(1, 1, 2, 2, 3, 3, 4, 4, 5);\n\nsource.pipe(\n  distinctUntilChanged() // Filter out consecutive duplicates\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",Ze=r(["const { of } = rxjs;","const { distinctUntilChanged } = rxjs.operators;"],M),I="import { from } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nconst source = from([1, 2, 3, 4, 5]);\n\nsource.pipe(\n  map(x => x * 2) // Double each value\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",He=r(["const { from } = rxjs;","const { map } = rxjs.operators;"],I),V="import { from } from 'rxjs';\nimport { pluck } from 'rxjs/operators';\n\nconst source = from([\n  { name: 'Alice', age: 28 },\n  { name: 'Bob', age: 32 },\n  { name: 'Charlie', age: 24 }\n]);\n\nsource.pipe(\n  pluck('name') // Extract the 'name' property from each object\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",Le=r(["const { from } = rxjs;","const { pluck } = rxjs.operators;"],V),Y="import { from } from 'rxjs';\nimport { scan } from 'rxjs/operators';\n\nconst source = from([1, 2, 3, 4, 5]);\n\nsource.pipe(\n  scan((accumulator, currentValue) => accumulator + currentValue, 0) // Calculate the running sum\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",ze=r(["const { from } = rxjs;","const { scan } = rxjs.operators;"],Y),J="import { of } from 'rxjs';\nimport { toArray } from 'rxjs/operators';\n\nconst source = of(1, 2, 3, 4, 5);\n\nsource.pipe(\n  toArray() // Collect values into an array\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",Pe=r(["const { of } = rxjs;","const { toArray } = rxjs.operators;"],J),U="import { interval, merge } from 'rxjs'; \nimport { map, take } from 'rxjs/operators'; \n\nconst source1 = interval(750).pipe(map(x => `A-${x}`), take(5)); \nconst source2 = interval(500).pipe(map(x => `B-${x}`), take(5)); \n\nconst merged = merge(source1, source2); \n\nmerged.subscribe( \n  value => console.log(value), \n  err => console.error(err), \n  () => console.log('Complete') \n);",Xe=r(["const { interval, merge } = rxjs;","const { map, take } = rxjs.operators;"],U),Q="import { concat, interval } from 'rxjs'; \nimport { map, take } from 'rxjs/operators'; \n\nconst source1 = interval(750).pipe(map(x => `A-${x}`), take(5)); \nconst source2 = interval(500).pipe(map(x => `B-${x}`), take(5)); \n\nconst concatenated = concat(source1, source2); \n\nconcatenated.subscribe( \n  value => console.log(value), \n  err => console.error(err), \n  () => console.log('Complete') \n);",Ke=r(["const { concat, interval } = rxjs;","const { map, take } = rxjs.operators;"],Q),F="import { combineLatest, interval } from 'rxjs'; \nimport { map, take } from 'rxjs/operators'; \n\nconst source1 = interval(750).pipe(map(x => `A-${x}`), take(5)); \nconst source2 = interval(500).pipe(map(x => `B-${x}`), take(5)); \n\nconst combined = combineLatest(source1, source2); \n\ncombined.subscribe( \n  value => console.log(value), \n  err => console.error(err) \n);",Ge=r(["const { combineLatest, interval } = rxjs;","const { map, take } = rxjs.operators;"],F),W="import { forkJoin, of } from 'rxjs';\nimport { delay } from 'rxjs/operators';\n\nconst source1 = of('A').pipe(delay(2000));\nconst source2 = of('B').pipe(delay(1000));\n\nforkJoin([source1, source2]).subscribe(\n  values => console.log(values),\n  err => console.error(err),\n  () => console.log('Complete')\n);",qe=r(["const { forkJoin, of } = rxjs;","const { delay } = rxjs.operators;"],W),D="import { of } from 'rxjs';\nimport { startWith } from 'rxjs/operators';\n\nconst source = of(1, 2, 3);\n\nsource.pipe(\n  startWith(0) // Prepend 0 to the values\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",er=r(["const { of } = rxjs;","const { startWith } = rxjs.operators;"],D),N="import { of } from 'rxjs'; \nimport { every } from 'rxjs/operators'; \n\nconst source = of(2, 4, 6, 8, 10); \n\nsource.pipe( \n  every(x => x % 2 === 0) // Check if all values are even \n).subscribe( \n  result => console.log(`All values are even: ${result}`), \n  err => console.error(err) \n);",rr=r(["const { of } = rxjs;","const { every } = rxjs.operators;"],N),Z="import { of } from 'rxjs'; \nimport { find } from 'rxjs/operators'; \n\nconst source = of(1, 2, 3, 4, 5); \n\nsource.pipe( \n  find(x => x > 2) // Find the first value greater than 2 \n).subscribe( \n  result => console.log(`First value greater than 2: ${result}`), \n  err => console.error(err) \n);",or=r(["const { of } = rxjs;","const { find } = rxjs.operators;"],Z),H="import { of } from 'rxjs'; \nimport { findIndex } from 'rxjs/operators'; \n\nconst source = of(10, 20, 30, 40, 50); \n\nsource.pipe( \n  findIndex(x => x > 35) // Find the index of the first value greater than 35 \n).subscribe( \n  result => console.log(`Index of the first value greater than 35: ${result}`), \n  err => console.error(err) \n);",sr=r(["const { of } = rxjs;","const { findIndex } = rxjs.operators;"],H),L="import { of } from 'rxjs'; \nimport { isEmpty } from 'rxjs/operators'; \n\nconst source1 = of(); \nconst source2 = of(1, 2, 3); \n\nsource1.pipe( \n  isEmpty() // Check if the Observable is empty \n).subscribe( \n  result => console.log(`Is source1 empty? ${result}`), \n  err => console.error(err) \n); \n\nsource2.pipe( \n  isEmpty() // Check if the Observable is empty \n).subscribe( \n  result => console.log(`Is source2 empty? ${result}`), \n  err => console.error(err) \n);",nr=r(["const { of } = rxjs;","const { isEmpty } = rxjs.operators;"],L),z="import { of } from 'rxjs'; \nimport { tap } from 'rxjs/operators'; \n\nconst source = of(1, 2, 3); \n\nsource.pipe( \n  tap(value => console.log(`Logging value: ${value}`)) \n).subscribe( \n  value => console.log(value), \n  err => console.error(err), \n  () => console.log('Complete') \n);",tr=r(["const { of } = rxjs;","const { tap } = rxjs.operators;"],z),P="import { of } from 'rxjs';\nimport { delay } from 'rxjs/operators';\n\nconst source = of(1, 2, 3);\n\nsource.pipe(\n  delay(2000) // Delay by 2 seconds\n).subscribe(\n  value => console.log(value),\n  err => console.error(err),\n  () => console.log('Complete')\n);",cr=r(["const { of } = rxjs;","const { delay } = rxjs.operators;"],P),X="import { of } from 'rxjs';\nimport { finalize } from 'rxjs/operators';\n\nconst source = of(1, 2, 3);\n\nsource.pipe(\n  finalize(() => console.log('Observation complete'))\n).subscribe(\n  value => console.log(value),\n  err => console.error(err)\n);",ar=r(["const { of } = rxjs;","const { finalize } = rxjs.operators;"],X),K="import { interval } from 'rxjs';\nimport { take, timeout } from 'rxjs/operators';\n\nconst source = interval(1000).pipe(take(10));\n\nsource.pipe(\n  timeout(2000) // Timeout after 2 seconds\n).subscribe(\n  value => console.log(value),\n  err => console.error(err)\n);",lr=r(["const { interval } = rxjs;","const { take, timeout } = rxjs.operators;"],K),G="import { of, throwError } from 'rxjs'; \nimport { catchError } from 'rxjs/operators'; \n\nconst source = throwError('An error occurred'); \n\nsource.pipe( \n  catchError(error => of(`Error handled: ${error}`)) \n).subscribe( \n  value => console.log(value), \n  err => console.error(`Caught error: ${err}`) \n);",_r=r(["const { of, throwError } = rxjs;","const { catchError } = rxjs.operators;"],G),q="import { of } from 'rxjs'; \nimport { retry, tap } from 'rxjs/operators'; \n\nconst source = of('A', 'B', 'C'); \n\nsource.pipe( \n  tap(value => { \n    if (value === 'C') \n      throw new Error('An error occurred'); \n  }), \n  retry(2) // Retry up to 2 times \n).subscribe( \n  value => console.log(value), \n  err => console.error(err) \n);",ir=r(["const { of } = rxjs;","const { tap, retry } = rxjs.operators;"],q),ee="import { of, throwError, timer } from 'rxjs'; \nimport { mergeMap, retryWhen, take } from 'rxjs/operators'; \n\nlet retryCount = 0; \n\nconst source = of('A', 'B', 'C'); \n\nsource.pipe( \n  tap(value => { \n    if (value === 'C') \n      throw new Error('An error occurred'); \n  }), \n  retryWhen(errors => \n    errors.pipe( \n      mergeMap((error, index) => { \n        if (index < 2) { \n          retryCount++; \n          console.error(`Error encountered (${retryCount} retries): ${error}`); \n          return timer(2000); // Retry after a delay \n        } else { \n          return throwError(error); // Stop retrying after 2 retries \n        } \n      }) \n    ) \n  ) \n).subscribe( \n  value => console.log(value), \n  err => console.error(`Final error: ${err}`) \n);",ur=r(["const { of, throwError, timer } = rxjs;","const { mergeMap, retryWhen, take, tap } = rxjs.operators;"],ee),re="import { of } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\n\nconst source = of(1, 2, 3, 4, 5);\n\nsource.pipe(\n  filter(x => x % 2 === 0), // Only even numbers\n  map(x => x * 2)           // Double the values\n).subscribe(result => console.log(result));",pr=r(["const { of } = rxjs;","const { map, filter } = rxjs.operators;"],re),br="import { of } from 'rxjs';\n\nconst source = of(1, 2, 3, 4, 5);\n\nsource\n  .filter(x => x % 2 === 0) // Only even numbers\n  .map(x => x * 2)          // Double the values\n  .subscribe(result => console.log(result));",oe="import { interval, of } from 'rxjs'; \nimport { concatMap, map, take } from 'rxjs/operators'; \n\nconst source = of(1, 2, 3); \n\nsource.pipe( \n  concatMap(value => \n    interval(1000).pipe( \n      take(3), \n      map(innerValue => `Source: ${value}, Inner: ${innerValue}`) \n    ) \n  ) \n).subscribe(result => console.log(result));",xr=r(["const { of, interval } = rxjs;","const { concatMap, map, take } = rxjs.operators;"],oe),se="import { of } from 'rxjs'; \nimport { delay, mergeMap } from 'rxjs/operators'; \n\nconst source = of(1, 2, 3); \n\nsource.pipe( \n  mergeMap(value => \n    of(`Processed: ${value}`).pipe( \n      delay(1000 / value) // Simulate some async processing. The value takes on 1, 2, and 3 respectively \n    ) \n  ) \n).subscribe(result => console.log(result));",jr=r(["const { of } = rxjs;","const { delay, mergeMap } = rxjs.operators;"],se),ne="import { interval, of } from 'rxjs'; \nimport { map, switchMap, take } from 'rxjs/operators'; \n\nconst source = of(1, 2, 3); \n\nsource.pipe( \n  switchMap(value => \n    interval(1000).pipe( \n      take(3), \n      map(innerValue => `Source: ${value}, Inner: ${innerValue}`) \n    ) \n  ) \n).subscribe(result => console.log(result));",mr=r(["const { interval, of  } = rxjs;","const { map, switchMap, take } = rxjs.operators;"],ne),te="import { interval, of } from 'rxjs'; \nimport { exhaustMap, take } from 'rxjs/operators'; \n\n// Source observable emits values 1, 2, 3 \nconst source = of(1, 2, 3); \n\nsource.pipe( \n  exhaustMap(value => { \n    // Inner observable emits values based on source value \n    return interval(1000).pipe( \n      take(3), // Limit inner observable to emit 3 values \n      map(innerValue => `${value}-${innerValue}`) \n    ); \n  }) \n) \n.subscribe(result => { \n  console.log(result); \n});",vr=r(["const { interval, of  } = rxjs;","const { map, exhaustMap, take } = rxjs.operators;"],te),ce="import { fromEvent } from 'rxjs'; \nimport { debounceTime, map } from 'rxjs/operators'; \n\n// Create an observable from input events (e.g., user typing) \nconst input = document.getElementById('search-input'); \nconst inputs = fromEvent(input, 'input'); \n\ninputs.pipe( \n  debounceTime(300), // Wait for 300 milliseconds of inactivity \n  map(event => event.target.value) \n).subscribe(value => console.log('Input Value:', value));",fr=r(["const { fromEvent  } = rxjs;","const { debounceTime, map } = rxjs.operators;"],ce,'<label>Key in rapidly! </label><input id="search-input">'),ae="import { fromEvent } from 'rxjs'; \nimport { map, throttleTime } from 'rxjs/operators'; \n\n// Create an observable from mousemove events \nconst mousemove = fromEvent(document, 'mousemove'); \n\nmousemove.pipe( \n  throttleTime(1000), // Allow one event per 1000 milliseconds \n  map(event => `Mouse Position: (${event.clientX}, ${event.clientY})`) \n).subscribe(position => console.log(position));",hr=r(["const { fromEvent  } = rxjs;","const { map, throttleTime } = rxjs.operators;"],ae,"<p>Move mouse in this area!</p>"),le="import { fromEvent, interval } from 'rxjs'; \nimport { buffer, take } from 'rxjs/operators'; \n\n// Create a source observable that emits values every 500ms \nconst source = interval(500).pipe(take(20)); \n\n// Create a signal observable that emits values every 2000ms (2 seconds) \nconst signal = interval(2000).pipe(take(5)); \n\n// Use buffer to collect values from the source based on the signal \nconst bufferedSource = source.pipe(buffer(signal)); \n\n// Subscribe to the buffered source \nbufferedSource.subscribe(buffer => { \n  console.log('Buffered Values:', buffer); \n});",dr=r(["const { fromEvent, interval } = rxjs;","const { buffer, take } = rxjs.operators;"],le),_e="import { interval } from 'rxjs'; \nimport { mergeAll, take, window as win } from 'rxjs/operators'; \n\n// Create a source observable that emits values every 500ms \nconst source = interval(500); \n\n// Create a boundary observable that emits values every 2000ms (2 seconds) \nconst boundary = interval(2000); \n\n// Use window to create windows based on the boundary \nconst windowedSource = source.pipe(win(boundary)); \n\n// Merge all windows into a single observable \nconst mergedWindows = windowedSource.pipe(mergeAll()); \n\n// Take the first 3 values from each window \nconst result = mergedWindows.pipe(take(9)); \n\n// Subscribe to the result \nresult.subscribe(value => { \n  console.log('Value:', value); \n});",gr=r(["const { interval } = rxjs;","const { mergeAll, take, window: win } = rxjs.operators;"],_e),ie="import { of, pipe } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\n\n// The customOperator function is defined, taking a predicate as an argument\nconst customOperator = (predicate) => pipe(\n  filter(predicate),\n  map(value => value * 2)\n);\n\n// An observable named source is defined\nconst source = of(2, 4, 6, 8, 10);\n\n// The customOperator is applied to the source observable with a predicate function\nsource.pipe(\n  customOperator(x => x > 5)\n).subscribe(result => {\n  console.log(result);// Output: 12, 16, 20\n});",yr=r(["const { of, pipe } = rxjs;","const { filter, map } = rxjs.operators;"],ie),ue="import { Observable } from 'rxjs';\n\n// Define the custom operator function\nfunction multiplyBy(factor) {\n  // Return a function that takes the source observable as an argument\n  return (source) => {\n    // Create and return a new observable\n    return new Observable((observer) => {\n      // Subscribe to the source observable\n      const subscription = source.subscribe({\n        next(value) {\n          // Multiply the value by the specified factor\n          const result = value * factor;\n          // Emit the transformed value\n          observer.next(result);\n        },\n        error(error) {\n          // Pass along any errors\n          observer.error(error);\n        },\n        complete() {\n          // Complete the observer when the source completes\n          observer.complete();\n        },\n      });\n\n      // Return a cleanup function to unsubscribe from the source\n      return () => {\n        subscription.unsubscribe();\n      };\n    });\n  };\n}\n\n// Create an example observable\nconst source = new Observable((observer) => {\n  observer.next(1);\n  observer.next(2);\n  observer.next(3);\n  observer.complete();\n});\n\n// Use the custom operator\nsource.pipe(\n  multiplyBy(10) // Multiply each value by 10\n).subscribe((result) => {\n  console.log(result); // Output: 10, 20, 30\n});",Sr=r(["const { Observable } = rxjs;"],ue),pe="import { Subject } from 'rxjs'; \n\n// Create a new Subject \nconst subject = new Subject(); \n\n// Subscribe multiple observers to the Subject \nsubject.subscribe({ \n  next: value => console.log(`Observer A: ${value}`) \n}); \n\nsubject.subscribe({ \n  next: value => console.log(`Observer B: ${value}`) \n}); \n\n// Emit values from the Subject \nsubject.next(1); // Emits to both Observer A and Observer B \nsubject.next(2); // Emits to both Observer A and Observer B",Cr=r(["const { Subject } = rxjs;"],pe),be="import { BehaviorSubject } from 'rxjs';\n\n// Create a BehaviorSubject with an initial value\nconst behaviorSubject = new BehaviorSubject('Initial value');\n\n// Subscribe to the BehaviorSubject\nbehaviorSubject.subscribe(value => console.log('Observer 1:', value)); // Outputs: Observer 1: Initial value\n\n// Emit a new value\nbehaviorSubject.next('New value'); // Outputs: Observer 1: New value\n\n// Subscribe to the BehaviorSubject after a value has been emitted\nbehaviorSubject.subscribe(value => console.log('Observer 2:', value)); // Outputs: Observer 2: New value",Or=r(["const { BehaviorSubject } = rxjs;"],be),xe="import { ReplaySubject } from 'rxjs';\n\n// Create a ReplaySubject that replays the last 2 values\nconst replaySubject = new ReplaySubject(2);\n\n// Emit values to the ReplaySubject\nreplaySubject.next('Value 1');\nreplaySubject.next('Value 2');\nreplaySubject.next('Value 3');\n\n// Subscribe to the ReplaySubject\nreplaySubject.subscribe(value => console.log('Observer 1:', value)); // Outputs: Observer 1: Value 2, Observer 1: Value 3\n\n// Emit another value\nreplaySubject.next('Value 4');\n\n// Subscribe to the ReplaySubject after values have been emitted\nreplaySubject.subscribe(value => console.log('Observer 2:', value)); // Outputs: Observer 2: Value 3, Observer 2: Value 4",kr=r(["const { ReplaySubject } = rxjs;"],xe),je="import { AsyncSubject } from 'rxjs';\n\n// Create an AsyncSubject\nconst asyncSubject = new AsyncSubject();\n\n// Subscribe to the AsyncSubject\nasyncSubject.subscribe(value => console.log('Observer 1:', value));\n\n// Emit values to the AsyncSubject\nasyncSubject.next('Value 1');\nasyncSubject.next('Value 2');\n\n// Complete the AsyncSubject\nasyncSubject.complete();\n\n// Subscribe to the AsyncSubject after completion\nasyncSubject.subscribe(value => console.log('Observer 2:', value)); // Outputs: Observer 2: Value 2",wr=r(["const { AsyncSubject } = rxjs;"],je),Er="import { of } from 'rxjs';\n\nconst coldObservable = of(1, 2, 3);\n\n// Subscribers get independent streams\ncoldObservable.subscribe(value => console.log('Subscriber A:', value));\ncoldObservable.subscribe(value => console.log('Subscriber B:', value));",$r="import { Subject } from 'rxjs';\n\nconst hotObservable = new Subject();\n\nhotObservable.subscribe(value => console.log('Subscriber A:', value));\nhotObservable.subscribe(value => console.log('Subscriber B:', value));\n\nhotObservable.next(1); // Both subscribers receive the same value";var me=c(294),u=c(1481),Ar=c(3353),Br=c(7913),Rr=c(5342);function Tr(o,n){if(1&o&&(e.TgZ(0,"h2",null,4),e._uU(2),e.qZA()),2&o){const s=e.oxw(2);e.xp6(2),e.AsE("",null==s.chapter?null:s.chapter.chid,". ",null==s.chapter?null:s.chapter.title,"")}}function Mr(o,n){if(1&o&&(e.ynx(0),e.YNc(1,Tr,3,2,"h2",1),e.BQk()),2&o){const s=e.oxw();e.xp6(1),e.Q6J("ngIf",null==s.chapter?null:s.chapter.chid)}}function Ir(o,n){if(1&o&&e._UZ(0,"p",8),2&o){const s=e.oxw().$implicit,t=e.oxw(3);e.Q6J("innerHTML",t.bypass(null==s?null:s.text),e.oJD)}}function Vr(o,n){if(1&o&&e._UZ(0,"p",8),2&o){const s=e.oxw().$implicit,t=e.oxw(3);e.Q6J("innerHTML",t.bypass(null==s?null:s.text),e.oJD)}}function Yr(o,n){if(1&o&&(e.TgZ(0,"p"),e._UZ(1,"app-code-viewer",9),e.qZA()),2&o){const s=e.oxw().$implicit,t=e.oxw(3);e.xp6(1),e.Q6J("lang","JS")("codeConfig",t.rectify(s.codeConfig))}}function Jr(o,n){if(1&o&&(e.ynx(0),e.YNc(1,Ir,1,1,"p",7),e.YNc(2,Vr,1,1,"p",7),e.YNc(3,Yr,2,2,"p",1),e.BQk()),2&o){const s=n.$implicit;e.xp6(1),e.Q6J("ngIf",!s.codeid&&!s.isShortCode),e.xp6(1),e.Q6J("ngIf",!s.codeid&&s.isShortCode),e.xp6(1),e.Q6J("ngIf",s.codeConfig)}}function Ur(o,n){if(1&o&&(e.ynx(0),e.TgZ(1,"h3",5,6),e._uU(3),e.qZA(),e.YNc(4,Jr,4,3,"ng-container",2),e.BQk()),2&o){const s=e.oxw().$implicit,t=e.oxw();e.xp6(1),e.cQ8("id","",null==t.chapter?null:t.chapter.category,"-ch-",null==t.chapter?null:t.chapter.chid,"-sec-",null==s?null:s.secid,""),e.xp6(2),e.hij(" ",s.subtitle," "),e.xp6(1),e.Q6J("ngForOf",null==s?null:s.paragraphs)}}function Qr(o,n){if(1&o&&(e.ynx(0),e.YNc(1,Ur,5,5,"ng-container",1),e.BQk()),2&o){const s=n.$implicit,t=e.oxw();e.xp6(1),e.Q6J("ngIf",s.secid===+t.secid)}}let l=(()=>{class o extends fe.H{constructor(s,t,p,Nr,Zr,Hr,Lr,zr,Pr){super(s,t,p,Nr,Zr,Hr,Lr,zr,Pr),this.codeData=i}ngOnInit(){super.ngOnInit()}ngOnDestroy(){super.ngOnDestroy()}}return o.\u0275fac=function(s){return new(s||o)(e.Y36(me.X),e.Y36(u.h_),e.Y36(u.Dx),e.Y36(Ar.t4),e.Y36(u.H7),e.Y36(a.F0),e.Y36(a.gz),e.Y36(_.Ye),e.Y36(x.p))},o.\u0275cmp=e.Xpm({type:o,selectors:[["app-rxjs-chapter"]],features:[e.qOj],decls:5,vars:2,consts:[[1,"chapter-container"],[4,"ngIf"],[4,"ngFor","ngForOf"],[1,"navigator-container"],["h2",""],[3,"id"],["h3s",""],[3,"innerHTML",4,"ngIf"],[3,"innerHTML"],[3,"lang","codeConfig"]],template:function(s,t){1&s&&(e.TgZ(0,"div",0),e.YNc(1,Mr,2,1,"ng-container",1),e.YNc(2,Qr,2,1,"ng-container",2),e.TgZ(3,"div",3),e._UZ(4,"app-chapter-navigator"),e.qZA()()),2&s&&(e.xp6(1),e.Q6J("ngIf","1"===t.secid),e.xp6(1),e.Q6J("ngForOf",null==t.chapter?null:t.chapter.sections))},dependencies:[_.sg,_.O5,Br.R,Rr.V],styles:[".chapter-container[_ngcontent-%COMP%]{margin:1rem}"]}),o})();const Fr=[{path:"",component:ve,children:[{path:"chapter",component:l},{path:"chapter/:chid",component:l},{path:"chapter/:chid/section/:secid",component:l},{path:"**",component:l},{path:"",component:l}]}];let Wr=(()=>{class o{}return o.\u0275fac=function(s){return new(s||o)},o.\u0275mod=e.oAB({type:o}),o.\u0275inj=e.cJS({imports:[a.Bz.forChild(Fr),a.Bz]}),o})(),Dr=(()=>{class o{}return o.\u0275fac=function(s){return new(s||o)},o.\u0275mod=e.oAB({type:o}),o.\u0275inj=e.cJS({imports:[_.ez,Wr,me.I]}),o})()}}]);